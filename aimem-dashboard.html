<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>aimem Dashboard - aimem</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      color: #eee;
      height: 100vh;
      overflow: hidden;
    }

    /* Header */
    .header {
      background: #16213e;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #0f3460;
    }

    .header h1 {
      font-size: 18px;
      font-weight: 500;
      color: #e94560;
    }

    .header h1 span {
      color: #eee;
      font-weight: 400;
    }

    .search-box {
      display: flex;
      gap: 8px;
    }

    .search-box input {
      background: #0f3460;
      border: 1px solid #1a1a2e;
      color: #eee;
      padding: 6px 12px;
      border-radius: 4px;
      width: 200px;
    }

    .search-box input::placeholder {
      color: #666;
    }

    /* View mode toggle */
    .view-toggle {
      display: flex;
      background: #0f3460;
      border-radius: 4px;
      overflow: hidden;
    }

    .view-toggle-btn {
      background: transparent;
      border: none;
      color: #888;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
    }

    .view-toggle-btn:hover {
      color: #ccc;
    }

    .view-toggle-btn.active {
      background: #e94560;
      color: white;
    }

    .back-btn {
      background: #0f3460;
      border: 1px solid #1a1a2e;
      color: #aaa;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      display: none;
    }

    .back-btn:hover {
      background: #1a1a2e;
      color: #fff;
    }

    .back-btn.visible {
      display: inline-block;
    }

    .fullscreen-btn {
      background: #0f3460;
      border: 1px solid #1a1a2e;
      color: #aaa;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .fullscreen-btn:hover {
      background: #1a1a2e;
      color: #fff;
    }

    /* Fullscreen mode */
    body.fullscreen .sidebar,
    body.fullscreen .details-panel,
    body.fullscreen .header,
    body.fullscreen .tabs {
      display: none;
    }

    body.fullscreen .main {
      height: 100vh;
    }

    body.fullscreen .graph-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
    }

    body.fullscreen .view-description {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1001;
    }

    body.fullscreen .stats-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 1001;
    }

    body.fullscreen .exit-fullscreen {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 1002;
      background: rgba(22, 33, 62, 0.9);
      color: #ccc;
      border: 1px solid #0f3460;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      backdrop-filter: blur(4px);
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    body.fullscreen .exit-fullscreen:hover {
      background: rgba(233, 69, 96, 0.9);
      color: white;
      border-color: #e94560;
    }

    /* Fullscreen details panel - slides in from right */
    body.fullscreen .details-panel {
      display: none;
      position: fixed;
      top: 60px;
      right: 16px;
      bottom: 16px;
      width: 380px;
      z-index: 1001;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      background: rgba(22, 33, 62, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid #0f3460;
    }

    body.fullscreen .details-panel.visible {
      display: flex;
    }

    body.fullscreen .details-panel .details-header {
      position: relative;
    }

    body.fullscreen .details-panel .close-details {
      display: block;
    }

    .close-details {
      display: none;
      background: none;
      border: none;
      color: #888;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
    }

    .close-details:hover {
      color: #e94560;
    }

    /* Visualize button in details panel */
    .visualize-btn {
      background: #e94560;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      width: 100%;
      margin-top: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: background 0.2s;
    }

    .visualize-btn:hover {
      background: #d63d56;
    }

    .visualize-btn:disabled {
      background: #475569;
      cursor: not-allowed;
    }

    .visualize-btn-group {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .visualize-btn-group .visualize-btn {
      flex: 1;
      margin-top: 0;
      padding: 8px 12px;
      font-size: 12px;
    }

    .visualize-btn-group .visualize-btn.secondary {
      background: #0f3460;
      color: #ccc;
    }

    .visualize-btn-group .visualize-btn.secondary:hover {
      background: #1a4a7a;
      color: #fff;
    }

    /* Smooth transitions for fullscreen */
    .main, .graph-container, #cy {
      transition: all 0.2s ease;
    }

    /* Tabs */
    .tabs {
      background: #16213e;
      display: flex;
      gap: 0;
      border-bottom: 1px solid #0f3460;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      color: #888;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab:hover {
      color: #ccc;
      background: rgba(233, 69, 96, 0.1);
    }

    .tab.active {
      color: #e94560;
      border-bottom-color: #e94560;
    }

    /* Main layout */
    .main {
      display: flex;
      height: calc(100vh - 90px);
      min-height: 0;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: #16213e;
      padding: 16px;
      border-right: 1px solid #0f3460;
      overflow-y: auto;
    }

    .sidebar h3 {
      font-size: 12px;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 12px;
    }

    .filter-group {
      margin-bottom: 20px;
    }

    .filter-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      cursor: pointer;
    }

    .filter-item input {
      accent-color: #e94560;
    }

    .filter-item label {
      font-size: 13px;
      cursor: pointer;
    }

    .filter-item .count {
      margin-left: auto;
      font-size: 11px;
      color: #666;
      background: #0f3460;
      padding: 2px 6px;
      border-radius: 10px;
    }

    .layout-select {
      width: 100%;
      background: #0f3460;
      border: 1px solid #1a1a2e;
      color: #eee;
      padding: 8px;
      border-radius: 4px;
      margin-top: 8px;
    }

    /* Graph container */
    .graph-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0; /* Important for flex overflow */
      min-width: 0;
      position: relative;
    }

    #cy {
      flex: 1;
      background: #1a1a2e;
      min-height: 0;
    }

    /* Details panel */
    .details-panel {
      width: 350px;
      background: #16213e;
      border-left: 1px solid #0f3460;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .details-header {
      padding: 12px 16px;
      border-bottom: 1px solid #0f3460;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .details-header h3 {
      font-size: 14px;
      font-weight: 500;
    }

    .details-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .detail-row {
      margin-bottom: 12px;
    }

    .detail-label {
      font-size: 11px;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 4px;
    }

    .detail-value {
      font-size: 13px;
      color: #eee;
    }

    .detail-value a {
      color: #e94560;
      text-decoration: none;
    }

    .detail-value a:hover {
      text-decoration: underline;
    }

    /* Code block */
    .code-block {
      background: #0f3460;
      border-radius: 4px;
      padding: 12px;
      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      line-height: 1.5;
      overflow-x: auto;
      white-space: pre;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Tags */
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
    }

    .tag.function { background: #2563eb; color: white; }
    .tag.class { background: #7c3aed; color: white; }
    .tag.method { background: #0891b2; color: white; }
    .tag.interface { background: #059669; color: white; }
    .tag.type { background: #d97706; color: white; }
    .tag.variable { background: #dc2626; color: white; }
    .tag.module { background: #4f46e5; color: white; }
    .tag.file { background: #475569; color: white; }
    .tag.decision { background: #16a34a; color: white; }
    .tag.pattern { background: #0d9488; color: white; }
    .tag.rejection { background: #dc2626; color: white; }

    /* List view */
    #list-view {
      display: none;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 16px;
      background: #1a1a2e;
      min-height: 0; /* Important for flex overflow */
    }

    #list-view.active {
      display: flex;
      flex-direction: column;
    }

    #list-view .list-content {
      flex: 1;
      overflow-y: auto;
    }

    #cy.hidden {
      display: none !important;
    }

    .list-section {
      margin-bottom: 24px;
    }

    .list-section h4 {
      font-size: 12px;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #0f3460;
      position: sticky;
      top: 0;
      background: #1a1a2e;
      z-index: 10;
      padding-top: 8px;
    }

    .list-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 10px 12px;
      background: #16213e;
      border-radius: 4px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.2s;
      max-width: 100%;
      overflow: hidden;
    }

    .list-item:hover {
      background: #1e2a4a;
    }

    .list-item .tag {
      flex-shrink: 0;
    }

    .list-item-content {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .list-item-name {
      font-weight: 500;
      color: #eee;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .list-item-location {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .list-item-signature {
      font-size: 11px;
      color: #888;
      font-family: 'Fira Code', monospace;
      margin-top: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Stats bar */
    .stats-bar {
      padding: 8px 16px;
      background: #0f3460;
      display: flex;
      gap: 20px;
      font-size: 12px;
      color: #888;
    }

    .stat {
      display: flex;
      gap: 4px;
    }

    .stat-value {
      color: #e94560;
      font-weight: 500;
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 60px;
      left: 16px;
      background: rgba(22, 33, 62, 0.95);
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 11px;
      z-index: 100;
      backdrop-filter: blur(4px);
      transition: opacity 0.2s;
    }

    /* Hide legend in list view */
    .legend.hidden {
      display: none;
    }

    .legend-title {
      font-weight: 600;
      color: #888;
      margin-bottom: 8px;
      text-transform: uppercase;
      font-size: 10px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      color: #ccc;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-shape {
      width: 16px;
      height: 10px;
      border-radius: 3px;
    }

    /* Breadcrumb */
    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: #0f3460;
      font-size: 12px;
      color: #888;
      border-bottom: 1px solid #1a1a2e;
    }

    .breadcrumb-item {
      color: #888;
      cursor: pointer;
      transition: color 0.2s;
    }

    .breadcrumb-item:hover {
      color: #e94560;
    }

    .breadcrumb-item.current {
      color: #eee;
      cursor: default;
    }

    .breadcrumb-sep {
      color: #444;
    }

    /* Tooltip */
    #tooltip {
      position: fixed;
      background: rgba(22, 33, 62, 0.98);
      border: 1px solid #0f3460;
      border-radius: 6px;
      padding: 10px 14px;
      font-size: 12px;
      color: #eee;
      pointer-events: none;
      z-index: 2000;
      max-width: 350px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      display: none;
    }

    #tooltip.visible {
      display: block;
    }

    #tooltip .tip-type {
      font-size: 10px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 4px;
    }

    #tooltip .tip-name {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 6px;
    }

    #tooltip .tip-location {
      font-size: 11px;
      color: #666;
      margin-bottom: 6px;
    }

    #tooltip .tip-hint {
      font-size: 10px;
      color: #e94560;
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid #0f3460;
    }

    /* Welcome overlay */
    .welcome-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(22, 33, 62, 0.98);
      border: 1px solid #0f3460;
      border-radius: 12px;
      padding: 32px 40px;
      text-align: center;
      z-index: 500;
      max-width: 400px;
    }

    .welcome-overlay h2 {
      color: #e94560;
      margin-bottom: 16px;
      font-size: 20px;
    }

    .welcome-overlay p {
      color: #aaa;
      margin-bottom: 12px;
      line-height: 1.5;
    }

    .welcome-overlay .hint {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: #0f3460;
      border-radius: 6px;
      margin: 8px 0;
      text-align: left;
      font-size: 13px;
    }

    .welcome-overlay .hint-icon {
      font-size: 18px;
    }

    .welcome-overlay button {
      background: #e94560;
      color: white;
      border: none;
      padding: 12px 32px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 16px;
    }

    .welcome-overlay button:hover {
      background: #d63d56;
    }

    /* View description */
    .view-description {
      padding: 10px 16px;
      background: #0f3460;
      border-bottom: 1px solid #1a1a2e;
      font-size: 13px;
      color: #aaa;
      line-height: 1.4;
    }

    .view-description strong {
      color: #e94560;
    }

    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
    }

    .empty-state h3 {
      margin-bottom: 8px;
    }

    /* Tooltip */
    .cy-tooltip {
      position: absolute;
      background: #16213e;
      border: 1px solid #0f3460;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>aimem <span>Dashboard: aimem</span></h1>
    <div class="search-box">
      <input type="text" id="search" placeholder="Search nodes...">
      <button class="back-btn" id="back-btn" title="Go back">‚Üê Back</button>
      <div class="view-toggle">
        <button class="view-toggle-btn active" data-mode="visual">Visual</button>
        <button class="view-toggle-btn" data-mode="list">List</button>
      </div>
      <button class="fullscreen-btn" id="fullscreen-btn" title="Toggle fullscreen">Fullscreen</button>
    </div>
  </div>

  <div class="tabs">
    <div class="tab active" data-view="overview">Overview</div>
    <div class="tab" data-view="callGraph">Call Graph</div>
    <div class="tab" data-view="dependencies">Dependencies</div>
    <div class="tab" data-view="classes">Classes</div>
    <div class="tab" data-view="decisions">Decisions</div>
  </div>

  <button class="exit-fullscreen" id="exit-fullscreen" style="display: none;">Exit Fullscreen (ESC)</button>

  <div class="main">
    <div class="sidebar">
      <div class="filter-group">
        <h3>Filter by Type</h3>
        <div class="filter-item">
          <input type="checkbox" id="filter-function" checked>
          <label for="filter-function">Functions</label>
          <span class="count">297</span>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-class" checked>
          <label for="filter-class">Classes</label>
          <span class="count">48</span>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-method" checked>
          <label for="filter-method">Methods</label>
          <span class="count">19</span>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-interface" checked>
          <label for="filter-interface">Interfaces</label>
          <span class="count">48</span>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-type" checked>
          <label for="filter-type">Types</label>
          <span class="count">15</span>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-file" checked>
          <label for="filter-file">Files</label>
          <span class="count">61</span>
        </div>
      </div>

      <div class="filter-group">
        <h3>Layout</h3>
        <select class="layout-select" id="layout-select">
          <option value="grid">Grid</option>
          <option value="cose">Force Directed</option>
          <option value="breadthfirst">Hierarchical</option>
          <option value="circle">Circular</option>
          <option value="concentric">Concentric</option>
        </select>
      </div>

      <div class="filter-group" id="flow-mode-group" style="display: none;">
        <h3>Flow Mode</h3>
        <div class="filter-item">
          <input type="radio" name="flow-mode" id="flow-connections" value="connections" checked>
          <label for="flow-connections">Connections</label>
        </div>
        <div class="filter-item">
          <input type="radio" name="flow-mode" id="flow-downstream" value="downstream">
          <label for="flow-downstream">Downstream (calls)</label>
        </div>
        <div class="filter-item">
          <input type="radio" name="flow-mode" id="flow-upstream" value="upstream">
          <label for="flow-upstream">Upstream (callers)</label>
        </div>
        <p style="font-size: 11px; color: #666; margin-top: 8px;">Click a function to trace its flow</p>
      </div>
    </div>

    <div class="graph-container">
      <div class="breadcrumb" id="breadcrumb">
        <span class="breadcrumb-item current">Project</span>
      </div>
      <div class="view-description" id="view-description">
        <strong>Overview</strong> - All files in your codebase. Each node shows the file name and number of structures (functions, classes, etc.) it contains. Click a file to see details.
      </div>
      <div id="cy"></div>
      <div id="list-view"></div>

      <!-- Legend -->
      <div class="legend" id="legend">
        <div class="legend-title">Legend</div>
        <div class="legend-item"><span class="legend-shape" style="background: #475569;"></span> File</div>
        <div class="legend-item"><span class="legend-dot" style="background: #2563eb;"></span> Function</div>
        <div class="legend-item"><span class="legend-dot" style="background: #7c3aed;"></span> Class</div>
        <div class="legend-item"><span class="legend-dot" style="background: #0891b2;"></span> Method</div>
        <div class="legend-item"><span class="legend-dot" style="background: #059669;"></span> Interface</div>
      </div>

      <!-- Tooltip -->
      <div id="tooltip">
        <div class="tip-type"></div>
        <div class="tip-name"></div>
        <div class="tip-location"></div>
        <div class="tip-hint">Double-click to explore</div>
      </div>

      <!-- Welcome overlay (shown on first visit) -->
      <div class="welcome-overlay" id="welcome" style="display: none;">
        <h2>Explore Your Code</h2>
        <p>Navigate your codebase like a map:</p>
        <div class="hint"><strong>Click</strong> - See details and source code</div>
        <div class="hint"><strong>Double-click</strong> - Dive deeper into that item</div>
        <div class="hint"><strong>Hover</strong> - See what is connected</div>
        <div class="hint"><strong>Search</strong> - Find anything by name</div>
        <button onclick="dismissWelcome()">Start Exploring</button>
      </div>

      <div class="stats-bar">
        <div class="stat"><span class="stat-value">427</span> structures</div>
        <div class="stat"><span class="stat-value">61</span> files</div>
        <div class="stat"><span class="stat-value">359</span> links</div>
        <div class="stat"><span class="stat-value">23</span> decisions</div>
      </div>
    </div>

    <div class="details-panel" id="details-panel">
      <div class="details-header">
        <h3>Details</h3>
        <button class="close-details" id="close-details" title="Close">&times;</button>
      </div>
      <div class="details-content" id="details-content">
        <div class="empty-state">
          <h3>No selection</h3>
          <p>Click a node to view details</p>
        </div>
      </div>
    </div>
  </div>

  <script id="viz-data" type="application/json">{"project":{"id":1,"path":"/mnt/c/Users/mrcdc/OneDrive/Documents2/repos/aimem","name":"aimem","created_at":"2025-12-13 03:42:40"},"graphs":{"overview":{"nodes":[{"data":{"id":"file:dist-test/src/cli/commands/import.js","label":"import.js (15)","type":"file","file":"dist-test/src/cli/commands/import.js","content":"Contains 15 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/init.js","label":"init.js (1)","type":"file","file":"dist-test/src/cli/commands/init.js","content":"Contains 1 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/mcp-serve.js","label":"mcp-serve.js (1)","type":"file","file":"dist-test/src/cli/commands/mcp-serve.js","content":"Contains 1 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/query.js","label":"query.js (3)","type":"file","file":"dist-test/src/cli/commands/query.js","content":"Contains 3 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/setup.js","label":"setup.js (15)","type":"file","file":"dist-test/src/cli/commands/setup.js","content":"Contains 15 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/start.js","label":"start.js (5)","type":"file","file":"dist-test/src/cli/commands/start.js","content":"Contains 5 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/status.js","label":"status.js (3)","type":"file","file":"dist-test/src/cli/commands/status.js","content":"Contains 3 structures: function"}},{"data":{"id":"file:dist-test/src/cli/commands/stop.js","label":"stop.js (2)","type":"file","file":"dist-test/src/cli/commands/stop.js","content":"Contains 2 structures: function"}},{"data":{"id":"file:dist-test/src/db/index.js","label":"index.js (34)","type":"file","file":"dist-test/src/db/index.js","content":"Contains 34 structures: function"}},{"data":{"id":"file:dist-test/src/extractor/index.js","label":"index.js (9)","type":"file","file":"dist-test/src/extractor/index.js","content":"Contains 9 structures: function"}},{"data":{"id":"file:dist-test/src/indexer/index.js","label":"index.js (6)","type":"file","file":"dist-test/src/indexer/index.js","content":"Contains 6 structures: function"}},{"data":{"id":"file:dist-test/src/indexer/parsers/base.js","label":"base.js (2)","type":"file","file":"dist-test/src/indexer/parsers/base.js","content":"Contains 2 structures: function"}},{"data":{"id":"file:dist-test/src/indexer/parsers/go.js","label":"go.js (3)","type":"file","file":"dist-test/src/indexer/parsers/go.js","content":"Contains 3 structures: interface, type, function"}},{"data":{"id":"file:dist-test/src/indexer/parsers/javascript.js","label":"javascript.js (6)","type":"file","file":"dist-test/src/indexer/parsers/javascript.js","content":"Contains 6 structures: function, class, interface, type"}},{"data":{"id":"file:dist-test/src/indexer/parsers/python.js","label":"python.js (3)","type":"file","file":"dist-test/src/indexer/parsers/python.js","content":"Contains 3 structures: class, function"}},{"data":{"id":"file:dist-test/src/indexer/parsers/ruby.js","label":"ruby.js (2)","type":"file","file":"dist-test/src/indexer/parsers/ruby.js","content":"Contains 2 structures: class, function"}},{"data":{"id":"file:dist-test/src/indexer/watcher.js","label":"watcher.js (2)","type":"file","file":"dist-test/src/indexer/watcher.js","content":"Contains 2 structures: function"}},{"data":{"id":"file:dist-test/src/mcp/server.js","label":"server.js (3)","type":"file","file":"dist-test/src/mcp/server.js","content":"Contains 3 structures: function, class"}},{"data":{"id":"file:dist-test/src/query/index.js","label":"index.js (3)","type":"file","file":"dist-test/src/query/index.js","content":"Contains 3 structures: function"}},{"data":{"id":"file:dist-test/test/db.test.js","label":"db.test.js (4)","type":"file","file":"dist-test/test/db.test.js","content":"Contains 4 structures: function"}},{"data":{"id":"file:dist-test/test/extractor.test.js","label":"extractor.test.js (3)","type":"file","file":"dist-test/test/extractor.test.js","content":"Contains 3 structures: function, class"}},{"data":{"id":"file:dist-test/test/helpers.js","label":"helpers.js (7)","type":"file","file":"dist-test/test/helpers.js","content":"Contains 7 structures: function"}},{"data":{"id":"file:dist-test/test/parsers.test.js","label":"parsers.test.js (32)","type":"file","file":"dist-test/test/parsers.test.js","content":"Contains 32 structures: function, class, interface, type"}},{"data":{"id":"file:dist-test/test/query.test.js","label":"query.test.js (7)","type":"file","file":"dist-test/test/query.test.js","content":"Contains 7 structures: function, class"}},{"data":{"id":"file:src/cli/commands/import.ts","label":"import.ts (20)","type":"file","file":"src/cli/commands/import.ts","content":"Contains 20 structures: type, interface, function"}},{"data":{"id":"file:src/cli/commands/init.ts","label":"init.ts (1)","type":"file","file":"src/cli/commands/init.ts","content":"Contains 1 structures: function"}},{"data":{"id":"file:src/cli/commands/mcp-serve.ts","label":"mcp-serve.ts (1)","type":"file","file":"src/cli/commands/mcp-serve.ts","content":"Contains 1 structures: function"}},{"data":{"id":"file:src/cli/commands/query.ts","label":"query.ts (4)","type":"file","file":"src/cli/commands/query.ts","content":"Contains 4 structures: interface, function"}},{"data":{"id":"file:src/cli/commands/setup.ts","label":"setup.ts (16)","type":"file","file":"src/cli/commands/setup.ts","content":"Contains 16 structures: interface, function"}},{"data":{"id":"file:src/cli/commands/start.ts","label":"start.ts (6)","type":"file","file":"src/cli/commands/start.ts","content":"Contains 6 structures: function, interface"}},{"data":{"id":"file:src/cli/commands/status.ts","label":"status.ts (4)","type":"file","file":"src/cli/commands/status.ts","content":"Contains 4 structures: function, interface"}},{"data":{"id":"file:src/cli/commands/stop.ts","label":"stop.ts (3)","type":"file","file":"src/cli/commands/stop.ts","content":"Contains 3 structures: function, interface"}},{"data":{"id":"file:src/cli/commands/visualize.ts","label":"visualize.ts (3)","type":"file","file":"src/cli/commands/visualize.ts","content":"Contains 3 structures: interface, function"}},{"data":{"id":"file:src/db/index.ts","label":"index.ts (38)","type":"file","file":"src/db/index.ts","content":"Contains 38 structures: function, interface"}},{"data":{"id":"file:src/extractor/index.ts","label":"index.ts (11)","type":"file","file":"src/extractor/index.ts","content":"Contains 11 structures: interface, function"}},{"data":{"id":"file:src/indexer/index.ts","label":"index.ts (7)","type":"file","file":"src/indexer/index.ts","content":"Contains 7 structures: interface, function"}},{"data":{"id":"file:src/indexer/parsers/base.ts","label":"base.ts (5)","type":"file","file":"src/indexer/parsers/base.ts","content":"Contains 5 structures: interface, function"}},{"data":{"id":"file:src/indexer/parsers/go.ts","label":"go.ts (3)","type":"file","file":"src/indexer/parsers/go.ts","content":"Contains 3 structures: interface, type, function"}},{"data":{"id":"file:src/indexer/parsers/javascript.ts","label":"javascript.ts (6)","type":"file","file":"src/indexer/parsers/javascript.ts","content":"Contains 6 structures: function, class, interface, type"}},{"data":{"id":"file:src/indexer/parsers/python.ts","label":"python.ts (3)","type":"file","file":"src/indexer/parsers/python.ts","content":"Contains 3 structures: class, function"}},{"data":{"id":"file:src/indexer/parsers/ruby.ts","label":"ruby.ts (2)","type":"file","file":"src/indexer/parsers/ruby.ts","content":"Contains 2 structures: class, function"}},{"data":{"id":"file:src/indexer/watcher.ts","label":"watcher.ts (3)","type":"file","file":"src/indexer/watcher.ts","content":"Contains 3 structures: interface, function"}},{"data":{"id":"file:src/mcp/server.ts","label":"server.ts (3)","type":"file","file":"src/mcp/server.ts","content":"Contains 3 structures: function, class"}},{"data":{"id":"file:src/proxy/interceptor.py","label":"interceptor.py (20)","type":"file","file":"src/proxy/interceptor.py","content":"Contains 20 structures: class, method"}},{"data":{"id":"file:src/query/index.ts","label":"index.ts (4)","type":"file","file":"src/query/index.ts","content":"Contains 4 structures: interface, function"}},{"data":{"id":"file:src/types/index.ts","label":"index.ts (12)","type":"file","file":"src/types/index.ts","content":"Contains 12 structures: interface, type"}},{"data":{"id":"file:src/visualize/index.ts","label":"index.ts (15)","type":"file","file":"src/visualize/index.ts","content":"Contains 15 structures: interface, function, class"}},{"data":{"id":"file:src/visualize/server.ts","label":"server.ts (2)","type":"file","file":"src/visualize/server.ts","content":"Contains 2 structures: interface, function"}},{"data":{"id":"file:src/visualize/template.ts","label":"template.ts (10)","type":"file","file":"src/visualize/template.ts","content":"Contains 10 structures: function"}},{"data":{"id":"file:test/db.test.ts","label":"db.test.ts (4)","type":"file","file":"test/db.test.ts","content":"Contains 4 structures: function"}},{"data":{"id":"file:test/extractor.test.ts","label":"extractor.test.ts (3)","type":"file","file":"test/extractor.test.ts","content":"Contains 3 structures: function, class"}},{"data":{"id":"file:test/helpers.ts","label":"helpers.ts (8)","type":"file","file":"test/helpers.ts","content":"Contains 8 structures: interface, function"}},{"data":{"id":"file:test/parsers.test.ts","label":"parsers.test.ts (32)","type":"file","file":"test/parsers.test.ts","content":"Contains 32 structures: function, class, interface, type"}},{"data":{"id":"file:test/query.test.ts","label":"query.test.ts (7)","type":"file","file":"test/query.test.ts","content":"Contains 7 structures: function, class"}}],"edges":[]},"callGraph":{"nodes":[{"data":{"id":"structure:5138","label":"greet","type":"function","file":"test/parsers.test.ts","line":66,"signature":"function greet(name)","content":"      assert.strictEqual(structures[0].signature, 'function greet(name)');\n      assert.strictEqual(structures[0].lineStart, 1);\n      assert.strictEqual(structures[0].lineEnd, 3);\n    });\n\n    it('should parse async function', () =\u003e {\n      const code = `async function fetchData(url) {\n  const response = await fetch(url);\n  return response.json();\n}`;\n      const structures = javascriptParser.parse(code, 'test.js');\n\n      assert.strictEqual(structures.length, 1);\n      assert.strictEqual(structures[0].name, 'fetchData');\n      assert.ok(structures[0].signature?.includes('fetchData'));\n    });","weight":1}},{"data":{"id":"structure:5139","label":"fetchData","type":"function","file":"test/parsers.test.ts","line":72,"signature":"function fetchData(url)","content":"      const code = `async function fetchData(url) {\n  const response = await fetch(url);\n  return response.json();\n}`;","weight":2}},{"data":{"id":"structure:5182","label":"calculateTotal","type":"function","file":"test/db.test.ts","line":115,"signature":"function calculateTotal(items)","content":"      createTestStructure(testDb.db, file.id, 'function', 'calculateTotal', 1, 10, 'calculateTotal(items)', 'function calculateTotal(items) {}');","weight":1}},{"data":{"id":"structure:5172","label":"createTestStructure","type":"function","file":"test/helpers.ts","line":63,"signature":"function createTestStructure(\n  db: Database.Database,\n  fileId: number,\n  type: string,\n  name: string,\n  lineStart: number,\n  lineEnd: number,\n  signature: string | null,\n  rawContent: string\n)","content":"export function createTestStructure(\n  db: Database.Database,\n  fileId: number,\n  type: string,\n  name: string,\n  lineStart: number,\n  lineEnd: number,\n  signature: string | null,\n  rawContent: string\n) {\n  const stmt = db.prepare(`\n    INSERT INTO structures (file_id, type, name, line_start, line_end, signature, raw_content, metadata)\n    VALUES (?, ?, ?, ?, ?, ?, ?, '{}')\n    RETURNING *\n  `);\n  return stmt.get(fileId, type, name, lineStart, lineEnd, signature, rawContent);\n}","weight":10}},{"data":{"id":"structure:5183","label":"validateInput","type":"function","file":"test/db.test.ts","line":116,"signature":"function validateInput(data)","content":"      createTestStructure(testDb.db, file.id, 'function', 'validateInput', 11, 20, 'validateInput(data)', 'function validateInput(data) {}');","weight":1}},{"data":{"id":"structure:5184","label":"processPayment","type":"function","file":"dist-test/test/query.test.js","line":18,"signature":"function processPayment(amount: number)","content":"            createTestStructure(testDb.db, file.id, 'function', 'processPayment', 1, 20, 'processPayment(amount: number)', 'function processPayment(amount: number) { /* ... */ }');","weight":1}},{"data":{"id":"structure:5185","label":"validateCard","type":"function","file":"dist-test/test/query.test.js","line":19,"signature":"function validateCard(cardNumber: string)","content":"            createTestStructure(testDb.db, file.id, 'function', 'validateCard', 21, 40, 'validateCard(cardNumber: string)', 'function validateCard(cardNumber: string) { /* ... */ }');","weight":1}},{"data":{"id":"structure:5186","label":"formatDate","type":"function","file":"dist-test/test/query.test.js","line":34,"signature":"function formatDate(date: Date)","content":"            createTestStructure(testDb.db, file.id, 'function', 'formatDate', 1, 10, 'formatDate(date: Date)', 'function formatDate(date: Date) { return date.toISOString(); }');","weight":1}},{"data":{"id":"structure:5187","label":"handleRequest","type":"function","file":"dist-test/test/query.test.js","line":73,"signature":"function handleRequest(req)","content":"            const structure = createTestStructure(testDb.db, file.id, 'function', 'handleRequest', 1, 30, 'handleRequest(req)', 'function handleRequest(req) {}');","weight":1}},{"data":{"id":"structure:5192","label":"greet","type":"function","file":"dist-test/test/parsers.test.js","line":53,"signature":"function greet(name)","content":"            assert.strictEqual(structures[0].signature, 'function greet(name)');\n            assert.strictEqual(structures[0].lineStart, 1);\n            assert.strictEqual(structures[0].lineEnd, 3);\n        });\n        it('should parse async function', () =\u003e {\n            const code = `async function fetchData(url) {\n  const response = await fetch(url);\n  return response.json();\n}`;\n            const structures = javascriptParser.parse(code, 'test.js');\n            assert.strictEqual(structures.length, 1);\n            assert.strictEqual(structures[0].name, 'fetchData');\n            assert.ok(structures[0].signature?.includes('fetchData'));\n        });","weight":1}},{"data":{"id":"structure:5233","label":"processData","type":"function","file":"dist-test/test/db.test.js","line":55,"signature":"function processData(input: string)","content":"            const structure = createTestStructure(testDb.db, file.id, 'function', 'processData', 10, 25, 'function processData(input: string)', 'function processData(input: string) { return input; }');","weight":1}},{"data":{"id":"structure:5234","label":"processData","type":"function","file":"dist-test/test/db.test.js","line":55,"signature":"function processData(input: string)","content":"            const structure = createTestStructure(testDb.db, file.id, 'function', 'processData', 10, 25, 'function processData(input: string)', 'function processData(input: string) { return input; }');","weight":1}},{"data":{"id":"structure:5235","label":"calculateTotal","type":"function","file":"dist-test/test/db.test.js","line":75,"signature":"function calculateTotal(items)","content":"            createTestStructure(testDb.db, file.id, 'function', 'calculateTotal', 1, 10, 'calculateTotal(items)', 'function calculateTotal(items) {}');","weight":1}},{"data":{"id":"structure:5236","label":"validateInput","type":"function","file":"dist-test/test/db.test.js","line":76,"signature":"function validateInput(data)","content":"            createTestStructure(testDb.db, file.id, 'function', 'validateInput', 11, 20, 'validateInput(data)', 'function validateInput(data) {}');","weight":1}},{"data":{"id":"structure:5249","label":"generateDashboardHTML","type":"function","file":"src/visualize/template.ts","line":4,"signature":"function generateDashboardHTML(data: VisualizationData)","content":"export function generateDashboardHTML(data: VisualizationData): string {\n  // Escape JSON for safe embedding in HTML script tag\n  // We use a script tag with type=\"application/json\" to avoid parsing issues\n  const jsonData = JSON.stringify(data)\n    .replace(/\u003c/g, '\\\\u003c')         // Escape \u003c to prevent \u003c/script\u003e issues\n    .replace(/\u003e/g, '\\\\u003e')         // Escape \u003e for safety\n    .replace(/\u0026/g, '\\\\u0026');        // Escape \u0026 for safety\n\n  return `\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003eaimem Dashboard - ${escapeHtml(data.project.name)}\u003c/title\u003e\n  \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js\"\u003e\u003c/script\u003e\n  \u003cstyle\u003e\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n    }\n\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n      background: #1a1a2e;\n      color: #eee;\n      height: 100vh;\n      overflow: hidden;\n    }\n\n    /* Header */\n    .header {\n      background: #16213e;\n      padding: 12px 20px;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      border-bottom: 1px solid #0f3460;\n    }\n\n    .header h1 {\n      font-size: 18px;\n      font-weight: 500;\n      color: #e94560;\n    }\n\n    .header h1 span {\n      color: #eee;\n      font-weight: 400;\n    }\n\n    .search-box {\n      display: flex;\n      gap: 8px;\n    }\n\n    .search-box input {\n      background: #0f3460;\n      border: 1px solid #1a1a2e;\n      color: #eee;\n      padding: 6px 12px;\n      border-radius: 4px;\n      width: 200px;\n    }\n\n    .search-box input::placeholder {\n      color: #666;\n    }\n\n    /* Tabs */\n    .tabs {\n      background: #16213e;\n      display: flex;\n      gap: 0;\n      border-bottom: 1px solid #0f3460;\n    }\n\n    .tab {\n      padding: 10px 20px;\n      cursor: pointer;\n      color: #888;\n      border-bottom: 2px solid transparent;\n      transition: all 0.2s;\n    }\n\n    .tab:hover {\n      color: #ccc;\n      background: rgba(233, 69, 96, 0.1);\n    }\n\n    .tab.active {\n      color: #e94560;\n      border-bottom-color: #e94560;\n    }\n\n    /* Main layout */\n    .main {\n      display: flex;\n      height: calc(100vh - 90px);\n    }\n\n    /* Sidebar */\n    .sidebar {\n      width: 220px;\n      background: #16213e;\n      padding: 16px;\n      border-right: 1px solid #0f3460;\n      overflow-y: auto;\n    }\n\n    .sidebar h3 {\n      font-size: 12px;\n      text-transform: uppercase;\n      color: #666;\n      margin-bottom: 12px;\n    }\n\n    .filter-group {\n      margin-bottom: 20px;\n    }\n\n    .filter-item {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 6px 0;\n      cursor: pointer;\n    }\n\n    .filter-item input {\n      accent-color: #e94560;\n    }\n\n    .filter-item label {\n      font-size: 13px;\n      cursor: pointer;\n    }\n\n    .filter-item .count {\n      margin-left: auto;\n      font-size: 11px;\n      color: #666;\n      background: #0f3460;\n      padding: 2px 6px;\n      border-radius: 10px;\n    }\n\n    .layout-select {\n      width: 100%;\n      background: #0f3460;\n      border: 1px solid #1a1a2e;\n      color: #eee;\n      padding: 8px;\n      border-radius: 4px;\n      margin-top: 8px;\n    }\n\n    /* Graph container */\n    .graph-container {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n    }\n\n    #cy {\n      flex: 1;\n      background: #1a1a2e;\n    }\n\n    /* Details panel */\n    .details-panel {\n      width: 350px;\n      background: #16213e;\n      border-left: 1px solid #0f3460;\n      display: flex;\n      flex-direction: column;\n      overflow: hidden;\n    }\n\n    .details-header {\n      padding: 12px 16px;\n      border-bottom: 1px solid #0f3460;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n\n    .details-header h3 {\n      font-size: 14px;\n      font-weight: 500;\n    }\n\n    .details-content {\n      flex: 1;\n      overflow-y: auto;\n      padding: 16px;\n    }\n\n    .detail-row {\n      margin-bottom: 12px;\n    }\n\n    .detail-label {\n      font-size: 11px;\n      text-transform: uppercase;\n      color: #666;\n      margin-bottom: 4px;\n    }\n\n    .detail-value {\n      font-size: 13px;\n      color: #eee;\n    }\n\n    .detail-value a {\n      color: #e94560;\n      text-decoration: none;\n    }\n\n    .detail-value a:hover {\n      text-decoration: underline;\n    }\n\n    /* Code block */\n    .code-block {\n      background: #0f3460;\n      border-radius: 4px;\n      padding: 12px;\n      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;\n      font-size: 12px;\n      line-height: 1.5;\n      overflow-x: auto;\n      white-space: pre;\n      max-height: 300px;\n      overflow-y: auto;\n    }\n\n    /* Tags */\n    .tag {\n      display: inline-block;\n      padding: 2px 8px;\n      border-radius: 3px;\n      font-size: 11px;\n      font-weight: 500;\n    }\n\n    .tag.function { background: #2563eb; color: white; }\n    .tag.class { background: #7c3aed; color: white; }\n    .tag.method { background: #0891b2; color: white; }\n    .tag.interface { background: #059669; color: white; }\n    .tag.type { background: #d97706; color: white; }\n    .tag.variable { background: #dc2626; color: white; }\n    .tag.module { background: #4f46e5; color: white; }\n    .tag.file { background: #475569; color: white; }\n    .tag.decision { background: #16a34a; color: white; }\n    .tag.pattern { background: #0d9488; color: white; }\n    .tag.rejection { background: #dc2626; color: white; }\n\n    /* Stats bar */\n    .stats-bar {\n      padding: 8px 16px;\n      background: #0f3460;\n      display: flex;\n      gap: 20px;\n      font-size: 12px;\n      color: #888;\n    }\n\n    .stat {\n      display: flex;\n      gap: 4px;\n    }\n\n    .stat-value {\n      color: #e94560;\n      font-weight: 500;\n    }\n\n    /* View description */\n    .view-description {\n      padding: 10px 16px;\n      background: #0f3460;\n      border-bottom: 1px solid #1a1a2e;\n      font-size: 13px;\n      color: #aaa;\n      line-height: 1.4;\n    }\n\n    .view-description strong {\n      color: #e94560;\n    }\n\n    /* Empty state */\n    .empty-state {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      height: 100%;\n      color: #666;\n    }\n\n    .empty-state h3 {\n      margin-bottom: 8px;\n    }\n\n    /* Tooltip */\n    .cy-tooltip {\n      position: absolute;\n      background: #16213e;\n      border: 1px solid #0f3460;\n      padding: 8px 12px;\n      border-radius: 4px;\n      font-size: 12px;\n      pointer-events: none;\n      z-index: 1000;\n      max-width: 300px;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n    }\n  \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv class=\"header\"\u003e\n    \u003ch1\u003eaimem \u003cspan\u003eDashboard: ${escapeHtml(data.project.name)}\u003c/span\u003e\u003c/h1\u003e\n    \u003cdiv class=\"search-box\"\u003e\n      \u003cinput type=\"text\" id=\"search\" placeholder=\"Search nodes...\"\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cdiv class=\"tabs\"\u003e\n    \u003cdiv class=\"tab active\" data-view=\"overview\"\u003eOverview\u003c/div\u003e\n    \u003cdiv class=\"tab\" data-view=\"callGraph\"\u003eCall Graph\u003c/div\u003e\n    \u003cdiv class=\"tab\" data-view=\"dependencies\"\u003eDependencies\u003c/div\u003e\n    \u003cdiv class=\"tab\" data-view=\"classes\"\u003eClasses\u003c/div\u003e\n    \u003cdiv class=\"tab\" data-view=\"decisions\"\u003eDecisions\u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cdiv class=\"main\"\u003e\n    \u003cdiv class=\"sidebar\"\u003e\n      \u003cdiv class=\"filter-group\"\u003e\n        \u003ch3\u003eFilter by Type\u003c/h3\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-function\" checked\u003e\n          \u003clabel for=\"filter-function\"\u003eFunctions\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.byType['function'] || 0}\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-class\" checked\u003e\n          \u003clabel for=\"filter-class\"\u003eClasses\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.byType['class'] || 0}\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-method\" checked\u003e\n          \u003clabel for=\"filter-method\"\u003eMethods\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.byType['method'] || 0}\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-interface\" checked\u003e\n          \u003clabel for=\"filter-interface\"\u003eInterfaces\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.byType['interface'] || 0}\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-type\" checked\u003e\n          \u003clabel for=\"filter-type\"\u003eTypes\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.byType['type'] || 0}\u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"filter-item\"\u003e\n          \u003cinput type=\"checkbox\" id=\"filter-file\" checked\u003e\n          \u003clabel for=\"filter-file\"\u003eFiles\u003c/label\u003e\n          \u003cspan class=\"count\"\u003e${data.stats.totalFiles}\u003c/span\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n\n      \u003cdiv class=\"filter-group\"\u003e\n        \u003ch3\u003eLayout\u003c/h3\u003e\n        \u003cselect class=\"layout-select\" id=\"layout-select\"\u003e\n          \u003coption value=\"grid\"\u003eGrid\u003c/option\u003e\n          \u003coption value=\"cose\"\u003eForce Directed\u003c/option\u003e\n          \u003coption value=\"breadthfirst\"\u003eHierarchical\u003c/option\u003e\n          \u003coption value=\"circle\"\u003eCircular\u003c/option\u003e\n          \u003coption value=\"concentric\"\u003eConcentric\u003c/option\u003e\n        \u003c/select\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cdiv class=\"graph-container\"\u003e\n      \u003cdiv class=\"view-description\" id=\"view-description\"\u003e\n        \u003cstrong\u003eOverview\u003c/strong\u003e - All files in your codebase. Each node shows the file name and number of structures (functions, classes, etc.) it contains. Click a file to see details.\n      \u003c/div\u003e\n      \u003cdiv id=\"cy\"\u003e\u003c/div\u003e\n      \u003cdiv class=\"stats-bar\"\u003e\n        \u003cdiv class=\"stat\"\u003e\u003cspan class=\"stat-value\"\u003e${data.stats.totalStructures}\u003c/span\u003e structures\u003c/div\u003e\n        \u003cdiv class=\"stat\"\u003e\u003cspan class=\"stat-value\"\u003e${data.stats.totalFiles}\u003c/span\u003e files\u003c/div\u003e\n        \u003cdiv class=\"stat\"\u003e\u003cspan class=\"stat-value\"\u003e${data.stats.totalLinks}\u003c/span\u003e links\u003c/div\u003e\n        \u003cdiv class=\"stat\"\u003e\u003cspan class=\"stat-value\"\u003e${data.stats.totalDecisions}\u003c/span\u003e decisions\u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n\n    \u003cdiv class=\"details-panel\"\u003e\n      \u003cdiv class=\"details-header\"\u003e\n        \u003ch3\u003eDetails\u003c/h3\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"details-content\" id=\"details-content\"\u003e\n        \u003cdiv class=\"empty-state\"\u003e\n          \u003ch3\u003eNo selection\u003c/h3\u003e\n          \u003cp\u003eClick a node to view details\u003c/p\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cscript id=\"viz-data\" type=\"application/json\"\u003e${jsonData}\u003c/script\u003e\n  \u003cscript\u003e\n    // Visualization data - parse from JSON script tag to avoid escaping issues\n    const vizData = JSON.parse(document.getElementById('viz-data').textContent);\n\n    // Initialize Cytoscape\n    let cy = null;\n    let currentView = 'overview';\n\n    // View descriptions\n    const viewDescriptions = {\n      overview: '\u003cstrong\u003eOverview\u003c/strong\u003e - All files in your codebase. Each node shows the file name and number of structures it contains. Click a file to see details.',\n      callGraph: '\u003cstrong\u003eCall Graph\u003c/strong\u003e - Function and method relationships. Arrows show which functions call other functions. Useful for understanding code flow.',\n      dependencies: '\u003cstrong\u003eDependencies\u003c/strong\u003e - File-level view showing how your codebase is organized. Each node represents a source file.',\n      classes: '\u003cstrong\u003eClasses\u003c/strong\u003e - Object-oriented structures. Shows classes, interfaces, and their methods. Useful for understanding your type hierarchy.',\n      decisions: '\u003cstrong\u003eDecisions\u003c/strong\u003e - Architectural decisions extracted from AI conversations. Shows what was decided and which code it affects.',\n    };\n\n    // Node colors\n    const nodeColors = {\n      function: '#2563eb',\n      class: '#7c3aed',\n      method: '#0891b2',\n      interface: '#059669',\n      type: '#d97706',\n      variable: '#dc2626',\n      module: '#4f46e5',\n      file: '#475569',\n      decision: '#16a34a',\n      pattern: '#0d9488',\n      rejection: '#dc2626',\n    };\n\n    // Cytoscape styles\n    const cyStyle = [\n      {\n        selector: 'node',\n        style: {\n          'label': 'data(label)',\n          'text-valign': 'bottom',\n          'text-halign': 'center',\n          'font-size': '10px',\n          'color': '#ccc',\n          'text-margin-y': 4,\n          'background-color': '#475569',\n          'width': 30,\n          'height': 30,\n        }\n      },\n      {\n        selector: 'node[type=\"function\"]',\n        style: { 'background-color': nodeColors.function }\n      },\n      {\n        selector: 'node[type=\"class\"]',\n        style: { 'background-color': nodeColors.class, 'width': 40, 'height': 40 }\n      },\n      {\n        selector: 'node[type=\"method\"]',\n        style: { 'background-color': nodeColors.method }\n      },\n      {\n        selector: 'node[type=\"interface\"]',\n        style: { 'background-color': nodeColors.interface }\n      },\n      {\n        selector: 'node[type=\"type\"]',\n        style: { 'background-color': nodeColors.type }\n      },\n      {\n        selector: 'node[type=\"file\"]',\n        style: {\n          'background-color': nodeColors.file,\n          'width': 50,\n          'height': 30,\n          'shape': 'round-rectangle',\n          'font-size': '11px',\n          'text-wrap': 'ellipsis',\n          'text-max-width': '80px',\n        }\n      },\n      {\n        selector: 'node[type=\"decision\"]',\n        style: { 'background-color': nodeColors.decision, 'shape': 'diamond' }\n      },\n      {\n        selector: 'node[type=\"pattern\"]',\n        style: { 'background-color': nodeColors.pattern, 'shape': 'diamond' }\n      },\n      {\n        selector: 'node[type=\"rejection\"]',\n        style: { 'background-color': nodeColors.rejection, 'shape': 'diamond' }\n      },\n      {\n        selector: 'edge',\n        style: {\n          'width': 1.5,\n          'line-color': '#334155',\n          'target-arrow-color': '#334155',\n          'target-arrow-shape': 'triangle',\n          'curve-style': 'bezier',\n          'arrow-scale': 0.8,\n        }\n      },\n      {\n        selector: 'edge[type=\"calls\"]',\n        style: { 'line-color': '#2563eb', 'target-arrow-color': '#2563eb' }\n      },\n      {\n        selector: 'edge[type=\"contains\"]',\n        style: { 'line-style': 'dashed', 'line-color': '#475569', 'target-arrow-shape': 'none' }\n      },\n      {\n        selector: 'edge[type=\"decision\"]',\n        style: { 'line-color': '#16a34a', 'target-arrow-color': '#16a34a' }\n      },\n      {\n        selector: ':selected',\n        style: {\n          'border-width': 3,\n          'border-color': '#e94560',\n        }\n      }\n    ];\n\n    function initCytoscape(graphData) {\n      if (cy) {\n        cy.destroy();\n      }\n\n      cy = cytoscape({\n        container: document.getElementById('cy'),\n        elements: [...graphData.nodes, ...graphData.edges],\n        style: cyStyle,\n        layout: { name: 'cose', animate: false, randomize: true },\n        minZoom: 0.1,\n        maxZoom: 3,\n      });\n\n      // Click handler\n      cy.on('tap', 'node', function(evt) {\n        const node = evt.target;\n        showDetails(node.data());\n      });\n\n      // Clear selection on background click\n      cy.on('tap', function(evt) {\n        if (evt.target === cy) {\n          clearDetails();\n        }\n      });\n\n      runLayout();\n    }\n\n    function runLayout() {\n      const layoutName = document.getElementById('layout-select').value;\n      const nodeCount = cy.nodes(':visible').length;\n\n      const layoutOptions = {\n        name: layoutName,\n        animate: nodeCount \u003c 100,\n        animationDuration: 300,\n        nodeDimensionsIncludeLabels: true,\n        fit: true,\n        padding: 50,\n      };\n\n      // Layout-specific options for better spacing\n      if (layoutName === 'cose') {\n        Object.assign(layoutOptions, {\n          nodeRepulsion: 8000,\n          idealEdgeLength: 100,\n          edgeElasticity: 100,\n          nestingFactor: 1.2,\n          gravity: 0.25,\n          numIter: 1000,\n          randomize: true,\n        });\n      } else if (layoutName === 'breadthfirst') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.5,\n          directed: true,\n        });\n      } else if (layoutName === 'circle') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.2,\n        });\n      } else if (layoutName === 'grid') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.5,\n          condense: false,\n        });\n      } else if (layoutName === 'concentric') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 2,\n          minNodeSpacing: 50,\n        });\n      }\n\n      cy.layout(layoutOptions).run();\n    }\n\n    function showDetails(data) {\n      const content = document.getElementById('details-content');\n      let html = '';\n\n      // Type tag\n      html += '\u003cdiv class=\"detail-row\"\u003e';\n      html += '\u003cspan class=\"tag ' + data.type + '\"\u003e' + data.type + '\u003c/span\u003e';\n      html += '\u003c/div\u003e';\n\n      // Name\n      html += '\u003cdiv class=\"detail-row\"\u003e';\n      html += '\u003cdiv class=\"detail-label\"\u003eName\u003c/div\u003e';\n      html += '\u003cdiv class=\"detail-value\"\u003e' + escapeHtml(data.label) + '\u003c/div\u003e';\n      html += '\u003c/div\u003e';\n\n      // File location\n      if (data.file) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eLocation\u003c/div\u003e';\n        html += '\u003cdiv class=\"detail-value\"\u003e' + escapeHtml(data.file);\n        if (data.line) {\n          html += ':' + data.line;\n        }\n        html += '\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      // Signature\n      if (data.signature) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eSignature\u003c/div\u003e';\n        html += '\u003cdiv class=\"detail-value\"\u003e\u003ccode\u003e' + escapeHtml(data.signature) + '\u003c/code\u003e\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      // Source code\n      if (data.content) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eSource Code\u003c/div\u003e';\n        html += '\u003cdiv class=\"code-block\"\u003e' + escapeHtml(data.content) + '\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      content.innerHTML = html;\n    }\n\n    function clearDetails() {\n      document.getElementById('details-content').innerHTML = \\`\n        \u003cdiv class=\"empty-state\"\u003e\n          \u003ch3\u003eNo selection\u003c/h3\u003e\n          \u003cp\u003eClick a node to view details\u003c/p\u003e\n        \u003c/div\u003e\n      \\`;\n    }\n\n    function escapeHtml(text) {\n      if (!text) return '';\n      const div = document.createElement('div');\n      div.textContent = text;\n      return div.innerHTML;\n    }\n\n    function switchView(view) {\n      currentView = view;\n\n      // Update tabs\n      document.querySelectorAll('.tab').forEach(tab =\u003e {\n        tab.classList.toggle('active', tab.dataset.view === view);\n      });\n\n      // Update description\n      document.getElementById('view-description').innerHTML = viewDescriptions[view] || '';\n\n      // Load graph data\n      const graphData = vizData.graphs[view];\n      if (graphData \u0026\u0026 (graphData.nodes.length \u003e 0 || graphData.edges.length \u003e 0)) {\n        initCytoscape(graphData);\n      } else {\n        if (cy) cy.destroy();\n        document.getElementById('cy').innerHTML = \\`\n          \u003cdiv class=\"empty-state\"\u003e\n            \u003ch3\u003eNo data\u003c/h3\u003e\n            \u003cp\u003eNo nodes to display for this view\u003c/p\u003e\n          \u003c/div\u003e\n        \\`;\n      }\n\n      clearDetails();\n    }\n\n    function applyFilters() {\n      if (!cy) return;\n\n      const filters = {\n        function: document.getElementById('filter-function').checked,\n        class: document.getElementById('filter-class').checked,\n        method: document.getElementById('filter-method').checked,\n        interface: document.getElementById('filter-interface').checked,\n        type: document.getElementById('filter-type').checked,\n        file: document.getElementById('filter-file').checked,\n      };\n\n      cy.nodes().forEach(node =\u003e {\n        const type = node.data('type');\n        const visible = filters[type] !== false;\n        node.style('display', visible ? 'element' : 'none');\n      });\n    }\n\n    function searchNodes(query) {\n      if (!cy || !query) {\n        cy \u0026\u0026 cy.nodes().style('opacity', 1);\n        return;\n      }\n\n      query = query.toLowerCase();\n      cy.nodes().forEach(node =\u003e {\n        const label = (node.data('label') || '').toLowerCase();\n        const matches = label.includes(query);\n        node.style('opacity', matches ? 1 : 0.2);\n      });\n    }\n\n    // Event listeners\n    document.querySelectorAll('.tab').forEach(tab =\u003e {\n      tab.addEventListener('click', () =\u003e switchView(tab.dataset.view));\n    });\n\n    document.getElementById('layout-select').addEventListener('change', runLayout);\n\n    document.querySelectorAll('[id^=\"filter-\"]').forEach(checkbox =\u003e {\n      checkbox.addEventListener('change', applyFilters);\n    });\n\n    document.getElementById('search').addEventListener('input', (e) =\u003e {\n      searchNodes(e.target.value);\n    });\n\n    // Initialize\n    switchView('overview');\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e`;\n}","weight":10}},{"data":{"id":"structure:5254","label":"escapeHtml","type":"function","file":"src/visualize/template.ts","line":673,"signature":"function escapeHtml(text)","content":"    function escapeHtml(text) {\n      if (!text) return '';\n      const div = document.createElement('div');\n      div.textContent = text;\n      return div.innerHTML;\n    }","weight":4}},{"data":{"id":"structure:5250","label":"initCytoscape","type":"function","file":"src/visualize/template.ts","line":540,"signature":"function initCytoscape(graphData)","content":"    function initCytoscape(graphData) {\n      if (cy) {\n        cy.destroy();\n      }\n\n      cy = cytoscape({\n        container: document.getElementById('cy'),\n        elements: [...graphData.nodes, ...graphData.edges],\n        style: cyStyle,\n        layout: { name: 'cose', animate: false, randomize: true },\n        minZoom: 0.1,\n        maxZoom: 3,\n      });\n\n      // Click handler\n      cy.on('tap', 'node', function(evt) {\n        const node = evt.target;\n        showDetails(node.data());\n      });\n\n      // Clear selection on background click\n      cy.on('tap', function(evt) {\n        if (evt.target === cy) {\n          clearDetails();\n        }\n      });\n\n      runLayout();\n    }","weight":6}},{"data":{"id":"structure:5252","label":"showDetails","type":"function","file":"src/visualize/template.ts","line":618,"signature":"function showDetails(data)","content":"    function showDetails(data) {\n      const content = document.getElementById('details-content');\n      let html = '';\n\n      // Type tag\n      html += '\u003cdiv class=\"detail-row\"\u003e';\n      html += '\u003cspan class=\"tag ' + data.type + '\"\u003e' + data.type + '\u003c/span\u003e';\n      html += '\u003c/div\u003e';\n\n      // Name\n      html += '\u003cdiv class=\"detail-row\"\u003e';\n      html += '\u003cdiv class=\"detail-label\"\u003eName\u003c/div\u003e';\n      html += '\u003cdiv class=\"detail-value\"\u003e' + escapeHtml(data.label) + '\u003c/div\u003e';\n      html += '\u003c/div\u003e';\n\n      // File location\n      if (data.file) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eLocation\u003c/div\u003e';\n        html += '\u003cdiv class=\"detail-value\"\u003e' + escapeHtml(data.file);\n        if (data.line) {\n          html += ':' + data.line;\n        }\n        html += '\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      // Signature\n      if (data.signature) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eSignature\u003c/div\u003e';\n        html += '\u003cdiv class=\"detail-value\"\u003e\u003ccode\u003e' + escapeHtml(data.signature) + '\u003c/code\u003e\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      // Source code\n      if (data.content) {\n        html += '\u003cdiv class=\"detail-row\"\u003e';\n        html += '\u003cdiv class=\"detail-label\"\u003eSource Code\u003c/div\u003e';\n        html += '\u003cdiv class=\"code-block\"\u003e' + escapeHtml(data.content) + '\u003c/div\u003e';\n        html += '\u003c/div\u003e';\n      }\n\n      content.innerHTML = html;\n    }","weight":3}},{"data":{"id":"structure:5253","label":"clearDetails","type":"function","file":"src/visualize/template.ts","line":664,"signature":"function clearDetails()","content":"    function clearDetails() {\n      document.getElementById('details-content').innerHTML = \\`\n        \u003cdiv class=\"empty-state\"\u003e\n          \u003ch3\u003eNo selection\u003c/h3\u003e\n          \u003cp\u003eClick a node to view details\u003c/p\u003e\n        \u003c/div\u003e\n      \\`;\n    }\n\n    function escapeHtml(text) {\n      if (!text) return '';\n      const div = document.createElement('div');\n      div.textContent = text;\n      return div.innerHTML;\n    }\n\n    function switchView(view) {\n      currentView = view;\n\n      // Update tabs\n      document.querySelectorAll('.tab').forEach(tab =\u003e {\n        tab.classList.toggle('active', tab.dataset.view === view);\n      });\n\n      // Update description\n      document.getElementById('view-description').innerHTML = viewDescriptions[view] || '';\n\n      // Load graph data\n      const graphData = vizData.graphs[view];\n      if (graphData \u0026\u0026 (graphData.nodes.length \u003e 0 || graphData.edges.length \u003e 0)) {\n        initCytoscape(graphData);\n      } else {\n        if (cy) cy.destroy();\n        document.getElementById('cy').innerHTML = \\`\n          \u003cdiv class=\"empty-state\"\u003e\n            \u003ch3\u003eNo data\u003c/h3\u003e\n            \u003cp\u003eNo nodes to display for this view\u003c/p\u003e\n          \u003c/div\u003e\n        \\`;\n      }\n\n      clearDetails();\n    }\n\n    function applyFilters() {\n      if (!cy) return;\n\n      const filters = {\n        function: document.getElementById('filter-function').checked,\n        class: document.getElementById('filter-class').checked,\n        method: document.getElementById('filter-method').checked,\n        interface: document.getElementById('filter-interface').checked,\n        type: document.getElementById('filter-type').checked,\n        file: document.getElementById('filter-file').checked,\n      };\n\n      cy.nodes().forEach(node =\u003e {\n        const type = node.data('type');\n        const visible = filters[type] !== false;\n        node.style('display', visible ? 'element' : 'none');\n      });\n    }\n\n    function searchNodes(query) {\n      if (!cy || !query) {\n        cy \u0026\u0026 cy.nodes().style('opacity', 1);\n        return;\n      }\n\n      query = query.toLowerCase();\n      cy.nodes().forEach(node =\u003e {\n        const label = (node.data('label') || '').toLowerCase();\n        const matches = label.includes(query);\n        node.style('opacity', matches ? 1 : 0.2);\n      });\n    }\n\n    // Event listeners\n    document.querySelectorAll('.tab').forEach(tab =\u003e {\n      tab.addEventListener('click', () =\u003e switchView(tab.dataset.view));\n    });\n\n    document.getElementById('layout-select').addEventListener('change', runLayout);\n\n    document.querySelectorAll('[id^=\"filter-\"]').forEach(checkbox =\u003e {\n      checkbox.addEventListener('change', applyFilters);\n    });\n\n    document.getElementById('search').addEventListener('input', (e) =\u003e {\n      searchNodes(e.target.value);\n    });\n\n    // Initialize\n    switchView('overview');\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e`;\n}","weight":8}},{"data":{"id":"structure:5251","label":"runLayout","type":"function","file":"src/visualize/template.ts","line":570,"signature":"function runLayout()","content":"    function runLayout() {\n      const layoutName = document.getElementById('layout-select').value;\n      const nodeCount = cy.nodes(':visible').length;\n\n      const layoutOptions = {\n        name: layoutName,\n        animate: nodeCount \u003c 100,\n        animationDuration: 300,\n        nodeDimensionsIncludeLabels: true,\n        fit: true,\n        padding: 50,\n      };\n\n      // Layout-specific options for better spacing\n      if (layoutName === 'cose') {\n        Object.assign(layoutOptions, {\n          nodeRepulsion: 8000,\n          idealEdgeLength: 100,\n          edgeElasticity: 100,\n          nestingFactor: 1.2,\n          gravity: 0.25,\n          numIter: 1000,\n          randomize: true,\n        });\n      } else if (layoutName === 'breadthfirst') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.5,\n          directed: true,\n        });\n      } else if (layoutName === 'circle') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.2,\n        });\n      } else if (layoutName === 'grid') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 1.5,\n          condense: false,\n        });\n      } else if (layoutName === 'concentric') {\n        Object.assign(layoutOptions, {\n          spacingFactor: 2,\n          minNodeSpacing: 50,\n        });\n      }\n\n      cy.layout(layoutOptions).run();\n    }","weight":2}},{"data":{"id":"structure:5255","label":"switchView","type":"function","file":"src/visualize/template.ts","line":680,"signature":"function switchView(view)","content":"    function switchView(view) {\n      currentView = view;\n\n      // Update tabs\n      document.querySelectorAll('.tab').forEach(tab =\u003e {\n        tab.classList.toggle('active', tab.dataset.view === view);\n      });\n\n      // Update description\n      document.getElementById('view-description').innerHTML = viewDescriptions[view] || '';\n\n      // Load graph data\n      const graphData = vizData.graphs[view];\n      if (graphData \u0026\u0026 (graphData.nodes.length \u003e 0 || graphData.edges.length \u003e 0)) {\n        initCytoscape(graphData);\n      } else {\n        if (cy) cy.destroy();\n        document.getElementById('cy').innerHTML = \\`\n          \u003cdiv class=\"empty-state\"\u003e\n            \u003ch3\u003eNo data\u003c/h3\u003e\n            \u003cp\u003eNo nodes to display for this view\u003c/p\u003e\n          \u003c/div\u003e\n        \\`;\n      }\n\n      clearDetails();\n    }\n\n    function applyFilters() {\n      if (!cy) return;\n\n      const filters = {\n        function: document.getElementById('filter-function').checked,\n        class: document.getElementById('filter-class').checked,\n        method: document.getElementById('filter-method').checked,\n        interface: document.getElementById('filter-interface').checked,\n        type: document.getElementById('filter-type').checked,\n        file: document.getElementById('filter-file').checked,\n      };\n\n      cy.nodes().forEach(node =\u003e {\n        const type = node.data('type');\n        const visible = filters[type] !== false;\n        node.style('display', visible ? 'element' : 'none');\n      });\n    }\n\n    function searchNodes(query) {\n      if (!cy || !query) {\n        cy \u0026\u0026 cy.nodes().style('opacity', 1);\n        return;\n      }\n\n      query = query.toLowerCase();\n      cy.nodes().forEach(node =\u003e {\n        const label = (node.data('label') || '').toLowerCase();\n        const matches = label.includes(query);\n        node.style('opacity', matches ? 1 : 0.2);\n      });\n    }\n\n    // Event listeners\n    document.querySelectorAll('.tab').forEach(tab =\u003e {\n      tab.addEventListener('click', () =\u003e switchView(tab.dataset.view));\n    });\n\n    document.getElementById('layout-select').addEventListener('change', runLayout);\n\n    document.querySelectorAll('[id^=\"filter-\"]').forEach(checkbox =\u003e {\n      checkbox.addEventListener('change', applyFilters);\n    });\n\n    document.getElementById('search').addEventListener('input', (e) =\u003e {\n      searchNodes(e.target.value);\n    });\n\n    // Initialize\n    switchView('overview');\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e`;\n}\n\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/\u0026/g, '\u0026amp;')\n    .replace(/\u003c/g, '\u0026lt;')\n    .replace(/\u003e/g, '\u0026gt;')\n    .replace(/\"/g, '\u0026quot;')\n    .replace(/'/g, '\u0026#039;');\n}\n","weight":7}},{"data":{"id":"structure:5256","label":"applyFilters","type":"function","file":"src/visualize/template.ts","line":708,"signature":"function applyFilters()","content":"    function applyFilters() {\n      if (!cy) return;\n\n      const filters = {\n        function: document.getElementById('filter-function').checked,\n        class: document.getElementById('filter-class').checked,\n        method: document.getElementById('filter-method').checked,\n        interface: document.getElementById('filter-interface').checked,\n        type: document.getElementById('filter-type').checked,\n        file: document.getElementById('filter-file').checked,\n      };\n\n      cy.nodes().forEach(node =\u003e {\n        const type = node.data('type');\n        const visible = filters[type] !== false;\n        node.style('display', visible ? 'element' : 'none');\n      });\n    }","weight":3}},{"data":{"id":"structure:5257","label":"searchNodes","type":"function","file":"src/visualize/template.ts","line":727,"signature":"function searchNodes(query)","content":"    function searchNodes(query) {\n      if (!cy || !query) {\n        cy \u0026\u0026 cy.nodes().style('opacity', 1);\n        return;\n      }\n\n      query = query.toLowerCase();\n      cy.nodes().forEach(node =\u003e {\n        const label = (node.data('label') || '').toLowerCase();\n        const matches = label.includes(query);\n        node.style('opacity', matches ? 1 : 0.2);\n      });\n    }","weight":3}},{"data":{"id":"structure:5259","label":"startDashboardServer","type":"function","file":"src/visualize/server.ts","line":11,"signature":"function startDashboardServer(options: ServerOptions)","content":"export function startDashboardServer(options: ServerOptions): Promise\u003cvoid\u003e {\n  const { port, getData } = options;\n\n  return new Promise((resolve, reject) =\u003e {\n    const server = createServer((req: IncomingMessage, res: ServerResponse) =\u003e {\n      const url = req.url || '/';\n\n      // CORS headers for API\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');\n\n      if (req.method === 'OPTIONS') {\n        res.writeHead(200);\n        res.end();\n        return;\n      }\n\n      if (url === '/' || url === '/index.html') {\n        // Serve dashboard HTML\n        try {\n          const data = getData();\n          const html = generateDashboardHTML(data);\n          res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });\n          res.end(html);\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Error generating dashboard: ' + (error as Error).message);\n        }\n      } else if (url === '/api/data') {\n        // API endpoint for fresh data (for live updates)\n        try {\n          const data = getData();\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify(data));\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({ error: (error as Error).message }));\n        }\n      } else if (url === '/api/health') {\n        // Health check endpoint\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ status: 'ok' }));\n      } else {\n        // 404\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('Not found');\n      }\n    });\n\n    server.on('error', (err: NodeJS.ErrnoException) =\u003e {\n      if (err.code === 'EADDRINUSE') {\n        reject(new Error(`Port ${port} is already in use`));\n      } else {\n        reject(err);\n      }\n    });\n\n    server.listen(port, () =\u003e {\n      resolve();\n    });\n\n    // Handle graceful shutdown\n    process.on('SIGINT', () =\u003e {\n      server.close(() =\u003e {\n        process.exit(0);\n      });\n    });\n\n    process.on('SIGTERM', () =\u003e {\n      server.close(() =\u003e {\n        process.exit(0);\n      });\n    });\n  });\n}","weight":2}},{"data":{"id":"structure:5261","label":"buildVisualizationData","type":"function","file":"src/visualize/index.ts","line":56,"signature":"function buildVisualizationData(\n  project: Project,\n  structures: StructureWithFile[],\n  files: File[],\n  links: Link[],\n  extractions: Extraction[]\n)","content":"export function buildVisualizationData(\n  project: Project,\n  structures: StructureWithFile[],\n  files: File[],\n  links: Link[],\n  extractions: Extraction[]\n): VisualizationData {\n  // Count structures by type\n  const byType: Record\u003cstring, number\u003e = {};\n  for (const s of structures) {\n    byType[s.type] = (byType[s.type] || 0) + 1;\n  }\n\n  return {\n    project,\n    graphs: {\n      overview: buildOverviewGraph(structures, files),\n      callGraph: buildCallGraph(structures, links),\n      dependencies: buildDependencyGraph(structures, files),\n      classes: buildClassGraph(structures, links),\n      decisions: buildDecisionGraph(structures, extractions, links),\n    },\n    stats: {\n      totalStructures: structures.length,\n      totalFiles: files.length,\n      totalLinks: links.length,\n      totalDecisions: extractions.filter(e =\u003e e.type === 'decision').length,\n      byType,\n    },\n  };\n}","weight":6}},{"data":{"id":"structure:5262","label":"buildOverviewGraph","type":"function","file":"src/visualize/index.ts","line":89,"signature":"function buildOverviewGraph(structures: StructureWithFile[], files: File[])","content":"function buildOverviewGraph(structures: StructureWithFile[], files: File[]): GraphData {\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const fileMap = new Map\u003cstring, { count: number, types: Set\u003cstring\u003e }\u003e();\n\n  // Count structures per file\n  for (const s of structures) {\n    if (!fileMap.has(s.file_path)) {\n      fileMap.set(s.file_path, { count: 0, types: new Set() });\n    }\n    const info = fileMap.get(s.file_path)!;\n    info.count++;\n    info.types.add(s.type);\n  }\n\n  // Group files by directory for edges\n  const dirMap = new Map\u003cstring, string[]\u003e();\n  for (const filePath of fileMap.keys()) {\n    const dir = getDirectory(filePath);\n    if (!dirMap.has(dir)) {\n      dirMap.set(dir, []);\n    }\n    dirMap.get(dir)!.push(filePath);\n  }\n\n  // Add file nodes with structure counts\n  for (const [filePath, info] of fileMap) {\n    nodes.push({\n      data: {\n        id: `file:${filePath}`,\n        label: `${getFileName(filePath)} (${info.count})`,\n        type: 'file',\n        file: filePath,\n        content: `Contains ${info.count} structures: ${Array.from(info.types).join(', ')}`,\n      },\n    });\n  }\n\n  return { nodes, edges };\n}","weight":3}},{"data":{"id":"structure:5263","label":"buildCallGraph","type":"function","file":"src/visualize/index.ts","line":131,"signature":"function buildCallGraph(structures: StructureWithFile[], links: Link[])","content":"function buildCallGraph(structures: StructureWithFile[], links: Link[]): GraphData {\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const structureMap = new Map\u003cnumber, StructureWithFile\u003e();\n  const includedIds = new Set\u003cnumber\u003e();\n\n  // Build lookup map\n  for (const s of structures) {\n    structureMap.set(s.id, s);\n  }\n\n  // Find call relationships\n  for (const link of links) {\n    if ((link.link_type === 'calls' || link.link_type === 'called_by') \u0026\u0026\n        link.source_type === 'structure' \u0026\u0026 link.target_type === 'structure') {\n      includedIds.add(link.source_id);\n      includedIds.add(link.target_id);\n\n      const sourceId = link.link_type === 'calls' ? link.source_id : link.target_id;\n      const targetId = link.link_type === 'calls' ? link.target_id : link.source_id;\n\n      edges.push({\n        data: {\n          id: `call:${sourceId}:${targetId}`,\n          source: `structure:${sourceId}`,\n          target: `structure:${targetId}`,\n          type: 'calls',\n          label: 'calls',\n        },\n      });\n    }\n  }\n\n  // Add nodes for structures involved in calls\n  for (const id of includedIds) {\n    const s = structureMap.get(id);\n    if (s \u0026\u0026 (s.type === 'function' || s.type === 'method')) {\n      nodes.push({\n        data: {\n          id: `structure:${s.id}`,\n          label: s.name,\n          type: s.type,\n          file: s.file_path,\n          line: s.line_start,\n          signature: s.signature || undefined,\n          content: s.raw_content,\n        },\n      });\n    }\n  }\n\n  // If no call links, show all functions/methods\n  if (nodes.length === 0) {\n    for (const s of structures) {\n      if (s.type === 'function' || s.type === 'method') {\n        nodes.push({\n          data: {\n            id: `structure:${s.id}`,\n            label: s.name,\n            type: s.type,\n            file: s.file_path,\n            line: s.line_start,\n            signature: s.signature || undefined,\n            content: s.raw_content,\n          },\n        });\n      }\n    }\n  }\n\n  return { nodes, edges };\n}","weight":1}},{"data":{"id":"structure:5264","label":"buildDependencyGraph","type":"function","file":"src/visualize/index.ts","line":205,"signature":"function buildDependencyGraph(structures: StructureWithFile[], files: File[])","content":"function buildDependencyGraph(structures: StructureWithFile[], files: File[]): GraphData {\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const fileSet = new Set\u003cstring\u003e();\n\n  // Get unique files from structures\n  for (const s of structures) {\n    fileSet.add(s.file_path);\n  }\n\n  // Add file nodes\n  for (const filePath of fileSet) {\n    nodes.push({\n      data: {\n        id: `file:${filePath}`,\n        label: getFileName(filePath),\n        type: 'file',\n        file: filePath,\n      },\n    });\n  }\n\n  // For now, just show files - import analysis would require parsing\n  return { nodes, edges };\n}","weight":2}},{"data":{"id":"structure:5265","label":"buildClassGraph","type":"function","file":"src/visualize/index.ts","line":232,"signature":"function buildClassGraph(structures: StructureWithFile[], links: Link[])","content":"function buildClassGraph(structures: StructureWithFile[], links: Link[]): GraphData {\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const classIds = new Set\u003cnumber\u003e();\n  const structureMap = new Map\u003cnumber, StructureWithFile\u003e();\n\n  for (const s of structures) {\n    structureMap.set(s.id, s);\n  }\n\n  // Find classes and interfaces\n  for (const s of structures) {\n    if (s.type === 'class' || s.type === 'interface') {\n      classIds.add(s.id);\n      nodes.push({\n        data: {\n          id: `structure:${s.id}`,\n          label: s.name,\n          type: s.type,\n          file: s.file_path,\n          line: s.line_start,\n          signature: s.signature || undefined,\n          content: s.raw_content,\n        },\n      });\n    }\n  }\n\n  // Find methods that belong to classes (by file proximity or metadata)\n  // This is a simplified approach - methods appear near their class\n  for (const s of structures) {\n    if (s.type === 'method') {\n      nodes.push({\n        data: {\n          id: `structure:${s.id}`,\n          label: s.name,\n          type: s.type,\n          file: s.file_path,\n          line: s.line_start,\n          signature: s.signature || undefined,\n          content: s.raw_content,\n        },\n      });\n    }\n  }\n\n  return { nodes, edges };\n}","weight":1}},{"data":{"id":"structure:5266","label":"buildDecisionGraph","type":"function","file":"src/visualize/index.ts","line":282,"signature":"function buildDecisionGraph(\n  structures: StructureWithFile[],\n  extractions: Extraction[],\n  links: Link[]\n)","content":"function buildDecisionGraph(\n  structures: StructureWithFile[],\n  extractions: Extraction[],\n  links: Link[]\n): GraphData {\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const structureMap = new Map\u003cnumber, StructureWithFile\u003e();\n  const affectedStructures = new Set\u003cnumber\u003e();\n\n  for (const s of structures) {\n    structureMap.set(s.id, s);\n  }\n\n  // Add extraction nodes (decisions, patterns, rejections)\n  for (const e of extractions) {\n    if (e.type === 'decision' || e.type === 'pattern' || e.type === 'rejection') {\n      nodes.push({\n        data: {\n          id: `extraction:${e.id}`,\n          label: truncate(e.content, 50),\n          type: e.type,\n          content: e.content,\n        },\n      });\n    }\n  }\n\n  // Find links between extractions and structures\n  for (const link of links) {\n    if (link.source_type === 'extraction' \u0026\u0026 link.target_type === 'structure') {\n      affectedStructures.add(link.target_id);\n      edges.push({\n        data: {\n          id: `decision-link:${link.source_id}:${link.target_id}`,\n          source: `extraction:${link.source_id}`,\n          target: `structure:${link.target_id}`,\n          type: link.link_type,\n          label: link.link_type,\n        },\n      });\n    }\n  }\n\n  // Add structure nodes that are affected by decisions\n  for (const id of affectedStructures) {\n    const s = structureMap.get(id);\n    if (s) {\n      nodes.push({\n        data: {\n          id: `structure:${s.id}`,\n          label: s.name,\n          type: s.type,\n          file: s.file_path,\n          line: s.line_start,\n          content: s.raw_content,\n        },\n      });\n    }\n  }\n\n  return { nodes, edges };\n}","weight":2}},{"data":{"id":"structure:5268","label":"getDirectory","type":"function","file":"src/visualize/index.ts","line":353,"signature":"function getDirectory(filePath: string)","content":"function getDirectory(filePath: string): string {\n  const parts = filePath.split(/[/\\\\]/);\n  parts.pop();\n  return parts.join('/') || '.';\n}","weight":1}},{"data":{"id":"structure:5267","label":"getFileName","type":"function","file":"src/visualize/index.ts","line":347,"signature":"function getFileName(filePath: string)","content":"function getFileName(filePath: string): string {\n  const parts = filePath.split(/[/\\\\]/);\n  return parts[parts.length - 1] || filePath;\n}","weight":2}},{"data":{"id":"structure:5269","label":"truncate","type":"function","file":"src/visualize/index.ts","line":360,"signature":"function truncate(str: string, maxLen: number)","content":"function truncate(str: string, maxLen: number): string {\n  if (str.length \u003c= maxLen) return str;\n  return str.slice(0, maxLen - 3) + '...';\n}","weight":1}},{"data":{"id":"structure:5270","label":"generateDashboard","type":"function","file":"src/visualize/index.ts","line":366,"signature":"function generateDashboard(data: VisualizationData)","content":"export function generateDashboard(data: VisualizationData): string {\n  return generateDashboardHTML(data);\n}","weight":2}},{"data":{"id":"structure:5276","label":"__init__","type":"method","file":"src/proxy/interceptor.py","line":72,"signature":"def __init__(self)","content":"    def __init__(self):\n        self.data_dir = os.environ.get(\"AIMEM_DATA_DIR\", os.path.expanduser(\"~/.aimem\"))\n        self.db_path = os.path.join(self.data_dir, \"aimem.db\")\n        self.pending_requests = {}\n        self.current_project_id = None\n        self._detect_project()\n","weight":1}},{"data":{"id":"structure:5277","label":"_detect_project","type":"method","file":"src/proxy/interceptor.py","line":78,"signature":"def _detect_project(self)","content":"","weight":1}},{"data":{"id":"structure:5296","label":"getEntityContext","type":"function","file":"src/query/index.ts","line":33,"signature":"function getEntityContext(entityName: string)","content":"export function getEntityContext(entityName: string): ContextResult {\n  const structures = getStructuresByName(entityName);\n  const result: ContextResult = {\n    structures: [],\n    decisions: [],\n    rejections: [],\n    patterns: [],\n    relatedConversations: [],\n  };\n\n  for (const structure of structures) {\n    const file = getFile(structure.file_id);\n\n    result.structures.push({\n      type: structure.type,\n      name: structure.name,\n      file: file?.path || 'unknown',\n      line: structure.line_start,\n      signature: structure.signature,\n      content: structure.raw_content,\n    });\n\n    // Get linked conversations and extractions\n    const links = getLinksTo('structure', structure.id);\n\n    for (const link of links) {\n      if (link.source_type === 'conversation') {\n        const extractions = getConversationExtractions(link.source_id);\n\n        for (const extraction of extractions) {\n          switch (extraction.type) {\n            case 'decision':\n              result.decisions.push(extraction);\n              break;\n            case 'rejection':\n              result.rejections.push(extraction);\n              break;\n            case 'pattern':\n              result.patterns.push(extraction);\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}","weight":4}},{"data":{"id":"structure:5340","label":"getStructuresByName","type":"function","file":"src/db/index.ts","line":143,"signature":"function getStructuresByName(name: string, projectId?: number)","content":"export function getStructuresByName(name: string, projectId?: number): Structure[] {\n  const db = getDb();\n  if (projectId) {\n    return db.prepare(`\n      SELECT s.* FROM structures s\n      JOIN files f ON s.file_id = f.id\n      WHERE s.name = ? AND f.project_id = ?\n    `).all(name, projectId) as Structure[];\n  }\n  return db.prepare('SELECT * FROM structures WHERE name = ?').all(name) as Structure[];\n}","weight":5}},{"data":{"id":"structure:5333","label":"getFile","type":"function","file":"src/db/index.ts","line":77,"signature":"function getFile(id: number)","content":"export function getFile(id: number): File | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM files WHERE id = ?').get(id) as File | undefined;\n}","weight":9}},{"data":{"id":"structure:5346","label":"getLinksTo","type":"function","file":"src/db/index.ts","line":227,"signature":"function getLinksTo(targetType: Link['target_type'], targetId: number)","content":"export function getLinksTo(targetType: Link['target_type'], targetId: number): Link[] {\n  const db = getDb();\n  return db.prepare('SELECT * FROM links WHERE target_type = ? AND target_id = ?').all(targetType, targetId) as Link[];\n}","weight":7}},{"data":{"id":"structure:5348","label":"getConversationExtractions","type":"function","file":"src/db/index.ts","line":248,"signature":"function getConversationExtractions(conversationId: number)","content":"export function getConversationExtractions(conversationId: number): Extraction[] {\n  const db = getDb();\n  return db.prepare('SELECT * FROM extractions WHERE conversation_id = ?').all(conversationId) as Extraction[];\n}","weight":7}},{"data":{"id":"structure:5297","label":"searchContext","type":"function","file":"src/query/index.ts","line":85,"signature":"function searchContext(query: string, limit = 10)","content":"export function searchContext(query: string, limit = 10): ContextResult {\n  const result: ContextResult = {\n    structures: [],\n    decisions: [],\n    rejections: [],\n    patterns: [],\n    relatedConversations: [],\n  };\n\n  // Search structures\n  const structures = searchStructures(query, limit);\n  for (const s of structures) {\n    const file = getFile(s.file_id);\n    result.structures.push({\n      type: s.type,\n      name: s.name,\n      file: file?.path || 'unknown',\n      line: s.line_start,\n      signature: s.signature,\n      content: s.raw_content,\n    });\n  }\n\n  // Search conversations\n  const conversations = searchConversations(query, limit);\n  for (const c of conversations) {\n    result.relatedConversations.push({\n      id: c.id,\n      timestamp: c.timestamp,\n      summary: c.summary,\n    });\n\n    // Get extractions from these conversations\n    const extractions = getConversationExtractions(c.id);\n    for (const e of extractions) {\n      switch (e.type) {\n        case 'decision':\n          result.decisions.push(e);\n          break;\n        case 'rejection':\n          result.rejections.push(e);\n          break;\n        case 'pattern':\n          result.patterns.push(e);\n          break;\n      }\n    }\n  }\n\n  return result;\n}","weight":4}},{"data":{"id":"structure:5339","label":"searchStructures","type":"function","file":"src/db/index.ts","line":122,"signature":"function searchStructures(query: string, limit = 20, projectId?: number)","content":"export function searchStructures(query: string, limit = 20, projectId?: number): Structure[] {\n  const db = getDb();\n  if (projectId) {\n    return db.prepare(`\n      SELECT s.* FROM structures s\n      JOIN structures_fts fts ON s.id = fts.rowid\n      JOIN files f ON s.file_id = f.id\n      WHERE structures_fts MATCH ? AND f.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit) as Structure[];\n  }\n  return db.prepare(`\n    SELECT s.* FROM structures s\n    JOIN structures_fts fts ON s.id = fts.rowid\n    WHERE structures_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit) as Structure[];\n}","weight":7}},{"data":{"id":"structure:5343","label":"searchConversations","type":"function","file":"src/db/index.ts","line":185,"signature":"function searchConversations(query: string, limit = 20, projectId?: number)","content":"export function searchConversations(query: string, limit = 20, projectId?: number): Conversation[] {\n  const db = getDb();\n  if (projectId) {\n    return db.prepare(`\n      SELECT c.* FROM conversations c\n      JOIN conversations_fts fts ON c.id = fts.rowid\n      WHERE conversations_fts MATCH ? AND c.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit) as Conversation[];\n  }\n  return db.prepare(`\n    SELECT c.* FROM conversations c\n    JOIN conversations_fts fts ON c.id = fts.rowid\n    WHERE conversations_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit) as Conversation[];\n}","weight":7}},{"data":{"id":"structure:5300","label":"startMcpServer","type":"function","file":"src/mcp/server.ts","line":23,"signature":"function startMcpServer()","content":"export async function startMcpServer(): Promise\u003cvoid\u003e {\n  const server = new Server(\n    {\n      name: 'aimem',\n      version: '0.1.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // List available tools\n  server.setRequestHandler(ListToolsRequestSchema, async () =\u003e ({\n    tools: [\n      {\n        name: 'aimem_query',\n        description: 'Search for code structures (functions, classes, etc.) and past conversations. Use this to find relevant context about the codebase.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query - can be a function name, class name, or keyword',\n            },\n            type: {\n              type: 'string',\n              enum: ['all', 'structures', 'conversations'],\n              description: 'What to search: all, structures, or conversations',\n              default: 'all',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of results',\n              default: 10,\n            },\n          },\n          required: ['query'],\n        },\n      },\n      {\n        name: 'aimem_context',\n        description: 'Get relevant context for a specific code entity (function, class, file). Returns the structure details plus any related decisions and conversations.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the function, class, or entity to get context for',\n            },\n          },\n          required: ['name'],\n        },\n      },\n      {\n        name: 'aimem_decisions',\n        description: 'Get all decisions made about a specific code entity. Useful for understanding why something was built a certain way.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            entity: {\n              type: 'string',\n              description: 'Name of the entity to get decisions for',\n            },\n          },\n          required: ['entity'],\n        },\n      },\n      {\n        name: 'aimem_verify',\n        description: 'Verify that a code entity (function, class, file) exists in the codebase. Use this to check claims before making them.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the function or class to verify',\n            },\n            type: {\n              type: 'string',\n              enum: ['structure', 'file'],\n              description: 'Type of entity to verify',\n              default: 'structure',\n            },\n          },\n          required: ['name'],\n        },\n      },\n      {\n        name: 'aimem_conversations',\n        description: 'Search and retrieve full conversation history from past Claude/AI sessions. Use this for long-term memory - finding past discussions, decisions, and context about the project.',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: {\n              type: 'string',\n              description: 'Search query to find relevant conversations (keywords, topics, or questions)',\n            },\n            id: {\n              type: 'number',\n              description: 'Get a specific conversation by ID',\n            },\n            limit: {\n              type: 'number',\n              description: 'Maximum number of conversations to return',\n              default: 5,\n            },\n          },\n        },\n      },\n    ],\n  }));\n\n  // Handle tool calls\n  server.setRequestHandler(CallToolRequestSchema, async (request) =\u003e {\n    const { name, arguments: args } = request.params;\n\n    try {\n      switch (name) {\n        case 'aimem_query': {\n          const query = args?.query as string;\n          const type = (args?.type as string) || 'all';\n          const limit = (args?.limit as number) || 10;\n\n          const results: { structures?: unknown[]; conversations?: unknown[] } = {};\n\n          if (type === 'all' || type === 'structures') {\n            const structures = searchStructures(query, limit);\n            results.structures = structures.map(s =\u003e ({\n              type: s.type,\n              name: s.name,\n              file: getFile(s.file_id)?.path,\n              line: s.line_start,\n              signature: s.signature,\n            }));\n          }\n\n          if (type === 'all' || type === 'conversations') {\n            const conversations = searchConversations(query, limit);\n            results.conversations = conversations.map(c =\u003e ({\n              id: c.id,\n              timestamp: c.timestamp,\n              model: c.model,\n              summary: c.summary || c.raw_content.slice(0, 200),\n            }));\n          }\n\n          return {\n            content: [{ type: 'text', text: JSON.stringify(results, null, 2) }],\n          };\n        }\n\n        case 'aimem_context': {\n          const entityName = args?.name as string;\n          const structures = getStructuresByName(entityName);\n\n          if (structures.length === 0) {\n            return {\n              content: [{ type: 'text', text: `No entity found with name: ${entityName}` }],\n            };\n          }\n\n          const context = structures.map(s =\u003e {\n            const file = getFile(s.file_id);\n            const links = getLinksTo('structure', s.id);\n\n            return {\n              type: s.type,\n              name: s.name,\n              file: file?.path,\n              line: s.line_start,\n              signature: s.signature,\n              content: s.raw_content,\n              relatedConversations: links.filter(l =\u003e l.source_type === 'conversation').length,\n              decisions: links.filter(l =\u003e l.link_type === 'decision').length,\n            };\n          });\n\n          return {\n            content: [{ type: 'text', text: JSON.stringify(context, null, 2) }],\n          };\n        }\n\n        case 'aimem_decisions': {\n          const entity = args?.entity as string;\n          const structures = getStructuresByName(entity);\n\n          const decisions: unknown[] = [];\n\n          if (structures.length \u003e 0) {\n            // Found matching code structures - get linked decisions\n            for (const s of structures) {\n              const links = getLinksTo('structure', s.id);\n              for (const link of links) {\n                if (link.source_type === 'extraction') {\n                  const extraction = getExtraction(link.source_id);\n                  if (extraction) {\n                    decisions.push({\n                      type: extraction.type,\n                      content: extraction.content,\n                      link_type: link.link_type,\n                      source: 'linked',\n                    });\n                  }\n                } else if (link.source_type === 'conversation') {\n                  const extractions = getConversationExtractions(link.source_id);\n                  decisions.push(...extractions\n                    .filter(e =\u003e e.type === 'decision' || e.type === 'rejection')\n                    .map(e =\u003e ({ ...e, source: 'linked' })));\n                }\n              }\n            }\n          }\n\n          // Fallback: keyword search in decision content\n          if (decisions.length === 0) {\n            const keywordResults = searchExtractions(entity, 10);\n            for (const ext of keywordResults) {\n              decisions.push({\n                type: ext.type,\n                content: ext.content,\n                source: 'keyword_search',\n              });\n            }\n          }\n\n          if (decisions.length === 0) {\n            return {\n              content: [{ type: 'text', text: `No decisions found for: ${entity}` }],\n            };\n          }\n\n          return {\n            content: [{ type: 'text', text: JSON.stringify(decisions, null, 2) }],\n          };\n        }\n\n        case 'aimem_verify': {\n          const entityName = args?.name as string;\n          const entityType = (args?.type as string) || 'structure';\n\n          let exists = false;\n          if (entityType === 'structure') {\n            exists = structureExists(entityName);\n          } else if (entityType === 'file') {\n            exists = fileExists(entityName);\n          }\n\n          return {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({\n                name: entityName,\n                type: entityType,\n                exists,\n                message: exists\n                  ? `${entityType} \"${entityName}\" exists in the codebase`\n                  : `${entityType} \"${entityName}\" was NOT found in the codebase`,\n              }, null, 2),\n            }],\n          };\n        }\n\n        case 'aimem_conversations': {\n          const query = args?.query as string | undefined;\n          const id = args?.id as number | undefined;\n          const limit = (args?.limit as number) || 5;\n\n          // Get specific conversation by ID\n          if (id !== undefined) {\n            const conversation = getConversationById(id);\n            if (!conversation) {\n              return {\n                content: [{ type: 'text', text: `No conversation found with ID: ${id}` }],\n              };\n            }\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify({\n                  id: conversation.id,\n                  timestamp: conversation.timestamp,\n                  model: conversation.model,\n                  tool: conversation.tool,\n                  summary: conversation.summary,\n                  content: conversation.raw_content,\n                }, null, 2),\n              }],\n            };\n          }\n\n          // Search conversations\n          if (!query) {\n            return {\n              content: [{ type: 'text', text: 'Please provide a query to search conversations, or an id to get a specific conversation' }],\n            };\n          }\n\n          // Try to scope to current project\n          const cwd = process.cwd();\n          const project = findProjectForPath(cwd);\n          const projectId = project?.id;\n\n          const conversations = searchFullConversations(query, limit, projectId);\n\n          if (conversations.length === 0) {\n            return {\n              content: [{ type: 'text', text: `No conversations found matching: ${query}` }],\n            };\n          }\n\n          const results = conversations.map(c =\u003e ({\n            id: c.id,\n            timestamp: c.timestamp,\n            model: c.model,\n            tool: c.tool,\n            summary: c.summary,\n            content: c.raw_content.length \u003e 2000\n              ? c.raw_content.slice(0, 2000) + '... [truncated - use id to get full content]'\n              : c.raw_content,\n          }));\n\n          return {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({\n                query,\n                count: results.length,\n                conversations: results,\n              }, null, 2),\n            }],\n          };\n        }\n\n        default:\n          return {\n            content: [{ type: 'text', text: `Unknown tool: ${name}` }],\n            isError: true,\n          };\n      }\n    } catch (error) {\n      return {\n        content: [{ type: 'text', text: `Error: ${(error as Error).message}` }],\n        isError: true,\n      };\n    }\n  });\n\n  // Start server\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}","weight":15}},{"data":{"id":"structure:5349","label":"getExtraction","type":"function","file":"src/db/index.ts","line":253,"signature":"function getExtraction(id: number)","content":"export function getExtraction(id: number): Extraction | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM extractions WHERE id = ?').get(id) as Extraction | undefined;\n}","weight":3}},{"data":{"id":"structure:5350","label":"searchExtractions","type":"function","file":"src/db/index.ts","line":258,"signature":"function searchExtractions(query: string, limit = 20, projectId?: number)","content":"export function searchExtractions(query: string, limit = 20, projectId?: number): Extraction[] {\n  const db = getDb();\n  const searchTerm = `%${query}%`;\n\n  if (projectId) {\n    return db.prepare(`\n      SELECT e.* FROM extractions e\n      JOIN conversations c ON e.conversation_id = c.id\n      WHERE e.content LIKE ? AND c.project_id = ?\n      ORDER BY e.id DESC\n      LIMIT ?\n    `).all(searchTerm, projectId, limit) as Extraction[];\n  }\n\n  return db.prepare(`\n    SELECT * FROM extractions\n    WHERE content LIKE ?\n    ORDER BY id DESC\n    LIMIT ?\n  `).all(searchTerm, limit) as Extraction[];\n}","weight":3}},{"data":{"id":"structure:5353","label":"structureExists","type":"function","file":"src/db/index.ts","line":310,"signature":"function structureExists(name: string)","content":"export function structureExists(name: string): boolean {\n  const db = getDb();\n  const result = db.prepare('SELECT 1 FROM structures WHERE name = ? LIMIT 1').get(name);\n  return result !== undefined;\n}","weight":3}},{"data":{"id":"structure:5354","label":"fileExists","type":"function","file":"src/db/index.ts","line":316,"signature":"function fileExists(path: string)","content":"export function fileExists(path: string): boolean {\n  const db = getDb();\n  const result = db.prepare('SELECT 1 FROM files WHERE path = ? LIMIT 1').get(path);\n  return result !== undefined;\n}","weight":3}},{"data":{"id":"structure:5355","label":"getConversationById","type":"function","file":"src/db/index.ts","line":323,"signature":"function getConversationById(id: number)","content":"export function getConversationById(id: number): Conversation | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM conversations WHERE id = ?').get(id) as Conversation | undefined;\n}","weight":3}},{"data":{"id":"structure:5341","label":"findProjectForPath","type":"function","file":"src/db/index.ts","line":156,"signature":"function findProjectForPath(targetPath: string)","content":"export function findProjectForPath(targetPath: string): Project | undefined {\n  const projects = getAllProjects();\n  // Sort by path length descending to find most specific match\n  projects.sort((a, b) =\u003e b.path.length - a.path.length);\n  for (const project of projects) {\n    if (targetPath.startsWith(project.path)) {\n      return project;\n    }\n  }\n  return undefined;\n}","weight":6}},{"data":{"id":"structure:5357","label":"searchFullConversations","type":"function","file":"src/db/index.ts","line":340,"signature":"function searchFullConversations(query: string, limit = 20, projectId?: number)","content":"export function searchFullConversations(query: string, limit = 20, projectId?: number): Conversation[] {\n  const db = getDb();\n  if (projectId) {\n    return db.prepare(`\n      SELECT c.* FROM conversations c\n      JOIN conversations_fts fts ON c.id = fts.rowid\n      WHERE conversations_fts MATCH ? AND c.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit) as Conversation[];\n  }\n  return db.prepare(`\n    SELECT c.* FROM conversations c\n    JOIN conversations_fts fts ON c.id = fts.rowid\n    WHERE conversations_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit) as Conversation[];\n}","weight":3}},{"data":{"id":"structure:5309","label":"indexFile","type":"function","file":"src/indexer/index.ts","line":74,"signature":"function indexFile(\n  projectId: number,\n  projectPath: string,\n  relativePath: string,\n  pendingCalls?: PendingCall[]\n)","content":"export async function indexFile(\n  projectId: number,\n  projectPath: string,\n  relativePath: string,\n  pendingCalls?: PendingCall[]\n): Promise\u003cnumber\u003e {\n  const fullPath = join(projectPath, relativePath);\n  const parser = getParser(fullPath);\n\n  if (!parser) {\n    return 0;\n  }\n\n  try {\n    const content = readFileSync(fullPath, 'utf-8');\n    const hash = getFileHash(content);\n\n    // Upsert file record\n    const file = upsertFile(projectId, relativePath, hash);\n\n    // Clear existing structures for this file\n    deleteFileStructures(file.id);\n\n    // Parse and store structures\n    const structures = parser.parse(content, relativePath);\n\n    for (const s of structures) {\n      const inserted = insertStructure(\n        file.id,\n        s.type,\n        s.name,\n        s.lineStart,\n        s.lineEnd,\n        s.signature,\n        s.rawContent,\n        s.metadata\n      );\n\n      // Collect pending calls to resolve later\n      if (pendingCalls \u0026\u0026 s.calls \u0026\u0026 s.calls.length \u003e 0) {\n        for (const calledName of s.calls) {\n          pendingCalls.push({\n            callerId: inserted.id,\n            calledName,\n          });\n        }\n      }\n    }\n\n    return structures.length;\n  } catch (err) {\n    // File might have been deleted or unreadable\n    console.error(`Error indexing ${relativePath}:`, err);\n    return 0;\n  }\n}","weight":6}},{"data":{"id":"structure:5307","label":"getParser","type":"function","file":"src/indexer/index.ts","line":55,"signature":"function getParser(filePath: string)","content":"function getParser(filePath: string): Parser | null {\n  const ext = extname(filePath).toLowerCase();\n  return extensionMap.get(ext) || null;\n}","weight":2}},{"data":{"id":"structure:5306","label":"getFileHash","type":"function","file":"src/indexer/index.ts","line":51,"signature":"function getFileHash(content: string)","content":"function getFileHash(content: string): string {\n  return createHash('md5').update(content).digest('hex');\n}","weight":2}},{"data":{"id":"structure:5332","label":"upsertFile","type":"function","file":"src/db/index.ts","line":64,"signature":"function upsertFile(projectId: number, path: string, hash: string)","content":"export function upsertFile(projectId: number, path: string, hash: string): File {\n  const db = getDb();\n  const stmt = db.prepare(`\n    INSERT INTO files (project_id, path, hash, last_indexed)\n    VALUES (?, ?, ?, datetime('now'))\n    ON CONFLICT(project_id, path) DO UPDATE SET\n      hash = excluded.hash,\n      last_indexed = datetime('now')\n    RETURNING *\n  `);\n  return stmt.get(projectId, path, hash) as File;\n}","weight":3}},{"data":{"id":"structure:5338","label":"deleteFileStructures","type":"function","file":"src/db/index.ts","line":117,"signature":"function deleteFileStructures(fileId: number)","content":"export function deleteFileStructures(fileId: number): void {\n  const db = getDb();\n  db.prepare('DELETE FROM structures WHERE file_id = ?').run(fileId);\n}","weight":3}},{"data":{"id":"structure:5337","label":"insertStructure","type":"function","file":"src/db/index.ts","line":98,"signature":"function insertStructure(\n  fileId: number,\n  type: Structure['type'],\n  name: string,\n  lineStart: number,\n  lineEnd: number,\n  signature: string | null,\n  rawContent: string,\n  metadata: Record\u003cstring, unknown\u003e = {}\n)","content":"export function insertStructure(\n  fileId: number,\n  type: Structure['type'],\n  name: string,\n  lineStart: number,\n  lineEnd: number,\n  signature: string | null,\n  rawContent: string,\n  metadata: Record\u003cstring, unknown\u003e = {}","weight":2}},{"data":{"id":"structure:5313","label":"extractDecisions","type":"function","file":"src/extractor/index.ts","line":23,"signature":"function extractDecisions(messages: TranscriptMessage[])","content":"export function extractDecisions(messages: TranscriptMessage[]): ExtractedItem[] {\n  const extractions: ExtractedItem[] = [];\n\n  // Decision patterns - phrases that indicate a choice was made\n  const decisionPatterns = [\n    /(?:we should|let's|I'll|I will|going to|decided to|will use|using|chose|choosing|the best approach is|recommend using)\\s+(.+?)(?:\\.|$)/gi,\n    /(?:the approach|the solution|the fix|the implementation|the strategy)\\s+(?:is|will be|should be)\\s+(.+?)(?:\\.|$)/gi,\n    /(?:because|since|the reason is|this is because)\\s+(.+?)(?:\\.|$)/gi,\n    /(?:I've implemented|I've added|I've created|I've updated)\\s+(.+?)(?:\\.|$)/gi,\n  ];\n\n  // Rejection patterns - phrases that indicate something was ruled out\n  const rejectionPatterns = [\n    /(?:instead of|rather than|not using|won't use|shouldn't use|avoid using|don't use)\\s+(.+?)(?:\\.|$)/gi,\n    /(?:rejected|ruled out|decided against|not recommended|wouldn't work)\\s+(.+?)(?:\\.|$)/gi,\n    /(?:the problem with|the issue with|doesn't work because)\\s+(.+?)(?:\\.|$)/gi,\n  ];\n\n  // Entity patterns for linking to code structures\n  const classPattern = /\\b([A-Z][a-zA-Z0-9]*(?:Service|Controller|Model|Helper|Manager|Handler|Factory|Builder|Provider|Middleware|Client|Server|Worker|Job|Task|Command|Query|Event|Listener|Observer|Strategy|Adapter|Decorator|Proxy|Repository|Gateway|Validator|Serializer|Parser|Formatter|Renderer|Component|Module|Plugin|Extension)?)\\b/g;\n  const functionPattern = /\\b([a-z_][a-z0-9_]*)\\s*\\(/g;\n  const methodPattern = /(?:def|function|const|let|var)\\s+([a-z_][a-z0-9_]*)/g;\n  const filePattern = /(?:in|from|file|at)\\s+[`\"']?([a-zA-Z0-9_/.-]+\\.[a-z]+)[`\"']?/gi;\n\n  for (const msg of messages) {\n    if (msg.role !== 'assistant') continue;\n\n    const content = getMessageContent(msg);\n    if (!content) continue;\n\n    // Extract decisions\n    for (const pattern of decisionPatterns) {\n      pattern.lastIndex = 0; // Reset regex state\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const sentence = getSentenceAround(content, match.index);\n        if (isValidExtraction(sentence)) {\n          const entities = extractEntities(sentence, classPattern, functionPattern, methodPattern);\n          extractions.push({\n            type: 'decision',\n            content: cleanSentence(sentence),\n            mentionedEntities: entities,\n            metadata: {\n              patternType: 'decision',\n              originalMatch: match[0].slice(0, 100)\n            }\n          });\n        }\n      }\n    }\n\n    // Extract rejections\n    for (const pattern of rejectionPatterns) {\n      pattern.lastIndex = 0;\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const sentence = getSentenceAround(content, match.index);\n        if (isValidExtraction(sentence)) {\n          const entities = extractEntities(sentence, classPattern, functionPattern, methodPattern);\n          extractions.push({\n            type: 'rejection',\n            content: cleanSentence(sentence),\n            mentionedEntities: entities,\n            metadata: {\n              patternType: 'rejection',\n              originalMatch: match[0].slice(0, 100)\n            }\n          });\n        }\n      }\n    }\n  }\n\n  // Deduplicate and return\n  return deduplicateExtractions(extractions);\n}\n\n/**\n * Get text content from a message, handling different content formats\n */\nfunction getMessageContent(msg: TranscriptMessage): string {\n  if (typeof msg.content === 'string') {\n    return msg.content;\n  }\n  if (Array.isArray(msg.content)) {\n    return msg.content\n      .map(c =\u003e c.text)\n      .filter(Boolean)\n      .join('\\n');\n  }\n  return '';\n}\n\n/**\n * Get the sentence containing the match index\n */\nfunction getSentenceAround(text: string, index: number): string {\n  // Find sentence boundaries (., !, ?, or newlines)\n  const sentenceEnders = /[.!?]\\s|\\n\\n/g;\n\n  let start = 0;\n  let end = text.length;\n\n  // Find start of sentence\n  const beforeText = text.slice(0, index);\n  const lastEnder = beforeText.search(/[.!?]\\s[^.!?]*$/);\n  if (lastEnder !== -1) {\n    start = lastEnder + 2;\n  }\n  const lastNewline = beforeText.lastIndexOf('\\n\\n');\n  if (lastNewline \u003e start) {\n    start = lastNewline + 2;\n  }\n\n  // Find end of sentence\n  const afterText = text.slice(index);\n  const nextEnderMatch = afterText.match(/[.!?](?:\\s|$)/);\n  if (nextEnderMatch \u0026\u0026 nextEnderMatch.index !== undefined) {\n    end = index + nextEnderMatch.index + 1;\n  }\n  const nextNewline = afterText.indexOf('\\n\\n');\n  if (nextNewline !== -1 \u0026\u0026 index + nextNewline \u003c end) {\n    end = index + nextNewline;\n  }\n\n  return text.slice(start, end).trim();\n}\n\n/**\n * Check if extraction is valid (not too short, not too long, not code)\n */\nfunction isValidExtraction(sentence: string): boolean {\n  // Too short or too long\n  if (sentence.length \u003c 30 || sentence.length \u003e 500) {\n    return false;\n  }\n\n  // Looks like code (too many special characters)\n  const codeIndicators = sentence.match(/[{}()\\[\\];=\u003c\u003e]/g);\n  if (codeIndicators \u0026\u0026 codeIndicators.length \u003e 5) {\n    return false;\n  }\n\n  // Is a code block\n  if (sentence.includes('```') || sentence.startsWith('  ') || sentence.startsWith('\\t')) {\n    return false;\n  }\n\n  // Is just a list item number or bullet\n  if (/^[\\d\\-*‚Ä¢]\\s/.test(sentence) \u0026\u0026 sentence.length \u003c 50) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Clean up a sentence for storage\n */\nfunction cleanSentence(sentence: string): string {\n  return sentence\n    .replace(/\\s+/g, ' ')  // Normalize whitespace\n    .replace(/^[-*‚Ä¢]\\s*/, '')  // Remove list markers\n    .replace(/^\\d+\\.\\s*/, '')  // Remove numbered list markers\n    .trim();\n}\n\n/**\n * Extract entity names from text using patterns\n */\nfunction extractEntities(text: string, ...patterns: RegExp[]): string[] {\n  const entities = new Set\u003cstring\u003e();\n\n  for (const pattern of patterns) {\n    const p = new RegExp(pattern.source, pattern.flags);\n    let match;\n    while ((match = p.exec(text)) !== null) {\n      const entity = match[1];\n      // Filter out common false positives\n      if (entity \u0026\u0026 entity.length \u003e 2 \u0026\u0026 !isCommonWord(entity)) {\n        entities.add(entity);\n      }\n    }\n  }\n\n  return [...entities];\n}\n\n/**\n * Check if a word is too common to be a meaningful entity\n */\nfunction isCommonWord(word: string): boolean {\n  const commonWords = new Set([\n    'the', 'this', 'that', 'these', 'those', 'then', 'than',\n    'will', 'would', 'should', 'could', 'can', 'may', 'might',\n    'have', 'has', 'had', 'get', 'set', 'let', 'var', 'const',\n    'function', 'class', 'def', 'return', 'true', 'false', 'null',\n    'undefined', 'new', 'for', 'while', 'if', 'else', 'try', 'catch',\n    'import', 'export', 'from', 'require', 'module', 'use', 'using',\n    'not', 'and', 'but', 'with', 'was', 'were', 'are', 'been',\n    'being', 'does', 'done', 'doing', 'did', 'make', 'made', 'making',\n    'String', 'Number', 'Boolean', 'Array', 'Object', 'Date', 'Error',\n    'Promise', 'Map', 'Set', 'JSON', 'Math', 'console', 'process',\n  ]);\n  return commonWords.has(word) || commonWords.has(word.toLowerCase());\n}\n\n/**\n * Remove duplicate or very similar extractions\n */\nfunction deduplicateExtractions(extractions: ExtractedItem[]): ExtractedItem[] {\n  const seen = new Set\u003cstring\u003e();\n  const result: ExtractedItem[] = [];\n\n  for (const ext of extractions) {\n    // Create a normalized key for comparison\n    const key = ext.content\n      .toLowerCase()\n      .replace(/\\s+/g, ' ')\n      .slice(0, 80);\n\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(ext);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Generate a summary of the conversation for storage\n */\nexport function generateSummary(messages: TranscriptMessage[]): string {\n  const userMessages = messages\n    .filter(m =\u003e m.role === 'user')\n    .map(m =\u003e getMessageContent(m))\n    .filter(c =\u003e c.length \u003e 0);\n\n  if (userMessages.length === 0) {\n    return 'Empty conversation';\n  }\n\n  // Use first user message as base for summary\n  const firstMessage = userMessages[0].slice(0, 200);\n  const topicHint = userMessages.length \u003e 1\n    ? ` (${userMessages.length} exchanges)`\n    : '';\n\n  return `${firstMessage}${topicHint}`;\n}\n","weight":16}},{"data":{"id":"structure:5314","label":"getMessageContent","type":"function","file":"src/extractor/index.ts","line":103,"signature":"function getMessageContent(msg: TranscriptMessage)","content":"function getMessageContent(msg: TranscriptMessage): string {\n  if (typeof msg.content === 'string') {\n    return msg.content;\n  }\n  if (Array.isArray(msg.content)) {\n    return msg.content\n      .map(c =\u003e c.text)\n      .filter(Boolean)\n      .join('\\n');\n  }\n  return '';\n}","weight":4}},{"data":{"id":"structure:5315","label":"getSentenceAround","type":"function","file":"src/extractor/index.ts","line":119,"signature":"function getSentenceAround(text: string, index: number)","content":"function getSentenceAround(text: string, index: number): string {\n  // Find sentence boundaries (., !, ?, or newlines)\n  const sentenceEnders = /[.!?]\\s|\\n\\n/g;\n\n  let start = 0;\n  let end = text.length;\n\n  // Find start of sentence\n  const beforeText = text.slice(0, index);\n  const lastEnder = beforeText.search(/[.!?]\\s[^.!?]*$/);\n  if (lastEnder !== -1) {\n    start = lastEnder + 2;\n  }\n  const lastNewline = beforeText.lastIndexOf('\\n\\n');\n  if (lastNewline \u003e start) {\n    start = lastNewline + 2;\n  }\n\n  // Find end of sentence\n  const afterText = text.slice(index);\n  const nextEnderMatch = afterText.match(/[.!?](?:\\s|$)/);\n  if (nextEnderMatch \u0026\u0026 nextEnderMatch.index !== undefined) {\n    end = index + nextEnderMatch.index + 1;\n  }\n  const nextNewline = afterText.indexOf('\\n\\n');\n  if (nextNewline !== -1 \u0026\u0026 index + nextNewline \u003c end) {\n    end = index + nextNewline;\n  }\n\n  return text.slice(start, end).trim();\n}","weight":3}},{"data":{"id":"structure:5316","label":"isValidExtraction","type":"function","file":"src/extractor/index.ts","line":154,"signature":"function isValidExtraction(sentence: string)","content":"function isValidExtraction(sentence: string): boolean {\n  // Too short or too long\n  if (sentence.length \u003c 30 || sentence.length \u003e 500) {\n    return false;\n  }\n\n  // Looks like code (too many special characters)\n  const codeIndicators = sentence.match(/[{}()\\[\\];=\u003c\u003e]/g);\n  if (codeIndicators \u0026\u0026 codeIndicators.length \u003e 5) {\n    return false;\n  }\n\n  // Is a code block\n  if (sentence.includes('```') || sentence.startsWith('  ') || sentence.startsWith('\\t')) {\n    return false;\n  }\n\n  // Is just a list item number or bullet\n  if (/^[\\d\\-*‚Ä¢]\\s/.test(sentence) \u0026\u0026 sentence.length \u003c 50) {\n    return false;\n  }\n\n  return true;\n}","weight":3}},{"data":{"id":"structure:5318","label":"extractEntities","type":"function","file":"src/extractor/index.ts","line":193,"signature":"function extractEntities(text: string, ...patterns: RegExp[])","content":"function extractEntities(text: string, ...patterns: RegExp[]): string[] {\n  const entities = new Set\u003cstring\u003e();\n\n  for (const pattern of patterns) {\n    const p = new RegExp(pattern.source, pattern.flags);\n    let match;\n    while ((match = p.exec(text)) !== null) {\n      const entity = match[1];\n      // Filter out common false positives\n      if (entity \u0026\u0026 entity.length \u003e 2 \u0026\u0026 !isCommonWord(entity)) {\n        entities.add(entity);\n      }\n    }\n  }\n\n  return [...entities];\n}","weight":3}},{"data":{"id":"structure:5317","label":"cleanSentence","type":"function","file":"src/extractor/index.ts","line":182,"signature":"function cleanSentence(sentence: string)","content":"function cleanSentence(sentence: string): string {\n  return sentence\n    .replace(/\\s+/g, ' ')  // Normalize whitespace\n    .replace(/^[-*‚Ä¢]\\s*/, '')  // Remove list markers\n    .replace(/^\\d+\\.\\s*/, '')  // Remove numbered list markers\n    .trim();\n}","weight":2}},{"data":{"id":"structure:5320","label":"deduplicateExtractions","type":"function","file":"src/extractor/index.ts","line":233,"signature":"function deduplicateExtractions(extractions: ExtractedItem[])","content":"function deduplicateExtractions(extractions: ExtractedItem[]): ExtractedItem[] {\n  const seen = new Set\u003cstring\u003e();\n  const result: ExtractedItem[] = [];\n\n  for (const ext of extractions) {\n    // Create a normalized key for comparison\n    const key = ext.content\n      .toLowerCase()\n      .replace(/\\s+/g, ' ')\n      .slice(0, 80);\n\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(ext);\n    }\n  }\n\n  return result;\n}","weight":2}},{"data":{"id":"structure:5319","label":"isCommonWord","type":"function","file":"src/extractor/index.ts","line":214,"signature":"function isCommonWord(word: string)","content":"function isCommonWord(word: string): boolean {\n  const commonWords = new Set([\n    'the', 'this', 'that', 'these', 'those', 'then', 'than',\n    'will', 'would', 'should', 'could', 'can', 'may', 'might',\n    'have', 'has', 'had', 'get', 'set', 'let', 'var', 'const',\n    'function', 'class', 'def', 'return', 'true', 'false', 'null',\n    'undefined', 'new', 'for', 'while', 'if', 'else', 'try', 'catch',\n    'import', 'export', 'from', 'require', 'module', 'use', 'using',\n    'not', 'and', 'but', 'with', 'was', 'were', 'are', 'been',\n    'being', 'does', 'done', 'doing', 'did', 'make', 'made', 'making',\n    'String', 'Number', 'Boolean', 'Array', 'Object', 'Date', 'Error',\n    'Promise', 'Map', 'Set', 'JSON', 'Math', 'console', 'process',\n  ]);\n  return commonWords.has(word) || commonWords.has(word.toLowerCase());\n}","weight":4}},{"data":{"id":"structure:5321","label":"generateSummary","type":"function","file":"src/extractor/index.ts","line":256,"signature":"function generateSummary(messages: TranscriptMessage[])","content":"export function generateSummary(messages: TranscriptMessage[]): string {\n  const userMessages = messages\n    .filter(m =\u003e m.role === 'user')\n    .map(m =\u003e getMessageContent(m))\n    .filter(c =\u003e c.length \u003e 0);\n\n  if (userMessages.length === 0) {\n    return 'Empty conversation';\n  }\n\n  // Use first user message as base for summary\n  const firstMessage = userMessages[0].slice(0, 200);\n  const topicHint = userMessages.length \u003e 1\n    ? ` (${userMessages.length} exchanges)`\n    : '';\n\n  return `${firstMessage}${topicHint}`;\n}","weight":3}},{"data":{"id":"structure:5326","label":"getDb","type":"function","file":"src/db/index.ts","line":23,"signature":"function getDb()","content":"export function getDb(): Database.Database {\n  if (!db) {\n    ensureDataDir();\n    db = new Database(DB_PATH);\n    db.pragma('journal_mode = WAL');\n    db.pragma('foreign_keys = ON');\n    db.exec(SCHEMA);\n  }\n  return db;\n}","weight":68}},{"data":{"id":"structure:5325","label":"ensureDataDir","type":"function","file":"src/db/index.ts","line":17,"signature":"function ensureDataDir()","content":"export function ensureDataDir(): void {\n  if (!existsSync(DATA_DIR)) {\n    mkdirSync(DATA_DIR, { recursive: true });\n  }\n}","weight":8}},{"data":{"id":"structure:5328","label":"createProject","type":"function","file":"src/db/index.ts","line":42,"signature":"function createProject(path: string, name: string)","content":"export function createProject(path: string, name: string): Project {\n  const db = getDb();\n  const stmt = db.prepare('INSERT INTO projects (path, name) VALUES (?, ?) RETURNING *');\n  return stmt.get(path, name) as Project;\n}","weight":3}},{"data":{"id":"structure:5329","label":"getProject","type":"function","file":"src/db/index.ts","line":48,"signature":"function getProject(id: number)","content":"export function getProject(id: number): Project | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM projects WHERE id = ?').get(id) as Project | undefined;\n}","weight":1}},{"data":{"id":"structure:5330","label":"getProjectByPath","type":"function","file":"src/db/index.ts","line":53,"signature":"function getProjectByPath(path: string)","content":"export function getProjectByPath(path: string): Project | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM projects WHERE path = ?').get(path) as Project | undefined;\n}","weight":7}},{"data":{"id":"structure:5331","label":"getAllProjects","type":"function","file":"src/db/index.ts","line":58,"signature":"function getAllProjects()","content":"export function getAllProjects(): Project[] {\n  const db = getDb();\n  return db.prepare('SELECT * FROM projects ORDER BY created_at DESC').all() as Project[];\n}","weight":5}},{"data":{"id":"structure:5334","label":"getFileByPath","type":"function","file":"src/db/index.ts","line":82,"signature":"function getFileByPath(projectId: number, path: string)","content":"export function getFileByPath(projectId: number, path: string): File | undefined {\n  const db = getDb();\n  return db.prepare('SELECT * FROM files WHERE project_id = ? AND path = ?').get(projectId, path) as File | undefined;\n}","weight":1}},{"data":{"id":"structure:5335","label":"deleteFile","type":"function","file":"src/db/index.ts","line":87,"signature":"function deleteFile(id: number)","content":"export function deleteFile(id: number): void {\n  const db = getDb();\n  db.prepare('DELETE FROM files WHERE id = ?').run(id);\n}","weight":2}},{"data":{"id":"structure:5336","label":"getProjectFiles","type":"function","file":"src/db/index.ts","line":92,"signature":"function getProjectFiles(projectId: number)","content":"export function getProjectFiles(projectId: number): File[] {\n  const db = getDb();\n  return db.prepare('SELECT * FROM files WHERE project_id = ?').all(projectId) as File[];\n}","weight":3}},{"data":{"id":"structure:5342","label":"insertConversation","type":"function","file":"src/db/index.ts","line":169,"signature":"function insertConversation(\n  rawContent: string,\n  projectId: number | null = null,\n  model: string | null = null,\n  tool: string | null = null,\n  summary: string | null = null\n)","content":"export function insertConversation(\n  rawContent: string,\n  projectId: number | null = null,\n  model: string | null = null,\n  tool: string | null = null,\n  summary: string | null = null\n): Conversation {\n  const db = getDb();\n  const stmt = db.prepare(`\n    INSERT INTO conversations (project_id, model, tool, summary, raw_content)\n    VALUES (?, ?, ?, ?, ?)\n    RETURNING *\n  `);\n  return stmt.get(projectId, model, tool, summary, rawContent) as Conversation;\n}","weight":1}},{"data":{"id":"structure:5344","label":"createLink","type":"function","file":"src/db/index.ts","line":206,"signature":"function createLink(\n  sourceType: Link['source_type'],\n  sourceId: number,\n  targetType: Link['target_type'],\n  targetId: number,\n  linkType: Link['link_type']\n)","content":"export function createLink(\n  sourceType: Link['source_type'],\n  sourceId: number,\n  targetType: Link['target_type'],\n  targetId: number,\n  linkType: Link['link_type']\n): Link {\n  const db = getDb();\n  const stmt = db.prepare(`\n    INSERT OR IGNORE INTO links (source_type, source_id, target_type, target_id, link_type)\n    VALUES (?, ?, ?, ?, ?)\n    RETURNING *\n  `);\n  return stmt.get(sourceType, sourceId, targetType, targetId, linkType) as Link;\n}","weight":1}},{"data":{"id":"structure:5345","label":"getLinksFrom","type":"function","file":"src/db/index.ts","line":222,"signature":"function getLinksFrom(sourceType: Link['source_type'], sourceId: number)","content":"export function getLinksFrom(sourceType: Link['source_type'], sourceId: number): Link[] {\n  const db = getDb();\n  return db.prepare('SELECT * FROM links WHERE source_type = ? AND source_id = ?').all(sourceType, sourceId) as Link[];\n}","weight":1}},{"data":{"id":"structure:5351","label":"isDuplicateExtraction","type":"function","file":"src/db/index.ts","line":280,"signature":"function isDuplicateExtraction(\n  content: string,\n  projectId: number | null,\n  windowSeconds: number = 300\n)","content":"export function isDuplicateExtraction(\n  content: string,\n  projectId: number | null,\n  windowSeconds: number = 300\n): boolean {\n  const db = getDb();\n  // Check for duplicate extraction content within the last N seconds\n  const stmt = db.prepare(`\n    SELECT COUNT(*) as count FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE e.content = ?\n    AND (c.project_id = ? OR (c.project_id IS NULL AND ? IS NULL))\n    AND datetime(c.timestamp) \u003e datetime('now', '-' || ? || ' seconds')\n  `);\n  const result = stmt.get(content.trim(), projectId, projectId, windowSeconds) as { count: number };\n  return result.count \u003e 0;\n}","weight":1}},{"data":{"id":"structure:5352","label":"getStats","type":"function","file":"src/db/index.ts","line":299,"signature":"function getStats()","content":"export function getStats(): IndexStats {\n  const db = getDb();\n  const projects = (db.prepare('SELECT COUNT(*) as count FROM projects').get() as { count: number }).count;\n  const files = (db.prepare('SELECT COUNT(*) as count FROM files').get() as { count: number }).count;\n  const structures = (db.prepare('SELECT COUNT(*) as count FROM structures').get() as { count: number }).count;\n  const conversations = (db.prepare('SELECT COUNT(*) as count FROM conversations').get() as { count: number }).count;\n  const links = (db.prepare('SELECT COUNT(*) as count FROM links').get() as { count: number }).count;\n  return { projects, files, structures, conversations, links };\n}","weight":3}},{"data":{"id":"structure:5356","label":"getFullConversations","type":"function","file":"src/db/index.ts","line":329,"signature":"function getFullConversations(projectId: number, limit = 50, offset = 0)","content":"export function getFullConversations(projectId: number, limit = 50, offset = 0): Conversation[] {\n  const db = getDb();\n  return db.prepare(`\n    SELECT * FROM conversations\n    WHERE project_id = ?\n    ORDER BY timestamp DESC\n    LIMIT ? OFFSET ?\n  `).all(projectId, limit, offset) as Conversation[];\n}","weight":1}},{"data":{"id":"structure:5358","label":"getAllProjectStructures","type":"function","file":"src/db/index.ts","line":366,"signature":"function getAllProjectStructures(projectId: number)","content":"export function getAllProjectStructures(projectId: number): StructureWithFile[] {\n  const db = getDb();\n  return db.prepare(`\n    SELECT s.*, f.path as file_path\n    FROM structures s\n    JOIN files f ON s.file_id = f.id\n    WHERE f.project_id = ?\n    ORDER BY f.path, s.line_start\n  `).all(projectId) as StructureWithFile[];\n}","weight":2}},{"data":{"id":"structure:5359","label":"getAllProjectLinks","type":"function","file":"src/db/index.ts","line":378,"signature":"function getAllProjectLinks(projectId: number)","content":"export function getAllProjectLinks(projectId: number): Link[] {\n  const db = getDb();\n  return db.prepare(`\n    SELECT DISTINCT l.* FROM links l\n    LEFT JOIN structures s ON l.source_type = 'structure' AND l.source_id = s.id\n    LEFT JOIN files f ON s.file_id = f.id\n    LEFT JOIN conversations c ON l.source_type = 'conversation' AND l.source_id = c.id\n    WHERE f.project_id = ? OR c.project_id = ?\n  `).all(projectId, projectId) as Link[];\n}","weight":2}},{"data":{"id":"structure:5360","label":"getAllProjectExtractions","type":"function","file":"src/db/index.ts","line":390,"signature":"function getAllProjectExtractions(projectId: number)","content":"export function getAllProjectExtractions(projectId: number): Extraction[] {\n  const db = getDb();\n  return db.prepare(`\n    SELECT e.* FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE c.project_id = ?\n    ORDER BY c.timestamp DESC\n  `).all(projectId) as Extraction[];\n}","weight":2}},{"data":{"id":"structure:5362","label":"getEntityContext","type":"function","file":"dist-test/src/query/index.js","line":5,"signature":"function getEntityContext(entityName)","content":"export function getEntityContext(entityName) {\n    const structures = getStructuresByName(entityName);\n    const result = {\n        structures: [],\n        decisions: [],\n        rejections: [],\n        patterns: [],\n        relatedConversations: [],\n    };\n    for (const structure of structures) {\n        const file = getFile(structure.file_id);\n        result.structures.push({\n            type: structure.type,\n            name: structure.name,\n            file: file?.path || 'unknown',\n            line: structure.line_start,\n            signature: structure.signature,\n            content: structure.raw_content,\n        });\n        // Get linked conversations and extractions\n        const links = getLinksTo('structure', structure.id);\n        for (const link of links) {\n            if (link.source_type === 'conversation') {\n                const extractions = getConversationExtractions(link.source_id);\n                for (const extraction of extractions) {\n                    switch (extraction.type) {\n                        case 'decision':\n                            result.decisions.push(extraction);\n                            break;\n                        case 'rejection':\n                            result.rejections.push(extraction);\n                            break;\n                        case 'pattern':\n                            result.patterns.push(extraction);\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}","weight":4}},{"data":{"id":"structure:5363","label":"searchContext","type":"function","file":"dist-test/src/query/index.js","line":50,"signature":"function searchContext(query, limit = 10)","content":"export function searchContext(query, limit = 10) {\n    const result = {\n        structures: [],\n        decisions: [],\n        rejections: [],\n        patterns: [],\n        relatedConversations: [],\n    };\n    // Search structures\n    const structures = searchStructures(query, limit);\n    for (const s of structures) {\n        const file = getFile(s.file_id);\n        result.structures.push({\n            type: s.type,\n            name: s.name,\n            file: file?.path || 'unknown',\n            line: s.line_start,\n            signature: s.signature,\n            content: s.raw_content,\n        });\n    }\n    // Search conversations\n    const conversations = searchConversations(query, limit);\n    for (const c of conversations) {\n        result.relatedConversations.push({\n            id: c.id,\n            timestamp: c.timestamp,\n            summary: c.summary,\n        });\n        // Get extractions from these conversations\n        const extractions = getConversationExtractions(c.id);\n        for (const e of extractions) {\n            switch (e.type) {\n                case 'decision':\n                    result.decisions.push(e);\n                    break;\n                case 'rejection':\n                    result.rejections.push(e);\n                    break;\n                case 'pattern':\n                    result.patterns.push(e);\n                    break;\n            }\n        }\n    }\n    return result;\n}","weight":4}},{"data":{"id":"structure:5365","label":"startMcpServer","type":"function","file":"dist-test/src/mcp/server.js","line":5,"signature":"function startMcpServer()","content":"export async function startMcpServer() {\n    const server = new Server({\n        name: 'aimem',\n        version: '0.1.0',\n    }, {\n        capabilities: {\n            tools: {},\n        },\n    });\n    // List available tools\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003e ({\n        tools: [\n            {\n                name: 'aimem_query',\n                description: 'Search for code structures (functions, classes, etc.) and past conversations. Use this to find relevant context about the codebase.',\n                inputSchema: {\n                    type: 'object',\n                    properties: {\n                        query: {\n                            type: 'string',\n                            description: 'Search query - can be a function name, class name, or keyword',\n                        },\n                        type: {\n                            type: 'string',\n                            enum: ['all', 'structures', 'conversations'],\n                            description: 'What to search: all, structures, or conversations',\n                            default: 'all',\n                        },\n                        limit: {\n                            type: 'number',\n                            description: 'Maximum number of results',\n                            default: 10,\n                        },\n                    },\n                    required: ['query'],\n                },\n            },\n            {\n                name: 'aimem_context',\n                description: 'Get relevant context for a specific code entity (function, class, file). Returns the structure details plus any related decisions and conversations.',\n                inputSchema: {\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            description: 'Name of the function, class, or entity to get context for',\n                        },\n                    },\n                    required: ['name'],\n                },\n            },\n            {\n                name: 'aimem_decisions',\n                description: 'Get all decisions made about a specific code entity. Useful for understanding why something was built a certain way.',\n                inputSchema: {\n                    type: 'object',\n                    properties: {\n                        entity: {\n                            type: 'string',\n                            description: 'Name of the entity to get decisions for',\n                        },\n                    },\n                    required: ['entity'],\n                },\n            },\n            {\n                name: 'aimem_verify',\n                description: 'Verify that a code entity (function, class, file) exists in the codebase. Use this to check claims before making them.',\n                inputSchema: {\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            description: 'Name of the function or class to verify',\n                        },\n                        type: {\n                            type: 'string',\n                            enum: ['structure', 'file'],\n                            description: 'Type of entity to verify',\n                            default: 'structure',\n                        },\n                    },\n                    required: ['name'],\n                },\n            },\n            {\n                name: 'aimem_conversations',\n                description: 'Search and retrieve full conversation history from past Claude/AI sessions. Use this for long-term memory - finding past discussions, decisions, and context about the project.',\n                inputSchema: {\n                    type: 'object',\n                    properties: {\n                        query: {\n                            type: 'string',\n                            description: 'Search query to find relevant conversations (keywords, topics, or questions)',\n                        },\n                        id: {\n                            type: 'number',\n                            description: 'Get a specific conversation by ID',\n                        },\n                        limit: {\n                            type: 'number',\n                            description: 'Maximum number of conversations to return',\n                            default: 5,\n                        },\n                    },\n                },\n            },\n        ],\n    }));\n    // Handle tool calls\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003e {\n        const { name, arguments: args } = request.params;\n        try {\n            switch (name) {\n                case 'aimem_query': {\n                    const query = args?.query;\n                    const type = args?.type || 'all';\n                    const limit = args?.limit || 10;\n                    const results = {};\n                    if (type === 'all' || type === 'structures') {\n                        const structures = searchStructures(query, limit);\n                        results.structures = structures.map(s =\u003e ({\n                            type: s.type,\n                            name: s.name,\n                            file: getFile(s.file_id)?.path,\n                            line: s.line_start,\n                            signature: s.signature,\n                        }));\n                    }\n                    if (type === 'all' || type === 'conversations') {\n                        const conversations = searchConversations(query, limit);\n                        results.conversations = conversations.map(c =\u003e ({\n                            id: c.id,\n                            timestamp: c.timestamp,\n                            model: c.model,\n                            summary: c.summary || c.raw_content.slice(0, 200),\n                        }));\n                    }\n                    return {\n                        content: [{ type: 'text', text: JSON.stringify(results, null, 2) }],\n                    };\n                }\n                case 'aimem_context': {\n                    const entityName = args?.name;\n                    const structures = getStructuresByName(entityName);\n                    if (structures.length === 0) {\n                        return {\n                            content: [{ type: 'text', text: `No entity found with name: ${entityName}` }],\n                        };\n                    }\n                    const context = structures.map(s =\u003e {\n                        const file = getFile(s.file_id);\n                        const links = getLinksTo('structure', s.id);\n                        return {\n                            type: s.type,\n                            name: s.name,\n                            file: file?.path,\n                            line: s.line_start,\n                            signature: s.signature,\n                            content: s.raw_content,\n                            relatedConversations: links.filter(l =\u003e l.source_type === 'conversation').length,\n                            decisions: links.filter(l =\u003e l.link_type === 'decision').length,\n                        };\n                    });\n                    return {\n                        content: [{ type: 'text', text: JSON.stringify(context, null, 2) }],\n                    };\n                }\n                case 'aimem_decisions': {\n                    const entity = args?.entity;\n                    const structures = getStructuresByName(entity);\n                    const decisions = [];\n                    if (structures.length \u003e 0) {\n                        // Found matching code structures - get linked decisions\n                        for (const s of structures) {\n                            const links = getLinksTo('structure', s.id);\n                            for (const link of links) {\n                                if (link.source_type === 'extraction') {\n                                    const extraction = getExtraction(link.source_id);\n                                    if (extraction) {\n                                        decisions.push({\n                                            type: extraction.type,\n                                            content: extraction.content,\n                                            link_type: link.link_type,\n                                            source: 'linked',\n                                        });\n                                    }\n                                }\n                                else if (link.source_type === 'conversation') {\n                                    const extractions = getConversationExtractions(link.source_id);\n                                    decisions.push(...extractions\n                                        .filter(e =\u003e e.type === 'decision' || e.type === 'rejection')\n                                        .map(e =\u003e ({ ...e, source: 'linked' })));\n                                }\n                            }\n                        }\n                    }\n                    // Fallback: keyword search in decision content\n                    if (decisions.length === 0) {\n                        const keywordResults = searchExtractions(entity, 10);\n                        for (const ext of keywordResults) {\n                            decisions.push({\n                                type: ext.type,\n                                content: ext.content,\n                                source: 'keyword_search',\n                            });\n                        }\n                    }\n                    if (decisions.length === 0) {\n                        return {\n                            content: [{ type: 'text', text: `No decisions found for: ${entity}` }],\n                        };\n                    }\n                    return {\n                        content: [{ type: 'text', text: JSON.stringify(decisions, null, 2) }],\n                    };\n                }\n                case 'aimem_verify': {\n                    const entityName = args?.name;\n                    const entityType = args?.type || 'structure';\n                    let exists = false;\n                    if (entityType === 'structure') {\n                        exists = structureExists(entityName);\n                    }\n                    else if (entityType === 'file') {\n                        exists = fileExists(entityName);\n                    }\n                    return {\n                        content: [{\n                                type: 'text',\n                                text: JSON.stringify({\n                                    name: entityName,\n                                    type: entityType,\n                                    exists,\n                                    message: exists\n                                        ? `${entityType} \"${entityName}\" exists in the codebase`\n                                        : `${entityType} \"${entityName}\" was NOT found in the codebase`,\n                                }, null, 2),\n                            }],\n                    };\n                }\n                case 'aimem_conversations': {\n                    const query = args?.query;\n                    const id = args?.id;\n                    const limit = args?.limit || 5;\n                    // Get specific conversation by ID\n                    if (id !== undefined) {\n                        const conversation = getConversationById(id);\n                        if (!conversation) {\n                            return {\n                                content: [{ type: 'text', text: `No conversation found with ID: ${id}` }],\n                            };\n                        }\n                        return {\n                            content: [{\n                                    type: 'text',\n                                    text: JSON.stringify({\n                                        id: conversation.id,\n                                        timestamp: conversation.timestamp,\n                                        model: conversation.model,\n                                        tool: conversation.tool,\n                                        summary: conversation.summary,\n                                        content: conversation.raw_content,\n                                    }, null, 2),\n                                }],\n                        };\n                    }\n                    // Search conversations\n                    if (!query) {\n                        return {\n                            content: [{ type: 'text', text: 'Please provide a query to search conversations, or an id to get a specific conversation' }],\n                        };\n                    }\n                    // Try to scope to current project\n                    const cwd = process.cwd();\n                    const project = findProjectForPath(cwd);\n                    const projectId = project?.id;\n                    const conversations = searchFullConversations(query, limit, projectId);\n                    if (conversations.length === 0) {\n                        return {\n                            content: [{ type: 'text', text: `No conversations found matching: ${query}` }],\n                        };\n                    }\n                    const results = conversations.map(c =\u003e ({\n                        id: c.id,\n                        timestamp: c.timestamp,\n                        model: c.model,\n                        tool: c.tool,\n                        summary: c.summary,\n                        content: c.raw_content.length \u003e 2000\n                            ? c.raw_content.slice(0, 2000) + '... [truncated - use id to get full content]'\n                            : c.raw_content,\n                    }));\n                    return {\n                        content: [{\n                                type: 'text',\n                                text: JSON.stringify({\n                                    query,\n                                    count: results.length,\n                                    conversations: results,\n                                }, null, 2),\n                            }],\n                    };\n                }\n                default:\n                    return {\n                        content: [{ type: 'text', text: `Unknown tool: ${name}` }],\n                        isError: true,\n                    };\n            }\n        }\n        catch (error) {\n            return {\n                content: [{ type: 'text', text: `Error: ${error.message}` }],\n                isError: true,\n            };\n        }\n    });\n    // Start server\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n}","weight":13}},{"data":{"id":"structure:5373","label":"indexFile","type":"function","file":"dist-test/src/indexer/index.js","line":58,"signature":"function indexFile(projectId, projectPath, relativePath)","content":"export async function indexFile(projectId, projectPath, relativePath) {\n    const fullPath = join(projectPath, relativePath);\n    const parser = getParser(fullPath);\n    if (!parser) {\n        return 0;\n    }\n    try {\n        const content = readFileSync(fullPath, 'utf-8');\n        const hash = getFileHash(content);\n        // Upsert file record\n        const file = upsertFile(projectId, relativePath, hash);\n        // Clear existing structures for this file\n        deleteFileStructures(file.id);\n        // Parse and store structures\n        const structures = parser.parse(content, relativePath);\n        for (const s of structures) {\n            insertStructure(file.id, s.type, s.name, s.lineStart, s.lineEnd, s.signature, s.rawContent, s.metadata);\n        }\n        return structures.length;\n    }\n    catch (err) {\n        // File might have been deleted or unreadable\n        console.error(`Error indexing ${relativePath}:`, err);\n        return 0;\n    }\n}","weight":5}},{"data":{"id":"structure:5374","label":"indexProject","type":"function","file":"dist-test/src/indexer/index.js","line":84,"signature":"function indexProject(projectId, projectPath)","content":"export async function indexProject(projectId, projectPath) {\n    const filePaths = await getProjectFilePaths(projectPath);\n    let totalStructures = 0;\n    let indexedFiles = 0;\n    for (const relativePath of filePaths) {\n        const count = await indexFile(projectId, projectPath, relativePath);\n        if (count \u003e 0) {\n            indexedFiles++;\n            totalStructures += count;\n        }\n    }\n    // Clean up files that no longer exist\n    const existingFiles = getProjectFiles(projectId);\n    const currentPaths = new Set(filePaths);\n    for (const file of existingFiles) {\n        if (!currentPaths.has(file.path)) {\n            deleteFile(file.id);\n        }\n    }\n    console.log(`  Indexed ${indexedFiles} files, ${totalStructures} structures`);\n    return { files: indexedFiles, structures: totalStructures };\n}","weight":4}},{"data":{"id":"structure:5308","label":"getProjectFilePaths","type":"function","file":"src/indexer/index.ts","line":60,"signature":"function getProjectFilePaths(projectPath: string)","content":"async function getProjectFilePaths(projectPath: string): Promise\u003cstring[]\u003e {\n  const extensions = Array.from(extensionMap.keys()).map(ext =\u003e ext.slice(1)); // Remove leading dot\n  const pattern = `**/*.{${extensions.join(',')}}`;\n\n  const files = await glob(pattern, {\n    cwd: projectPath,\n    ignore: IGNORE_PATTERNS,\n    nodir: true,\n    absolute: false,\n  });\n\n  return files;\n}","weight":1}},{"data":{"id":"structure:5376","label":"extractDecisions","type":"function","file":"dist-test/src/extractor/index.js","line":6,"signature":"function extractDecisions(messages)","content":"export function extractDecisions(messages) {\n    const extractions = [];\n    // Decision patterns - phrases that indicate a choice was made\n    const decisionPatterns = [\n        /(?:we should|let's|I'll|I will|going to|decided to|will use|using|chose|choosing|the best approach is|recommend using)\\s+(.+?)(?:\\.|$)/gi,\n        /(?:the approach|the solution|the fix|the implementation|the strategy)\\s+(?:is|will be|should be)\\s+(.+?)(?:\\.|$)/gi,\n        /(?:because|since|the reason is|this is because)\\s+(.+?)(?:\\.|$)/gi,\n        /(?:I've implemented|I've added|I've created|I've updated)\\s+(.+?)(?:\\.|$)/gi,\n    ];\n    // Rejection patterns - phrases that indicate something was ruled out\n    const rejectionPatterns = [\n        /(?:instead of|rather than|not using|won't use|shouldn't use|avoid using|don't use)\\s+(.+?)(?:\\.|$)/gi,\n        /(?:rejected|ruled out|decided against|not recommended|wouldn't work)\\s+(.+?)(?:\\.|$)/gi,\n        /(?:the problem with|the issue with|doesn't work because)\\s+(.+?)(?:\\.|$)/gi,\n    ];\n    // Entity patterns for linking to code structures\n    const classPattern = /\\b([A-Z][a-zA-Z0-9]*(?:Service|Controller|Model|Helper|Manager|Handler|Factory|Builder|Provider|Middleware|Client|Server|Worker|Job|Task|Command|Query|Event|Listener|Observer|Strategy|Adapter|Decorator|Proxy|Repository|Gateway|Validator|Serializer|Parser|Formatter|Renderer|Component|Module|Plugin|Extension)?)\\b/g;\n    const functionPattern = /\\b([a-z_][a-z0-9_]*)\\s*\\(/g;\n    const methodPattern = /(?:def|function|const|let|var)\\s+([a-z_][a-z0-9_]*)/g;\n    const filePattern = /(?:in|from|file|at)\\s+[`\"']?([a-zA-Z0-9_/.-]+\\.[a-z]+)[`\"']?/gi;\n    for (const msg of messages) {\n        if (msg.role !== 'assistant')\n            continue;\n        const content = getMessageContent(msg);\n        if (!content)\n            continue;\n        // Extract decisions\n        for (const pattern of decisionPatterns) {\n            pattern.lastIndex = 0; // Reset regex state\n            let match;\n            while ((match = pattern.exec(content)) !== null) {\n                const sentence = getSentenceAround(content, match.index);\n                if (isValidExtraction(sentence)) {\n                    const entities = extractEntities(sentence, classPattern, functionPattern, methodPattern);\n                    extractions.push({\n                        type: 'decision',\n                        content: cleanSentence(sentence),\n                        mentionedEntities: entities,\n                        metadata: {\n                            patternType: 'decision',\n                            originalMatch: match[0].slice(0, 100)\n                        }\n                    });\n                }\n            }\n        }\n        // Extract rejections\n        for (const pattern of rejectionPatterns) {\n            pattern.lastIndex = 0;\n            let match;\n            while ((match = pattern.exec(content)) !== null) {\n                const sentence = getSentenceAround(content, match.index);\n                if (isValidExtraction(sentence)) {\n                    const entities = extractEntities(sentence, classPattern, functionPattern, methodPattern);\n                    extractions.push({\n                        type: 'rejection',\n                        content: cleanSentence(sentence),\n                        mentionedEntities: entities,\n                        metadata: {\n                            patternType: 'rejection',\n                            originalMatch: match[0].slice(0, 100)\n                        }\n                    });\n                }\n            }\n        }\n    }\n    // Deduplicate and return\n    return deduplicateExtractions(extractions);\n}\n/**\n * Get text content from a message, handling different content formats\n */\nfunction getMessageContent(msg) {\n    if (typeof msg.content === 'string') {\n        return msg.content;\n    }\n    if (Array.isArray(msg.content)) {\n        return msg.content\n            .map(c =\u003e c.text)\n            .filter(Boolean)\n            .join('\\n');\n    }\n    return '';\n}\n/**\n * Get the sentence containing the match index\n */\nfunction getSentenceAround(text, index) {\n    // Find sentence boundaries (., !, ?, or newlines)\n    const sentenceEnders = /[.!?]\\s|\\n\\n/g;\n    let start = 0;\n    let end = text.length;\n    // Find start of sentence\n    const beforeText = text.slice(0, index);\n    const lastEnder = beforeText.search(/[.!?]\\s[^.!?]*$/);\n    if (lastEnder !== -1) {\n        start = lastEnder + 2;\n    }\n    const lastNewline = beforeText.lastIndexOf('\\n\\n');\n    if (lastNewline \u003e start) {\n        start = lastNewline + 2;\n    }\n    // Find end of sentence\n    const afterText = text.slice(index);\n    const nextEnderMatch = afterText.match(/[.!?](?:\\s|$)/);\n    if (nextEnderMatch \u0026\u0026 nextEnderMatch.index !== undefined) {\n        end = index + nextEnderMatch.index + 1;\n    }\n    const nextNewline = afterText.indexOf('\\n\\n');\n    if (nextNewline !== -1 \u0026\u0026 index + nextNewline \u003c end) {\n        end = index + nextNewline;\n    }\n    return text.slice(start, end).trim();\n}\n/**\n * Check if extraction is valid (not too short, not too long, not code)\n */\nfunction isValidExtraction(sentence) {\n    // Too short or too long\n    if (sentence.length \u003c 30 || sentence.length \u003e 500) {\n        return false;\n    }\n    // Looks like code (too many special characters)\n    const codeIndicators = sentence.match(/[{}()\\[\\];=\u003c\u003e]/g);\n    if (codeIndicators \u0026\u0026 codeIndicators.length \u003e 5) {\n        return false;\n    }\n    // Is a code block\n    if (sentence.includes('```') || sentence.startsWith('  ') || sentence.startsWith('\\t')) {\n        return false;\n    }\n    // Is just a list item number or bullet\n    if (/^[\\d\\-*‚Ä¢]\\s/.test(sentence) \u0026\u0026 sentence.length \u003c 50) {\n        return false;\n    }\n    return true;\n}\n/**\n * Clean up a sentence for storage\n */\nfunction cleanSentence(sentence) {\n    return sentence\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .replace(/^[-*‚Ä¢]\\s*/, '') // Remove list markers\n        .replace(/^\\d+\\.\\s*/, '') // Remove numbered list markers\n        .trim();\n}\n/**\n * Extract entity names from text using patterns\n */\nfunction extractEntities(text, ...patterns) {\n    const entities = new Set();\n    for (const pattern of patterns) {\n        const p = new RegExp(pattern.source, pattern.flags);\n        let match;\n        while ((match = p.exec(text)) !== null) {\n            const entity = match[1];\n            // Filter out common false positives\n            if (entity \u0026\u0026 entity.length \u003e 2 \u0026\u0026 !isCommonWord(entity)) {\n                entities.add(entity);\n            }\n        }\n    }\n    return [...entities];\n}\n/**\n * Check if a word is too common to be a meaningful entity\n */\nfunction isCommonWord(word) {\n    const commonWords = new Set([\n        'the', 'this', 'that', 'these', 'those', 'then', 'than',\n        'will', 'would', 'should', 'could', 'can', 'may', 'might',\n        'have', 'has', 'had', 'get', 'set', 'let', 'var', 'const',\n        'function', 'class', 'def', 'return', 'true', 'false', 'null',\n        'undefined', 'new', 'for', 'while', 'if', 'else', 'try', 'catch',\n        'import', 'export', 'from', 'require', 'module', 'use', 'using',\n        'not', 'and', 'but', 'with', 'was', 'were', 'are', 'been',\n        'being', 'does', 'done', 'doing', 'did', 'make', 'made', 'making',\n        'String', 'Number', 'Boolean', 'Array', 'Object', 'Date', 'Error',\n        'Promise', 'Map', 'Set', 'JSON', 'Math', 'console', 'process',\n    ]);\n    return commonWords.has(word) || commonWords.has(word.toLowerCase());\n}\n/**\n * Remove duplicate or very similar extractions\n */\nfunction deduplicateExtractions(extractions) {\n    const seen = new Set();\n    const result = [];\n    for (const ext of extractions) {\n        // Create a normalized key for comparison\n        const key = ext.content\n            .toLowerCase()\n            .replace(/\\s+/g, ' ')\n            .slice(0, 80);\n        if (!seen.has(key)) {\n            seen.add(key);\n            result.push(ext);\n        }\n    }\n    return result;\n}\n/**\n * Generate a summary of the conversation for storage\n */\nexport function generateSummary(messages) {\n    const userMessages = messages\n        .filter(m =\u003e m.role === 'user')\n        .map(m =\u003e getMessageContent(m))\n        .filter(c =\u003e c.length \u003e 0);\n    if (userMessages.length === 0) {\n        return 'Empty conversation';\n    }\n    // Use first user message as base for summary\n    const firstMessage = userMessages[0].slice(0, 200);\n    const topicHint = userMessages.length \u003e 1\n        ? ` (${userMessages.length} exchanges)`\n        : '';\n    return `${firstMessage}${topicHint}`;\n}\n//# sourceMappingURL=index.js.map","weight":8}},{"data":{"id":"structure:5381","label":"extractEntities","type":"function","file":"dist-test/src/extractor/index.js","line":157,"signature":"function extractEntities(text, ...patterns)","content":"function extractEntities(text, ...patterns) {\n    const entities = new Set();\n    for (const pattern of patterns) {\n        const p = new RegExp(pattern.source, pattern.flags);\n        let match;\n        while ((match = p.exec(text)) !== null) {\n            const entity = match[1];\n            // Filter out common false positives\n            if (entity \u0026\u0026 entity.length \u003e 2 \u0026\u0026 !isCommonWord(entity)) {\n                entities.add(entity);\n            }\n        }\n    }\n    return [...entities];\n}","weight":1}},{"data":{"id":"structure:5384","label":"generateSummary","type":"function","file":"dist-test/src/extractor/index.js","line":212,"signature":"function generateSummary(messages)","content":"export function generateSummary(messages) {\n    const userMessages = messages\n        .filter(m =\u003e m.role === 'user')\n        .map(m =\u003e getMessageContent(m))\n        .filter(c =\u003e c.length \u003e 0);\n    if (userMessages.length === 0) {\n        return 'Empty conversation';\n    }\n    // Use first user message as base for summary\n    const firstMessage = userMessages[0].slice(0, 200);\n    const topicHint = userMessages.length \u003e 1\n        ? ` (${userMessages.length} exchanges)`\n        : '';\n    return `${firstMessage}${topicHint}`;\n}","weight":1}},{"data":{"id":"structure:5387","label":"getDb","type":"function","file":"dist-test/src/db/index.js","line":17,"signature":"function getDb()","content":"export function getDb() {\n    if (!db) {\n        ensureDataDir();\n        db = new Database(DB_PATH);\n        db.pragma('journal_mode = WAL');\n        db.pragma('foreign_keys = ON');\n        db.exec(SCHEMA);\n    }\n    return db;\n}","weight":1}},{"data":{"id":"structure:5389","label":"createProject","type":"function","file":"dist-test/src/db/index.js","line":34,"signature":"function createProject(path, name)","content":"export function createProject(path, name) {\n    const db = getDb();\n    const stmt = db.prepare('INSERT INTO projects (path, name) VALUES (?, ?) RETURNING *');\n    return stmt.get(path, name);\n}","weight":1}},{"data":{"id":"structure:5390","label":"getProject","type":"function","file":"dist-test/src/db/index.js","line":39,"signature":"function getProject(id)","content":"export function getProject(id) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM projects WHERE id = ?').get(id);\n}","weight":1}},{"data":{"id":"structure:5391","label":"getProjectByPath","type":"function","file":"dist-test/src/db/index.js","line":43,"signature":"function getProjectByPath(path)","content":"export function getProjectByPath(path) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM projects WHERE path = ?').get(path);\n}","weight":1}},{"data":{"id":"structure:5392","label":"getAllProjects","type":"function","file":"dist-test/src/db/index.js","line":47,"signature":"function getAllProjects()","content":"export function getAllProjects() {\n    const db = getDb();\n    return db.prepare('SELECT * FROM projects ORDER BY created_at DESC').all();\n}","weight":1}},{"data":{"id":"structure:5393","label":"upsertFile","type":"function","file":"dist-test/src/db/index.js","line":52,"signature":"function upsertFile(projectId, path, hash)","content":"export function upsertFile(projectId, path, hash) {\n    const db = getDb();\n    const stmt = db.prepare(`\n    INSERT INTO files (project_id, path, hash, last_indexed)\n    VALUES (?, ?, ?, datetime('now'))\n    ON CONFLICT(project_id, path) DO UPDATE SET\n      hash = excluded.hash,\n      last_indexed = datetime('now')\n    RETURNING *\n  `);\n    return stmt.get(projectId, path, hash);\n}","weight":1}},{"data":{"id":"structure:5394","label":"getFile","type":"function","file":"dist-test/src/db/index.js","line":64,"signature":"function getFile(id)","content":"export function getFile(id) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM files WHERE id = ?').get(id);\n}","weight":1}},{"data":{"id":"structure:5395","label":"getFileByPath","type":"function","file":"dist-test/src/db/index.js","line":68,"signature":"function getFileByPath(projectId, path)","content":"export function getFileByPath(projectId, path) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM files WHERE project_id = ? AND path = ?').get(projectId, path);\n}","weight":1}},{"data":{"id":"structure:5396","label":"deleteFile","type":"function","file":"dist-test/src/db/index.js","line":72,"signature":"function deleteFile(id)","content":"export function deleteFile(id) {\n    const db = getDb();\n    db.prepare('DELETE FROM files WHERE id = ?').run(id);\n}","weight":1}},{"data":{"id":"structure:5397","label":"getProjectFiles","type":"function","file":"dist-test/src/db/index.js","line":76,"signature":"function getProjectFiles(projectId)","content":"export function getProjectFiles(projectId) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM files WHERE project_id = ?').all(projectId);\n}","weight":1}},{"data":{"id":"structure:5399","label":"deleteFileStructures","type":"function","file":"dist-test/src/db/index.js","line":90,"signature":"function deleteFileStructures(fileId)","content":"export function deleteFileStructures(fileId) {\n    const db = getDb();\n    db.prepare('DELETE FROM structures WHERE file_id = ?').run(fileId);\n}","weight":1}},{"data":{"id":"structure:5400","label":"searchStructures","type":"function","file":"dist-test/src/db/index.js","line":94,"signature":"function searchStructures(query, limit = 20, projectId)","content":"export function searchStructures(query, limit = 20, projectId) {\n    const db = getDb();\n    if (projectId) {\n        return db.prepare(`\n      SELECT s.* FROM structures s\n      JOIN structures_fts fts ON s.id = fts.rowid\n      JOIN files f ON s.file_id = f.id\n      WHERE structures_fts MATCH ? AND f.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit);\n    }\n    return db.prepare(`\n    SELECT s.* FROM structures s\n    JOIN structures_fts fts ON s.id = fts.rowid\n    WHERE structures_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit);\n}","weight":1}},{"data":{"id":"structure:5401","label":"getStructuresByName","type":"function","file":"dist-test/src/db/index.js","line":114,"signature":"function getStructuresByName(name, projectId)","content":"export function getStructuresByName(name, projectId) {\n    const db = getDb();\n    if (projectId) {\n        return db.prepare(`\n      SELECT s.* FROM structures s\n      JOIN files f ON s.file_id = f.id\n      WHERE s.name = ? AND f.project_id = ?\n    `).all(name, projectId);\n    }\n    return db.prepare('SELECT * FROM structures WHERE name = ?').all(name);\n}","weight":1}},{"data":{"id":"structure:5402","label":"findProjectForPath","type":"function","file":"dist-test/src/db/index.js","line":126,"signature":"function findProjectForPath(targetPath)","content":"export function findProjectForPath(targetPath) {\n    const projects = getAllProjects();\n    // Sort by path length descending to find most specific match\n    projects.sort((a, b) =\u003e b.path.length - a.path.length);\n    for (const project of projects) {\n        if (targetPath.startsWith(project.path)) {\n            return project;\n        }\n    }\n    return undefined;\n}","weight":1}},{"data":{"id":"structure:5403","label":"insertConversation","type":"function","file":"dist-test/src/db/index.js","line":138,"signature":"function insertConversation(rawContent, projectId = null, model = null, tool = null, summary = null)","content":"export function insertConversation(rawContent, projectId = null, model = null, tool = null, summary = null) {\n    const db = getDb();\n    const stmt = db.prepare(`\n    INSERT INTO conversations (project_id, model, tool, summary, raw_content)\n    VALUES (?, ?, ?, ?, ?)\n    RETURNING *\n  `);\n    return stmt.get(projectId, model, tool, summary, rawContent);\n}","weight":1}},{"data":{"id":"structure:5404","label":"searchConversations","type":"function","file":"dist-test/src/db/index.js","line":147,"signature":"function searchConversations(query, limit = 20, projectId)","content":"export function searchConversations(query, limit = 20, projectId) {\n    const db = getDb();\n    if (projectId) {\n        return db.prepare(`\n      SELECT c.* FROM conversations c\n      JOIN conversations_fts fts ON c.id = fts.rowid\n      WHERE conversations_fts MATCH ? AND c.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit);\n    }\n    return db.prepare(`\n    SELECT c.* FROM conversations c\n    JOIN conversations_fts fts ON c.id = fts.rowid\n    WHERE conversations_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit);\n}","weight":1}},{"data":{"id":"structure:5405","label":"createLink","type":"function","file":"dist-test/src/db/index.js","line":167,"signature":"function createLink(sourceType, sourceId, targetType, targetId, linkType)","content":"export function createLink(sourceType, sourceId, targetType, targetId, linkType) {\n    const db = getDb();\n    const stmt = db.prepare(`\n    INSERT OR IGNORE INTO links (source_type, source_id, target_type, target_id, link_type)\n    VALUES (?, ?, ?, ?, ?)\n    RETURNING *\n  `);\n    return stmt.get(sourceType, sourceId, targetType, targetId, linkType);\n}","weight":1}},{"data":{"id":"structure:5406","label":"getLinksFrom","type":"function","file":"dist-test/src/db/index.js","line":176,"signature":"function getLinksFrom(sourceType, sourceId)","content":"export function getLinksFrom(sourceType, sourceId) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM links WHERE source_type = ? AND source_id = ?').all(sourceType, sourceId);\n}","weight":1}},{"data":{"id":"structure:5407","label":"getLinksTo","type":"function","file":"dist-test/src/db/index.js","line":180,"signature":"function getLinksTo(targetType, targetId)","content":"export function getLinksTo(targetType, targetId) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM links WHERE target_type = ? AND target_id = ?').all(targetType, targetId);\n}","weight":1}},{"data":{"id":"structure:5409","label":"getConversationExtractions","type":"function","file":"dist-test/src/db/index.js","line":194,"signature":"function getConversationExtractions(conversationId)","content":"export function getConversationExtractions(conversationId) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM extractions WHERE conversation_id = ?').all(conversationId);\n}","weight":1}},{"data":{"id":"structure:5410","label":"getExtraction","type":"function","file":"dist-test/src/db/index.js","line":198,"signature":"function getExtraction(id)","content":"export function getExtraction(id) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM extractions WHERE id = ?').get(id);\n}","weight":1}},{"data":{"id":"structure:5411","label":"searchExtractions","type":"function","file":"dist-test/src/db/index.js","line":202,"signature":"function searchExtractions(query, limit = 20, projectId)","content":"export function searchExtractions(query, limit = 20, projectId) {\n    const db = getDb();\n    const searchTerm = `%${query}%`;\n    if (projectId) {\n        return db.prepare(`\n      SELECT e.* FROM extractions e\n      JOIN conversations c ON e.conversation_id = c.id\n      WHERE e.content LIKE ? AND c.project_id = ?\n      ORDER BY e.id DESC\n      LIMIT ?\n    `).all(searchTerm, projectId, limit);\n    }\n    return db.prepare(`\n    SELECT * FROM extractions\n    WHERE content LIKE ?\n    ORDER BY id DESC\n    LIMIT ?\n  `).all(searchTerm, limit);\n}","weight":1}},{"data":{"id":"structure:5412","label":"isDuplicateExtraction","type":"function","file":"dist-test/src/db/index.js","line":221,"signature":"function isDuplicateExtraction(content, projectId, windowSeconds = 300)","content":"export function isDuplicateExtraction(content, projectId, windowSeconds = 300) {\n    const db = getDb();\n    // Check for duplicate extraction content within the last N seconds\n    const stmt = db.prepare(`\n    SELECT COUNT(*) as count FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE e.content = ?\n    AND (c.project_id = ? OR (c.project_id IS NULL AND ? IS NULL))\n    AND datetime(c.timestamp) \u003e datetime('now', '-' || ? || ' seconds')\n  `);\n    const result = stmt.get(content.trim(), projectId, projectId, windowSeconds);\n    return result.count \u003e 0;\n}","weight":1}},{"data":{"id":"structure:5413","label":"getStats","type":"function","file":"dist-test/src/db/index.js","line":235,"signature":"function getStats()","content":"export function getStats() {\n    const db = getDb();\n    const projects = db.prepare('SELECT COUNT(*) as count FROM projects').get().count;\n    const files = db.prepare('SELECT COUNT(*) as count FROM files').get().count;\n    const structures = db.prepare('SELECT COUNT(*) as count FROM structures').get().count;\n    const conversations = db.prepare('SELECT COUNT(*) as count FROM conversations').get().count;\n    const links = db.prepare('SELECT COUNT(*) as count FROM links').get().count;\n    return { projects, files, structures, conversations, links };\n}","weight":1}},{"data":{"id":"structure:5414","label":"structureExists","type":"function","file":"dist-test/src/db/index.js","line":245,"signature":"function structureExists(name)","content":"export function structureExists(name) {\n    const db = getDb();\n    const result = db.prepare('SELECT 1 FROM structures WHERE name = ? LIMIT 1').get(name);\n    return result !== undefined;\n}","weight":1}},{"data":{"id":"structure:5415","label":"fileExists","type":"function","file":"dist-test/src/db/index.js","line":250,"signature":"function fileExists(path)","content":"export function fileExists(path) {\n    const db = getDb();\n    const result = db.prepare('SELECT 1 FROM files WHERE path = ? LIMIT 1').get(path);\n    return result !== undefined;\n}","weight":1}},{"data":{"id":"structure:5416","label":"getConversationById","type":"function","file":"dist-test/src/db/index.js","line":256,"signature":"function getConversationById(id)","content":"export function getConversationById(id) {\n    const db = getDb();\n    return db.prepare('SELECT * FROM conversations WHERE id = ?').get(id);\n}","weight":1}},{"data":{"id":"structure:5417","label":"getFullConversations","type":"function","file":"dist-test/src/db/index.js","line":261,"signature":"function getFullConversations(projectId, limit = 50, offset = 0)","content":"export function getFullConversations(projectId, limit = 50, offset = 0) {\n    const db = getDb();\n    return db.prepare(`\n    SELECT * FROM conversations\n    WHERE project_id = ?\n    ORDER BY timestamp DESC\n    LIMIT ? OFFSET ?\n  `).all(projectId, limit, offset);\n}","weight":1}},{"data":{"id":"structure:5418","label":"searchFullConversations","type":"function","file":"dist-test/src/db/index.js","line":271,"signature":"function searchFullConversations(query, limit = 20, projectId)","content":"export function searchFullConversations(query, limit = 20, projectId) {\n    const db = getDb();\n    if (projectId) {\n        return db.prepare(`\n      SELECT c.* FROM conversations c\n      JOIN conversations_fts fts ON c.id = fts.rowid\n      WHERE conversations_fts MATCH ? AND c.project_id = ?\n      ORDER BY rank\n      LIMIT ?\n    `).all(query, projectId, limit);\n    }\n    return db.prepare(`\n    SELECT c.* FROM conversations c\n    JOIN conversations_fts fts ON c.id = fts.rowid\n    WHERE conversations_fts MATCH ?\n    ORDER BY rank\n    LIMIT ?\n  `).all(query, limit);\n}","weight":1}},{"data":{"id":"structure:5419","label":"visualizeCommand","type":"function","file":"src/cli/commands/visualize.ts","line":22,"signature":"function visualizeCommand(options: VisualizeOptions)","content":"export async function visualizeCommand(options: VisualizeOptions): Promise\u003cvoid\u003e {\n  const cwd = process.cwd();\n\n  // Find project\n  const project = findProjectForPath(cwd);\n  if (!project) {\n    console.log(chalk.red('Error: No aimem project found for current directory.'));\n    console.log(chalk.gray('Run \"aimem init\" first to initialize a project.'));\n    process.exit(1);\n  }\n\n  console.log(chalk.bold(`Generating visualization for: ${project.name}\\n`));\n\n  // Gather data\n  console.log(chalk.gray('Gathering data...'));\n  const structures = getAllProjectStructures(project.id);\n  const files = getProjectFiles(project.id);\n  const links = getAllProjectLinks(project.id);\n  const extractions = getAllProjectExtractions(project.id);\n\n  console.log(chalk.gray(`  ${structures.length} structures`));\n  console.log(chalk.gray(`  ${files.length} files`));\n  console.log(chalk.gray(`  ${links.length} links`));\n  console.log(chalk.gray(`  ${extractions.length} extractions`));\n  console.log();\n\n  if (structures.length === 0) {\n    console.log(chalk.yellow('Warning: No structures found. The codebase may not be indexed yet.'));\n    console.log(chalk.gray('Run \"aimem start\" to begin indexing.'));\n  }\n\n  // Build visualization data\n  const vizData = buildVisualizationData(project, structures, files, links, extractions);\n\n  if (options.serve) {\n    // Serve mode\n    const port = options.port || 8080;\n\n    console.log(chalk.cyan(`Starting dashboard server on port ${port}...`));\n\n    try {\n      await startDashboardServer({\n        port,\n        getData: () =\u003e buildVisualizationData(\n          project,\n          getAllProjectStructures(project.id),\n          getProjectFiles(project.id),\n          getAllProjectLinks(project.id),\n          getAllProjectExtractions(project.id)\n        ),\n      });\n\n      const url = `http://localhost:${port}`;\n      console.log(chalk.green(`\\nDashboard running at: ${chalk.bold(url)}`));\n      console.log(chalk.gray('Press Ctrl+C to stop\\n'));\n\n      // Open in browser if requested\n      if (options.open) {\n        openBrowser(url);\n      }\n    } catch (error) {\n      console.log(chalk.red(`Error starting server: ${(error as Error).message}`));\n      process.exit(1);\n    }\n  } else {\n    // Static file mode\n    const outputPath = options.output || join(cwd, 'aimem-dashboard.html');\n\n    console.log(chalk.gray('Generating HTML...'));\n    const html = generateDashboard(vizData);\n\n    writeFileSync(outputPath, html, 'utf-8');\n    console.log(chalk.green(`\\nDashboard saved to: ${chalk.bold(outputPath)}`));\n\n    // Open in browser if requested\n    if (options.open) {\n      console.log(chalk.gray('Opening in browser...'));\n      openBrowser(outputPath);\n    } else {\n      console.log(chalk.gray('Use --open to open in browser'));\n    }\n  }\n}","weight":9}},{"data":{"id":"structure:5420","label":"openBrowser","type":"function","file":"src/cli/commands/visualize.ts","line":106,"signature":"function openBrowser(url: string)","content":"function openBrowser(url: string): void {\n  const platform = process.platform;\n  let command: string;\n\n  if (platform === 'darwin') {\n    command = `open \"${url}\"`;\n  } else if (platform === 'win32') {\n    command = `start \"\" \"${url}\"`;\n  } else {\n    // Linux and others\n    command = `xdg-open \"${url}\"`;\n  }\n\n  exec(command, (error) =\u003e {\n    if (error) {\n      console.log(chalk.yellow(`Could not open browser automatically.`));\n      console.log(chalk.gray(`Open manually: ${url}`));\n    }\n  });\n}","weight":1}},{"data":{"id":"structure:5422","label":"stopService","type":"function","file":"src/cli/commands/stop.ts","line":6,"signature":"function stopService(name: string)","content":"function stopService(name: string): boolean {\n  const pidFile = join(getDataDir(), `${name}.pid`);\n\n  if (!existsSync(pidFile)) {\n    return false;\n  }\n\n  try {\n    const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n\n    // Try to kill the process\n    try {\n      process.kill(pid, 'SIGTERM');\n      console.log(chalk.green(`Stopped ${name} (PID ${pid})`));\n    } catch {\n      console.log(chalk.gray(`${name} was not running`));\n    }\n\n    // Remove PID file\n    unlinkSync(pidFile);\n    return true;\n  } catch (err) {\n    console.log(chalk.red(`Error stopping ${name}: ${err}`));\n    return false;\n  }\n}","weight":3}},{"data":{"id":"structure:5324","label":"getDataDir","type":"function","file":"src/db/index.ts","line":13,"signature":"function getDataDir()","content":"export function getDataDir(): string {\n  return DATA_DIR;\n}","weight":14}},{"data":{"id":"structure:5423","label":"stopCommand","type":"function","file":"src/cli/commands/stop.ts","line":38,"signature":"function stopCommand(options: StopOptions)","content":"export function stopCommand(options: StopOptions): void {\n  const stopProxy = options.proxy !== false;\n  const stopWatcher = options.watcher !== false;\n\n  console.log(chalk.bold('Stopping aimem services...\\n'));\n\n  let stopped = 0;\n\n  if (stopProxy) {\n    if (stopService('proxy')) stopped++;\n  }\n\n  if (stopWatcher) {\n    if (stopService('watcher')) stopped++;\n  }\n\n  if (stopped === 0) {\n    console.log(chalk.gray('No services were running'));\n  }\n}","weight":1}},{"data":{"id":"structure:5426","label":"getServiceStatus","type":"function","file":"src/cli/commands/status.ts","line":25,"signature":"function getServiceStatus(name: string)","content":"function getServiceStatus(name: string): ServiceStatus {\n  const pidFile = join(getDataDir(), `${name}.pid`);\n  if (!existsSync(pidFile)) {\n    return { running: false };\n  }\n\n  try {\n    const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n    // Check if process is running\n    process.kill(pid, 0);\n    return { running: true, pid };\n  } catch {\n    return { running: false };\n  }\n}","weight":3}},{"data":{"id":"structure:5427","label":"statusCommand","type":"function","file":"src/cli/commands/status.ts","line":41,"signature":"function statusCommand()","content":"export function statusCommand(): void {\n  const dataDir = getDataDir();\n  console.log(chalk.bold('aimem status\\n'));\n\n  // Data directory\n  console.log(chalk.gray(`Data directory: ${dataDir}`));\n  console.log();\n\n  // Dependencies\n  const mitmproxyOk = isMitmproxyInstalled();\n  if (!mitmproxyOk) {\n    console.log(chalk.bold('Dependencies:'));\n    console.log(`  mitmproxy: ${chalk.red('not installed')} ${chalk.gray('(pip install mitmproxy)')}`);\n    console.log();\n  }\n\n  // Services\n  console.log(chalk.bold('Services:'));\n  const proxy = getServiceStatus('proxy');\n  const watcher = getServiceStatus('watcher');\n\n  console.log(`  Proxy:   ${proxy.running ? chalk.green(`running (PID ${proxy.pid})`) : chalk.gray('stopped')}`);\n  console.log(`  Watcher: ${watcher.running ? chalk.green(`running (PID ${watcher.pid})`) : chalk.gray('stopped')}`);\n  console.log();\n\n  // Database stats\n  console.log(chalk.bold('Database:'));\n  try {\n    const stats = getStats();\n    console.log(`  Projects:      ${chalk.cyan(stats.projects)}`);\n    console.log(`  Files:         ${chalk.cyan(stats.files)}`);\n    console.log(`  Structures:    ${chalk.cyan(stats.structures)}`);\n    console.log(`  Conversations: ${chalk.cyan(stats.conversations)}`);\n    console.log(`  Links:         ${chalk.cyan(stats.links)}`);\n  } catch (err) {\n    console.log(chalk.gray('  (no database yet)'));\n  }\n  console.log();\n\n  // Projects\n  console.log(chalk.bold('Projects:'));\n  try {\n    const projects = getAllProjects();\n    if (projects.length === 0) {\n      console.log(chalk.gray('  (none)'));\n    } else {\n      for (const p of projects) {\n        console.log(`  ${chalk.cyan(p.name)} - ${chalk.gray(p.path)}`);\n      }\n    }\n  } catch {\n    console.log(chalk.gray('  (no database yet)'));\n  }\n}","weight":5}},{"data":{"id":"structure:5425","label":"isMitmproxyInstalled","type":"function","file":"src/cli/commands/status.ts","line":7,"signature":"function isMitmproxyInstalled()","content":"function isMitmproxyInstalled(): boolean {\n  try {\n    const result = spawnSync('mitmdump', ['--version'], {\n      encoding: 'utf-8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    return result.status === 0;\n  } catch {\n    return false;\n  }\n}","weight":4}},{"data":{"id":"structure:5431","label":"getServicePid","type":"function","file":"src/cli/commands/start.ts","line":38,"signature":"function getServicePid(name: string)","content":"function getServicePid(name: string): number | null {\n  const pidFile = join(getDataDir(), `${name}.pid`);\n  if (!existsSync(pidFile)) return null;\n\n  try {\n    const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n    return isProcessRunning(pid) ? pid : null;\n  } catch {\n    return null;\n  }\n}","weight":4}},{"data":{"id":"structure:5430","label":"isProcessRunning","type":"function","file":"src/cli/commands/start.ts","line":29,"signature":"function isProcessRunning(pid: number)","content":"function isProcessRunning(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}","weight":2}},{"data":{"id":"structure:5432","label":"writePidFile","type":"function","file":"src/cli/commands/start.ts","line":50,"signature":"function writePidFile(name: string, pid: number)","content":"function writePidFile(name: string, pid: number): void {\n  const pidFile = join(getDataDir(), `${name}.pid`);\n  writeFileSync(pidFile, String(pid));\n}","weight":3}},{"data":{"id":"structure:5433","label":"startCommand","type":"function","file":"src/cli/commands/start.ts","line":55,"signature":"function startCommand(options: StartOptions)","content":"export async function startCommand(options: StartOptions): Promise\u003cvoid\u003e {\n  ensureDataDir();\n  const dataDir = getDataDir();\n\n  const startProxy = options.proxy !== false;\n  const startWatcher = options.watcher !== false;\n  const port = options.port || 8080;\n\n  console.log(chalk.bold('Starting aimem services...\\n'));\n\n  // Start proxy\n  if (startProxy) {\n    const existingPid = getServicePid('proxy');\n    if (existingPid) {\n      console.log(chalk.yellow(`Proxy already running (PID ${existingPid})`));\n    } else if (!isMitmproxyInstalled()) {\n      console.log(chalk.red('‚úó mitmproxy is not installed'));\n      console.log(chalk.yellow('\\n  mitmproxy is required for context capture. Install it with:\\n'));\n      console.log(chalk.white('    pip install mitmproxy\\n'));\n      console.log(chalk.gray('  After installing, run `aimem start` again.'));\n    } else {\n      const interceptorPath = join(__dirname, '..', '..', 'proxy', 'interceptor.py');\n\n      try {\n        const child = spawn('mitmdump', [\n          '-s', interceptorPath,\n          '-p', String(port),\n          '--set', `data_dir=${dataDir}`,\n        ], {\n          detached: true,\n          stdio: 'ignore',\n        });\n\n        if (child.pid) {\n          writePidFile('proxy', child.pid);\n          child.unref();\n          console.log(chalk.green(`Proxy started on port ${port} (PID ${child.pid})`));\n          console.log(chalk.gray(`  Configure tools with: HTTP_PROXY=http://localhost:${port}`));\n        }\n      } catch (err) {\n        console.log(chalk.red('Failed to start proxy.'));\n        console.log(chalk.gray('  Check mitmproxy installation: pip install mitmproxy'));\n      }\n    }\n  }\n\n  // Start watcher\n  if (startWatcher) {\n    const existingPid = getServicePid('watcher');\n    if (existingPid) {\n      console.log(chalk.yellow(`Watcher already running (PID ${existingPid})`));\n    } else {\n      const watcherPath = join(__dirname, '..', '..', 'indexer', 'watcher-daemon.js');\n\n      const child = spawn('node', [watcherPath], {\n        detached: true,\n        stdio: 'ignore',\n        env: { ...process.env, AIMEM_DATA_DIR: dataDir },\n      });\n\n      if (child.pid) {\n        writePidFile('watcher', child.pid);\n        child.unref();\n        console.log(chalk.green(`Watcher started (PID ${child.pid})`));\n      }\n    }\n  }\n\n  console.log(chalk.gray('\\nUse `aimem status` to check service status'));\n  console.log(chalk.gray('Use `aimem stop` to stop services'));\n}","weight":5}},{"data":{"id":"structure:5444","label":"addToShellProfile","type":"function","file":"src/cli/commands/setup.ts","line":279,"signature":"function addToShellProfile(profilePath: string, port: string, certPath: string | null)","content":"function addToShellProfile(profilePath: string, port: string, certPath: string | null): boolean {\n  const marker = '# aimem proxy configuration';\n\n  // Build env block with proper Node.js SSL handling\n  let envBlock = `\n${marker}\nexport HTTP_PROXY=http://localhost:${port}\nexport HTTPS_PROXY=http://localhost:${port}\n`;\n\n  // Add Node.js cert configuration\n  if (certPath) {\n    envBlock += `export NODE_EXTRA_CA_CERTS=\"${certPath}\"\n`;\n  }\n\n  // Fallback for apps that don't respect NODE_EXTRA_CA_CERTS\n  envBlock += `export NODE_TLS_REJECT_UNAUTHORIZED=0\n`;\n\n  try {\n    let content = '';\n    if (existsSync(profilePath)) {\n      content = readFileSync(profilePath, 'utf-8');\n\n      // Check if already configured\n      if (content.includes(marker)) {\n        console.log(chalk.yellow(`Shell profile already configured: ${profilePath}`));\n        return true;\n      }\n    }\n\n    // Append to profile\n    writeFileSync(profilePath, content + envBlock);\n    console.log(chalk.green(`Added proxy environment to: ${profilePath}`));\n    return true;\n  } catch (err) {\n    console.log(chalk.red(`Failed to update shell profile: ${profilePath}`));\n    return false;\n  }\n}\n\nexport async function setupCommand(tool: string, options: { force?: boolean; port?: string; install?: boolean; autostart?: boolean }): Promise\u003cvoid\u003e {\n  const supportedTools = ['claude-code', 'proxy', 'cursor', 'continue'];\n\n  if (!tool) {\n    console.log(chalk.bold('aimem setup\\n'));\n    console.log('Automatically configure aimem for AI coding tools.\\n');\n    console.log('Usage:');\n    console.log('  aimem setup claude-code    Configure for Claude Code (MCP server)');\n    console.log('  aimem setup proxy          Configure proxy for any tool (Cursor, etc.)');\n    console.log('  aimem setup cursor         Show Cursor configuration instructions');\n    console.log('  aimem setup continue       Show Continue.dev configuration instructions\\n');\n    console.log('Supported tools:', supportedTools.join(', '));\n    return;\n  }\n\n  if (!supportedTools.includes(tool)) {\n    console.log(chalk.red(`Unknown tool: ${tool}`));\n    console.log('Supported tools:', supportedTools.join(', '));\n    process.exit(1);\n  }\n\n  if (tool === 'claude-code') {\n    await setupClaudeCode(options);\n  } else if (tool === 'proxy') {\n    await setupProxy(options);\n  } else if (tool === 'cursor') {\n    await setupCursor(options);\n  } else if (tool === 'continue') {\n    await setupContinue(options);\n  }\n}\n\nasync function setupClaudeCode(options: { force?: boolean }): Promise\u003cvoid\u003e {\n  console.log(chalk.bold('Setting up aimem for Claude Code...\\n'));\n\n  const aimemPath = getAimemPath();\n  console.log(`Found aimem at: ${chalk.cyan(aimemPath)}`);\n\n  // Claude Code settings file location\n  const claudeDir = join(homedir(), '.claude');\n  const settingsPath = join(claudeDir, 'settings.json');\n\n  // Read existing settings or create new\n  let settings: ClaudeSettings = {};\n  const existingSettings = readJsonFile(settingsPath);\n\n  if (existingSettings) {\n    settings = existingSettings as ClaudeSettings;\n    console.log(`Found existing settings at: ${chalk.cyan(settingsPath)}`);\n  } else {\n    console.log(`Creating new settings file at: ${chalk.cyan(settingsPath)}`);\n  }\n\n  // Track what we're changing\n  const changes: string[] = [];\n\n  // Configure MCP server (for query tools)\n  if (!settings.mcpServers) {\n    settings.mcpServers = {};\n  }\n\n  if (!settings.mcpServers.aimem || options.force) {\n    settings.mcpServers.aimem = {\n      command: aimemPath,\n      args: ['mcp-serve'],\n    };\n    changes.push('Added aimem MCP server (query tools)');\n  } else {\n    console.log(chalk.yellow('MCP server already configured (use --force to overwrite)'));\n  }\n\n  // Write settings\n  if (changes.length \u003e 0) {\n    writeJsonFile(settingsPath, settings);\n\n    console.log(chalk.green('\\nConfiguration updated:'));\n    for (const change of changes) {\n      console.log(chalk.green(`  ‚úì ${change}`));\n    }\n  } else {\n    console.log(chalk.green('\\nMCP server already configured.'));\n  }\n\n  console.log(chalk.bold('\\nNext steps:'));\n  console.log('  1. Restart Claude Code to load the MCP server');\n  console.log('  2. Set up the proxy for context capture:');\n  console.log(chalk.cyan('     aimem setup proxy --install'));\n  console.log('  3. Start the proxy before using Claude Code:');\n  console.log(chalk.cyan('     aimem start'));\n  console.log('  4. Run `aimem init` in your project directory to index it\\n');\n\n  console.log(chalk.yellow('Note: The proxy captures decisions in real-time and injects'));\n  console.log(chalk.yellow('context into requests. MCP provides query tools.\\n'));\n}","weight":10}},{"data":{"id":"structure:5445","label":"setupCommand","type":"function","file":"src/cli/commands/setup.ts","line":321,"signature":"function setupCommand(tool: string, options: { force?: boolean; port?: string; install?: boolean; autostart?: boolean })","content":"export async function setupCommand(tool: string, options: { force?: boolean; port?: string; install?: boolean; autostart?: boolean }): Promise\u003cvoid\u003e {","weight":2}},{"data":{"id":"structure:5446","label":"setupClaudeCode","type":"function","file":"src/cli/commands/setup.ts","line":353,"signature":"function setupClaudeCode(options: { force?: boolean })","content":"async function setupClaudeCode(options: { force?: boolean }): Promise\u003cvoid\u003e {","weight":3}},{"data":{"id":"structure:5447","label":"setupProxy","type":"function","file":"src/cli/commands/setup.ts","line":416,"signature":"function setupProxy(options: { port?: string; install?: boolean; autostart?: boolean })","content":"async function setupProxy(options: { port?: string; install?: boolean; autostart?: boolean }): Promise\u003cvoid\u003e {","weight":4}},{"data":{"id":"structure:5448","label":"setupCursor","type":"function","file":"src/cli/commands/setup.ts","line":544,"signature":"function setupCursor(options: { port?: string })","content":"async function setupCursor(options: { port?: string }): Promise\u003cvoid\u003e {","weight":4}},{"data":{"id":"structure:5449","label":"setupContinue","type":"function","file":"src/cli/commands/setup.ts","line":573,"signature":"function setupContinue(options: { port?: string })","content":"async function setupContinue(options: { port?: string }): Promise\u003cvoid\u003e {","weight":3}},{"data":{"id":"structure:5435","label":"getAimemPath","type":"function","file":"src/cli/commands/setup.ts","line":21,"signature":"function getAimemPath()","content":"function getAimemPath(): string {\n  try {\n    // Try to find aimem in PATH\n    const result = execSync('which aimem', { encoding: 'utf-8' }).trim();\n    if (result) return result;\n  } catch {\n    // Fall through\n  }\n\n  // Fallback: check common locations\n  const possiblePaths = [\n    join(homedir(), '.nvm/versions/node', process.version, 'bin/aimem'),\n    '/usr/local/bin/aimem',\n    '/usr/bin/aimem',\n    join(homedir(), '.npm-global/bin/aimem'),\n  ];\n\n  for (const p of possiblePaths) {\n    if (existsSync(p)) return p;\n  }\n\n  // Last resort: use npx\n  return 'npx aimem';\n}","weight":6}},{"data":{"id":"structure:5437","label":"readJsonFile","type":"function","file":"src/cli/commands/setup.ts","line":56,"signature":"function readJsonFile(path: string)","content":"function readJsonFile(path: string): Record\u003cstring, unknown\u003e | null {\n  try {\n    if (!existsSync(path)) return null;\n    const content = readFileSync(path, 'utf-8');\n    return JSON.parse(content);\n  } catch {\n    return null;\n  }\n}","weight":3}},{"data":{"id":"structure:5438","label":"writeJsonFile","type":"function","file":"src/cli/commands/setup.ts","line":66,"signature":"function writeJsonFile(path: string, data: Record\u003cstring, unknown\u003e)","content":"function writeJsonFile(path: string, data: Record\u003cstring, unknown\u003e): void {\n  const dir = dirname(path);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n  writeFileSync(path, JSON.stringify(data, null, 2) + '\\n');\n}","weight":3}},{"data":{"id":"structure:5451","label":"formatStructure","type":"function","file":"src/cli/commands/query.ts","line":11,"signature":"function formatStructure(s: Structure, fileCache: Map\u003cnumber, string\u003e)","content":"function formatStructure(s: Structure, fileCache: Map\u003cnumber, string\u003e): string {\n  let filePath = fileCache.get(s.file_id);\n  if (!filePath) {\n    const file = getFile(s.file_id);\n    filePath = file?.path || 'unknown';\n    fileCache.set(s.file_id, filePath);\n  }\n\n  const location = `${filePath}:${s.line_start}`;\n  const sig = s.signature || s.name;\n\n  return `  ${chalk.cyan(s.type)} ${chalk.bold(s.name)}\n    ${chalk.gray(location)}\n    ${chalk.gray(sig)}`;\n}","weight":3}},{"data":{"id":"structure:5453","label":"queryCommand","type":"function","file":"src/cli/commands/query.ts","line":36,"signature":"function queryCommand(searchQuery: string, options: QueryOptions)","content":"export function queryCommand(searchQuery: string, options: QueryOptions): void {\n  const type = options.type || 'all';\n  const limit = options.limit || 10;\n\n  // Auto-detect project from cwd unless --global flag is set\n  let projectId: number | undefined;\n  if (!options.global) {\n    const project = findProjectForPath(process.cwd());\n    if (project) {\n      projectId = project.id;\n      console.log(chalk.gray(`Searching in project: ${project.name}`));\n      console.log(chalk.gray(`(use --global to search all projects)\\n`));\n    }\n  }\n\n  console.log(chalk.bold(`Searching for: \"${searchQuery}\"\\n`));\n\n  const fileCache = new Map\u003cnumber, string\u003e();\n  let foundAny = false;\n\n  // Search structures\n  if (type === 'all' || type === 'structures') {\n    try {\n      const structures = searchStructures(searchQuery, limit, projectId);\n      if (structures.length \u003e 0) {\n        foundAny = true;\n        console.log(chalk.bold.blue(`Structures (${structures.length}):`));\n        for (const s of structures) {\n          console.log(formatStructure(s, fileCache));\n\n          // Show related conversations\n          const links = getLinksTo('structure', s.id);\n          const decisions = links.filter(l =\u003e l.link_type === 'decision');\n          if (decisions.length \u003e 0) {\n            console.log(chalk.gray(`    ${decisions.length} related decision(s)`));\n          }\n        }\n        console.log();\n      }\n    } catch (err) {\n      // FTS might not be ready\n    }\n  }\n\n  // Search conversations\n  if (type === 'all' || type === 'conversations') {\n    try {\n      const conversations = searchConversations(searchQuery, limit, projectId);\n      if (conversations.length \u003e 0) {\n        foundAny = true;\n        console.log(chalk.bold.yellow(`Conversations (${conversations.length}):`));\n        for (const c of conversations) {\n          console.log(formatConversation(c));\n        }\n        console.log();\n      }\n    } catch (err) {\n      // FTS might not be ready\n    }\n  }\n\n  if (!foundAny) {\n    console.log(chalk.gray('No results found'));\n  }\n}","weight":6}},{"data":{"id":"structure:5452","label":"formatConversation","type":"function","file":"src/cli/commands/query.ts","line":27,"signature":"function formatConversation(c: Conversation)","content":"function formatConversation(c: Conversation): string {\n  const date = new Date(c.timestamp).toLocaleDateString();\n  const summary = c.summary || c.raw_content.slice(0, 100) + '...';\n  const model = c.model || 'unknown';\n\n  return `  ${chalk.yellow(`#${c.id}`)} ${chalk.gray(date)} ${chalk.gray(`[${model}]`)}\n    ${summary}`;\n}","weight":2}},{"data":{"id":"structure:5455","label":"mcpServeCommand","type":"function","file":"src/cli/commands/mcp-serve.ts","line":3,"signature":"function mcpServeCommand()","content":"export async function mcpServeCommand(): Promise\u003cvoid\u003e {\n  await startMcpServer();\n}","weight":1}},{"data":{"id":"structure:5456","label":"initCommand","type":"function","file":"src/cli/commands/init.ts","line":7,"signature":"function initCommand(targetPath?: string)","content":"export async function initCommand(targetPath?: string): Promise\u003cvoid\u003e {\n  const projectPath = resolve(targetPath || process.cwd());\n\n  if (!existsSync(projectPath)) {\n    console.error(chalk.red(`Error: Path does not exist: ${projectPath}`));\n    process.exit(1);\n  }\n\n  // Check if already initialized\n  const existing = getProjectByPath(projectPath);\n  if (existing) {\n    console.log(chalk.yellow(`Project already initialized: ${existing.name}`));\n    console.log(chalk.gray(`Re-indexing...`));\n    await indexProject(existing.id, projectPath);\n    console.log(chalk.green(`Re-indexed: ${projectPath}`));\n    return;\n  }\n\n  // Create new project\n  const name = projectPath.split('/').pop() || 'project';\n  const project = createProject(projectPath, name);\n\n  console.log(chalk.green(`Initialized aimem for: ${projectPath}`));\n  console.log(chalk.gray(`Data stored in: ${getDataDir()}`));\n  console.log(chalk.gray(`Project ID: ${project.id}`));\n\n  // Index the project\n  console.log(chalk.blue(`Indexing codebase...`));\n  await indexProject(project.id, projectPath);\n  console.log(chalk.green(`Done!`));\n}","weight":4}},{"data":{"id":"structure:5310","label":"indexProject","type":"function","file":"src/indexer/index.ts","line":131,"signature":"function indexProject(projectId: number, projectPath: string)","content":"export async function indexProject(projectId: number, projectPath: string): Promise\u003c{ files: number; structures: number; links: number }\u003e {","weight":2}},{"data":{"id":"structure:5462","label":"findClaudeProject","type":"function","file":"src/cli/commands/import.ts","line":127,"signature":"function findClaudeProject(projectPath: string)","content":"function findClaudeProject(projectPath: string): string | null {\n  const claudeProjectsDir = getClaudeProjectsDir();\n  if (!existsSync(claudeProjectsDir)) return null;\n\n  const encoded = encodeProjectPath(projectPath);\n  const fullPath = join(claudeProjectsDir, encoded);\n\n  if (existsSync(fullPath)) {\n    return fullPath;\n  }\n\n  const dirs = readdirSync(claudeProjectsDir);\n  for (const dir of dirs) {\n    if (dir.includes(basename(projectPath))) {\n      return join(claudeProjectsDir, dir);\n    }\n  }\n\n  return null;\n}","weight":4}},{"data":{"id":"structure:5460","label":"getClaudeProjectsDir","type":"function","file":"src/cli/commands/import.ts","line":119,"signature":"function getClaudeProjectsDir()","content":"function getClaudeProjectsDir(): string {\n  return join(homedir(), '.claude', 'projects');\n}","weight":2}},{"data":{"id":"structure:5461","label":"encodeProjectPath","type":"function","file":"src/cli/commands/import.ts","line":123,"signature":"function encodeProjectPath(projectPath: string)","content":"function encodeProjectPath(projectPath: string): string {\n  return '-' + projectPath.replace(/\\//g, '-').replace(/^-/, '');\n}","weight":2}},{"data":{"id":"structure:5465","label":"importFromClaude","type":"function","file":"src/cli/commands/import.ts","line":187,"signature":"function importFromClaude(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n)","content":"async function importFromClaude(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n): Promise\u003cImportResult | null\u003e {\n  const claudeProjectDir = findClaudeProject(projectPath);\n  if (!claudeProjectDir) {\n    return null;\n  }\n\n  console.log(chalk.bold('\\nüìÅ Claude Code'));\n  console.log(`   ${chalk.gray(claudeProjectDir)}`);\n\n  const db = getDb();\n  const files = readdirSync(claudeProjectDir)\n    .filter((f) =\u003e f.endsWith('.jsonl') \u0026\u0026 !f.startsWith('agent-'))\n    .map((f) =\u003e join(claudeProjectDir, f));\n\n  if (files.length === 0) {\n    console.log(chalk.gray('   No conversation files found'));\n    return null;\n  }\n\n  console.log(`   Found ${files.length} conversation files`);\n\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let skippedDuplicates = 0;\n\n  for (const file of files) {\n    const fileName = basename(file);\n    const messages = parseClaudeConversationFile(file);\n\n    if (messages.length === 0) continue;\n\n    for (const msg of messages) {\n      if (totalExtractions \u003e= limit) break;\n\n      const text = extractClaudeAssistantText(msg);\n      if (!text || text.length \u003c 100) continue;\n\n      totalMessages++;\n      const extractions = extractDecisions(text);\n\n      const newExtractions = extractions.filter((e) =\u003e {\n        const key = e.content.slice(0, 80).toLowerCase();\n        if (existingExtractions.has(key)) {\n          skippedDuplicates++;\n          return false;\n        }\n        existingExtractions.add(key);\n        return true;\n      });\n\n      if (newExtractions.length === 0) continue;\n\n      if (dryRun) {\n        if (full) {\n          console.log(chalk.gray(`   [full] ${text.slice(0, 80)}...`));\n        }\n        for (const ext of newExtractions) {\n          console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n          totalExtractions++;\n        }\n      } else {\n        const timestamp = msg.timestamp || new Date().toISOString();\n        // Store full content if --full flag is set, otherwise just metadata\n        const rawContent = full ? text : JSON.stringify({ imported: true, source: fileName });\n        const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'claude-code', rawContent, timestamp);\n\n        const conversationId = result.lastInsertRowid;\n\n        for (const ext of newExtractions) {\n          db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'claude' }));\n          totalExtractions++;\n        }\n      }\n    }\n\n    if (totalExtractions \u003e= limit) break;\n  }\n\n  return { source: 'claude', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":9}},{"data":{"id":"structure:5464","label":"parseClaudeConversationFile","type":"function","file":"src/cli/commands/import.ts","line":168,"signature":"function parseClaudeConversationFile(filePath: string)","content":"function parseClaudeConversationFile(filePath: string): ClaudeMessage[] {\n  const content = readFileSync(filePath, 'utf-8');\n  const messages: ClaudeMessage[] = [];\n\n  for (const line of content.split('\\n')) {\n    if (!line.trim()) continue;\n    try {\n      const parsed = JSON.parse(line) as ClaudeMessage;\n      if (parsed.type === 'assistant') {\n        messages.push(parsed);\n      }\n    } catch {\n      // Skip invalid lines\n    }\n  }\n\n  return messages;\n}","weight":2}},{"data":{"id":"structure:5463","label":"extractClaudeAssistantText","type":"function","file":"src/cli/commands/import.ts","line":148,"signature":"function extractClaudeAssistantText(message: ClaudeMessage)","content":"function extractClaudeAssistantText(message: ClaudeMessage): string {\n  if (!message.message || message.message.role !== 'assistant') {\n    return '';\n  }\n\n  const content = message.message.content;\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (Array.isArray(content)) {\n    return content\n      .filter((block) =\u003e block.type === 'text' \u0026\u0026 block.text)\n      .map((block) =\u003e block.text)\n      .join('\\n');\n  }\n\n  return '';\n}","weight":2}},{"data":{"id":"structure:5467","label":"parseAiderHistory","type":"function","file":"src/cli/commands/import.ts","line":312,"signature":"function parseAiderHistory(content: string)","content":"function parseAiderHistory(content: string): string[] {\n  // Aider format:\n  // #### /ask or #### user message\n  // User content\n  //\n  // #### assistant or #### Claude response\n  // Assistant content\n\n  const assistantBlocks: string[] = [];\n  const lines = content.split('\\n');\n  let inAssistantBlock = false;\n  let currentBlock = '';\n\n  for (const line of lines) {\n    // Check for block headers\n    if (line.startsWith('#### ')) {\n      // Save previous assistant block\n      if (inAssistantBlock \u0026\u0026 currentBlock.trim()) {\n        assistantBlocks.push(currentBlock.trim());\n      }\n      currentBlock = '';\n\n      // Check if this is an assistant block\n      const header = line.slice(5).toLowerCase();\n      inAssistantBlock = !header.startsWith('/') \u0026\u0026\n                         !header.includes('user') \u0026\u0026\n                         !header.includes('human') \u0026\u0026\n                         (header.includes('assistant') ||\n                          header.includes('claude') ||\n                          header.includes('gpt') ||\n                          header.includes('aider') ||\n                          header === '');\n    } else if (inAssistantBlock) {\n      currentBlock += line + '\\n';\n    }\n  }\n\n  // Don't forget the last block\n  if (inAssistantBlock \u0026\u0026 currentBlock.trim()) {\n    assistantBlocks.push(currentBlock.trim());\n  }\n\n  return assistantBlocks;\n}\n\nasync function importFromAider(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n): Promise\u003cImportResult | null\u003e {\n  const historyFiles = findAiderHistoryFiles(projectPath);\n\n  if (historyFiles.length === 0) {\n    return null;\n  }\n\n  console.log(chalk.bold('\\nüìÅ Aider'));\n  console.log(`   Found ${historyFiles.length} history file(s)`);\n\n  const db = getDb();\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let skippedDuplicates = 0;\n\n  for (const file of historyFiles) {\n    const fileName = basename(file);\n    console.log(`   ${chalk.gray(fileName)}`);\n\n    const content = readFileSync(file, 'utf-8');\n    const assistantBlocks = parseAiderHistory(content);\n\n    if (assistantBlocks.length === 0) {\n      console.log(chalk.gray('   No assistant messages found'));\n      continue;\n    }\n\n    console.log(`   ${assistantBlocks.length} assistant messages`);\n\n    for (const block of assistantBlocks) {\n      if (totalExtractions \u003e= limit) break;\n      if (block.length \u003c 100) continue;\n\n      totalMessages++;\n      const extractions = extractDecisions(block);\n\n      const newExtractions = extractions.filter((e) =\u003e {\n        const key = e.content.slice(0, 80).toLowerCase();\n        if (existingExtractions.has(key)) {\n          skippedDuplicates++;\n          return false;\n        }\n        existingExtractions.add(key);\n        return true;\n      });\n\n      if (newExtractions.length === 0) continue;\n\n      if (dryRun) {\n        if (full) {\n          console.log(chalk.gray(`   [full] ${block.slice(0, 80)}...`));\n        }\n        for (const ext of newExtractions) {\n          console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n          totalExtractions++;\n        }\n      } else {\n        // Store full content if --full flag is set, otherwise just metadata\n        const rawContent = full ? block : JSON.stringify({ imported: true, source: fileName });\n        const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'aider', rawContent, new Date().toISOString());\n\n        const conversationId = result.lastInsertRowid;\n\n        for (const ext of newExtractions) {\n          db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'aider' }));\n          totalExtractions++;\n        }\n      }\n    }\n\n    if (totalExtractions \u003e= limit) break;\n  }\n\n  return { source: 'aider', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}\n\n// ============================================================================\n// Continue.dev import\n// ============================================================================\n\nfunction getContinueSessionsDir(): string {\n  return join(homedir(), '.continue', 'sessions');\n}\n\ninterface ContinueSession {\n  history?: Array\u003c{\n    role: string;\n    content: string;\n  }\u003e;\n}\n\nasync function importFromContinue(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n): Promise\u003cImportResult | null\u003e {\n  const sessionsDir = getContinueSessionsDir();\n\n  if (!existsSync(sessionsDir)) {\n    return null;\n  }\n\n  console.log(chalk.bold('\\nüìÅ Continue.dev'));\n  console.log(`   ${chalk.gray(sessionsDir)}`);\n\n  const db = getDb();\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let skippedDuplicates = 0;\n\n  try {\n    const files = readdirSync(sessionsDir).filter((f) =\u003e f.endsWith('.json'));\n\n    if (files.length === 0) {\n      console.log(chalk.gray('   No session files found'));\n      return null;\n    }\n\n    console.log(`   Found ${files.length} session files`);\n\n    for (const file of files) {\n      if (totalExtractions \u003e= limit) break;\n\n      try {\n        const content = readFileSync(join(sessionsDir, file), 'utf-8');\n        const session = JSON.parse(content) as ContinueSession;\n\n        if (!session.history || !Array.isArray(session.history)) continue;\n\n        const assistantMessages = session.history.filter((m) =\u003e m.role === 'assistant' \u0026\u0026 m.content);\n\n        for (const msg of assistantMessages) {\n          if (totalExtractions \u003e= limit) break;\n          if (msg.content.length \u003c 100) continue;\n\n          totalMessages++;\n          const extractions = extractDecisions(msg.content);\n\n          const newExtractions = extractions.filter((e) =\u003e {\n            const key = e.content.slice(0, 80).toLowerCase();\n            if (existingExtractions.has(key)) {\n              skippedDuplicates++;\n              return false;\n            }\n            existingExtractions.add(key);\n            return true;\n          });\n\n          if (newExtractions.length === 0) continue;\n\n          if (dryRun) {\n            if (full) {\n              console.log(chalk.gray(`   [full] ${msg.content.slice(0, 80)}...`));\n            }\n            for (const ext of newExtractions) {\n              console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n              totalExtractions++;\n            }\n          } else {\n            // Store full content if --full flag is set, otherwise just metadata\n            const rawContent = full ? msg.content : JSON.stringify({ imported: true, source: file });\n            const result = db.prepare(`\n              INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n              VALUES (?, ?, ?, ?, ?)\n            `).run(projectId, 'imported', 'continue', rawContent, new Date().toISOString());\n\n            const conversationId = result.lastInsertRowid;\n\n            for (const ext of newExtractions) {\n              db.prepare(`\n                INSERT INTO extractions (conversation_id, type, content, metadata)\n                VALUES (?, ?, ?, ?)\n              `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'continue' }));\n              totalExtractions++;\n            }\n          }\n        }\n      } catch {\n        // Skip invalid files\n      }\n    }\n  } catch {\n    return null;\n  }\n\n  if (totalMessages === 0) {\n    return null;\n  }\n\n  return { source: 'continue', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}\n\n// ============================================================================\n// Main import command\n// ============================================================================\n\nexport async function importCommand(options: ImportOptions): Promise\u003cvoid\u003e {\n  ensureDataDir();\n  const db = getDb();\n\n  const projectPath = options.project || process.cwd();\n  const source = options.source || 'all';\n  const dryRun = options.dryRun || false;\n  const limit = options.limit || 1000;\n  const full = options.full || false;\n\n  console.log(chalk.bold('Importing conversation history...\\n'));\n\n  // Find the aimem project\n  const aimemProject = getProjectByPath(projectPath);\n  if (!aimemProject) {\n    console.log(chalk.red(`Project not indexed: ${projectPath}`));\n    console.log(chalk.yellow('Run `aimem init` first to index this project.'));\n    process.exit(1);\n  }\n\n  console.log(`Project: ${chalk.cyan(aimemProject.path)}`);\n  console.log(`Source:  ${chalk.cyan(source)}`);\n  if (dryRun) console.log(chalk.yellow('Mode:    dry-run'));\n  if (full) console.log(chalk.green('Mode:    full (storing complete conversation content)'));\n\n  // Load existing extractions to avoid duplicates\n  const existingExtractions = new Set\u003cstring\u003e();\n  const existingRows = db.prepare(`\n    SELECT e.content FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE c.project_id = ?\n  `).all(aimemProject.id) as Array\u003c{ content: string }\u003e;\n\n  for (const row of existingRows) {\n    existingExtractions.add(row.content.slice(0, 80).toLowerCase());\n  }\n\n  console.log(`Existing extractions: ${existingExtractions.size}`);\n\n  const results: ImportResult[] = [];\n\n  // Import from selected sources\n  if (source === 'all' || source === 'claude') {\n    const result = await importFromClaude(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  if (source === 'all' || source === 'aider') {\n    const result = await importFromAider(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  if (source === 'all' || source === 'continue') {\n    const result = await importFromContinue(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  // Summary\n  console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ'));\n\n  if (results.length === 0) {\n    console.log(chalk.yellow('No conversation history found for any source.'));\n    console.log(chalk.gray('\\nSupported sources:'));\n    console.log(chalk.gray('  - Claude Code: ~/.claude/projects/'));\n    console.log(chalk.gray('  - Aider: .aider.chat.history.md in project'));\n    console.log(chalk.gray('  - Continue.dev: ~/.continue/sessions/'));\n    return;\n  }\n\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let totalDuplicates = 0;\n\n  for (const r of results) {\n    console.log(`\\n${chalk.cyan(r.source)}:`);\n    console.log(`  Messages:    ${r.messages}`);\n    console.log(`  Extractions: ${chalk.green(r.extractions)}`);\n    console.log(`  Duplicates:  ${r.duplicates}`);\n    totalMessages += r.messages;\n    totalExtractions += r.extractions;\n    totalDuplicates += r.duplicates;\n  }\n\n  console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Total ‚îÅ‚îÅ‚îÅ'));\n  console.log(`Messages:    ${totalMessages}`);\n  console.log(`Extractions: ${chalk.green(totalExtractions)}`);\n  console.log(`Duplicates:  ${totalDuplicates}`);\n\n  if (dryRun) {\n    console.log(chalk.yellow('\\nDry run - no changes made. Remove --dry-run to import.'));\n  } else if (totalExtractions \u003e 0) {\n    console.log(chalk.green('\\nImport complete!'));\n    console.log(chalk.gray('Query with: aimem_decisions \u003ctopic\u003e'));\n  }\n}\n","weight":12}},{"data":{"id":"structure:5468","label":"importFromAider","type":"function","file":"src/cli/commands/import.ts","line":357,"signature":"function importFromAider(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n)","content":"async function importFromAider(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n): Promise\u003cImportResult | null\u003e {\n  const historyFiles = findAiderHistoryFiles(projectPath);\n\n  if (historyFiles.length === 0) {\n    return null;\n  }\n\n  console.log(chalk.bold('\\nüìÅ Aider'));\n  console.log(`   Found ${historyFiles.length} history file(s)`);\n\n  const db = getDb();\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let skippedDuplicates = 0;\n\n  for (const file of historyFiles) {\n    const fileName = basename(file);\n    console.log(`   ${chalk.gray(fileName)}`);\n\n    const content = readFileSync(file, 'utf-8');\n    const assistantBlocks = parseAiderHistory(content);\n\n    if (assistantBlocks.length === 0) {\n      console.log(chalk.gray('   No assistant messages found'));\n      continue;\n    }\n\n    console.log(`   ${assistantBlocks.length} assistant messages`);\n\n    for (const block of assistantBlocks) {\n      if (totalExtractions \u003e= limit) break;\n      if (block.length \u003c 100) continue;\n\n      totalMessages++;\n      const extractions = extractDecisions(block);\n\n      const newExtractions = extractions.filter((e) =\u003e {\n        const key = e.content.slice(0, 80).toLowerCase();\n        if (existingExtractions.has(key)) {\n          skippedDuplicates++;\n          return false;\n        }\n        existingExtractions.add(key);\n        return true;\n      });\n\n      if (newExtractions.length === 0) continue;\n\n      if (dryRun) {\n        if (full) {\n          console.log(chalk.gray(`   [full] ${block.slice(0, 80)}...`));\n        }\n        for (const ext of newExtractions) {\n          console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n          totalExtractions++;\n        }\n      } else {\n        // Store full content if --full flag is set, otherwise just metadata\n        const rawContent = full ? block : JSON.stringify({ imported: true, source: fileName });\n        const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'aider', rawContent, new Date().toISOString());\n\n        const conversationId = result.lastInsertRowid;\n\n        for (const ext of newExtractions) {\n          db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'aider' }));\n          totalExtractions++;\n        }\n      }\n    }\n\n    if (totalExtractions \u003e= limit) break;\n  }\n\n  return { source: 'aider', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":8}},{"data":{"id":"structure:5466","label":"findAiderHistoryFiles","type":"function","file":"src/cli/commands/import.ts","line":285,"signature":"function findAiderHistoryFiles(projectPath: string)","content":"function findAiderHistoryFiles(projectPath: string): string[] {\n  const files: string[] = [];\n\n  // Check for .aider.chat.history.md in project root\n  const historyFile = join(projectPath, '.aider.chat.history.md');\n  if (existsSync(historyFile)) {\n    files.push(historyFile);\n  }\n\n  // Also check for .aider.input.history and .aider.tags.cache.v3 patterns\n  try {\n    const projectFiles = readdirSync(projectPath);\n    for (const f of projectFiles) {\n      if (f.startsWith('.aider') \u0026\u0026 f.includes('history') \u0026\u0026 f.endsWith('.md')) {\n        const fullPath = join(projectPath, f);\n        if (!files.includes(fullPath)) {\n          files.push(fullPath);\n        }\n      }\n    }\n  } catch {\n    // Ignore read errors\n  }\n\n  return files;\n}","weight":4}},{"data":{"id":"structure:5469","label":"getContinueSessionsDir","type":"function","file":"src/cli/commands/import.ts","line":450,"signature":"function getContinueSessionsDir()","content":"function getContinueSessionsDir(): string {\n  return join(homedir(), '.continue', 'sessions');\n}","weight":4}},{"data":{"id":"structure:5470","label":"importFromContinue","type":"function","file":"src/cli/commands/import.ts","line":461,"signature":"function importFromContinue(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n)","content":"async function importFromContinue(\n  projectPath: string,\n  projectId: number,\n  existingExtractions: Set\u003cstring\u003e,\n  dryRun: boolean,\n  limit: number,\n  full: boolean = false\n): Promise\u003cImportResult | null\u003e {\n  const sessionsDir = getContinueSessionsDir();\n\n  if (!existsSync(sessionsDir)) {\n    return null;\n  }\n\n  console.log(chalk.bold('\\nüìÅ Continue.dev'));\n  console.log(`   ${chalk.gray(sessionsDir)}`);\n\n  const db = getDb();\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let skippedDuplicates = 0;\n\n  try {\n    const files = readdirSync(sessionsDir).filter((f) =\u003e f.endsWith('.json'));\n\n    if (files.length === 0) {\n      console.log(chalk.gray('   No session files found'));\n      return null;\n    }\n\n    console.log(`   Found ${files.length} session files`);\n\n    for (const file of files) {\n      if (totalExtractions \u003e= limit) break;\n\n      try {\n        const content = readFileSync(join(sessionsDir, file), 'utf-8');\n        const session = JSON.parse(content) as ContinueSession;\n\n        if (!session.history || !Array.isArray(session.history)) continue;\n\n        const assistantMessages = session.history.filter((m) =\u003e m.role === 'assistant' \u0026\u0026 m.content);\n\n        for (const msg of assistantMessages) {\n          if (totalExtractions \u003e= limit) break;\n          if (msg.content.length \u003c 100) continue;\n\n          totalMessages++;\n          const extractions = extractDecisions(msg.content);\n\n          const newExtractions = extractions.filter((e) =\u003e {\n            const key = e.content.slice(0, 80).toLowerCase();\n            if (existingExtractions.has(key)) {\n              skippedDuplicates++;\n              return false;\n            }\n            existingExtractions.add(key);\n            return true;\n          });\n\n          if (newExtractions.length === 0) continue;\n\n          if (dryRun) {\n            if (full) {\n              console.log(chalk.gray(`   [full] ${msg.content.slice(0, 80)}...`));\n            }\n            for (const ext of newExtractions) {\n              console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n              totalExtractions++;\n            }\n          } else {\n            // Store full content if --full flag is set, otherwise just metadata\n            const rawContent = full ? msg.content : JSON.stringify({ imported: true, source: file });\n            const result = db.prepare(`\n              INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n              VALUES (?, ?, ?, ?, ?)\n            `).run(projectId, 'imported', 'continue', rawContent, new Date().toISOString());\n\n            const conversationId = result.lastInsertRowid;\n\n            for (const ext of newExtractions) {\n              db.prepare(`\n                INSERT INTO extractions (conversation_id, type, content, metadata)\n                VALUES (?, ?, ?, ?)\n              `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'continue' }));\n              totalExtractions++;\n            }\n          }\n        }\n      } catch {\n        // Skip invalid files\n      }\n    }\n  } catch {\n    return null;\n  }\n\n  if (totalMessages === 0) {\n    return null;\n  }\n\n  return { source: 'continue', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":7}},{"data":{"id":"structure:5471","label":"importCommand","type":"function","file":"src/cli/commands/import.ts","line":569,"signature":"function importCommand(options: ImportOptions)","content":"export async function importCommand(options: ImportOptions): Promise\u003cvoid\u003e {\n  ensureDataDir();\n  const db = getDb();\n\n  const projectPath = options.project || process.cwd();\n  const source = options.source || 'all';\n  const dryRun = options.dryRun || false;\n  const limit = options.limit || 1000;\n  const full = options.full || false;\n\n  console.log(chalk.bold('Importing conversation history...\\n'));\n\n  // Find the aimem project\n  const aimemProject = getProjectByPath(projectPath);\n  if (!aimemProject) {\n    console.log(chalk.red(`Project not indexed: ${projectPath}`));\n    console.log(chalk.yellow('Run `aimem init` first to index this project.'));\n    process.exit(1);\n  }\n\n  console.log(`Project: ${chalk.cyan(aimemProject.path)}`);\n  console.log(`Source:  ${chalk.cyan(source)}`);\n  if (dryRun) console.log(chalk.yellow('Mode:    dry-run'));\n  if (full) console.log(chalk.green('Mode:    full (storing complete conversation content)'));\n\n  // Load existing extractions to avoid duplicates\n  const existingExtractions = new Set\u003cstring\u003e();\n  const existingRows = db.prepare(`\n    SELECT e.content FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE c.project_id = ?\n  `).all(aimemProject.id) as Array\u003c{ content: string }\u003e;\n\n  for (const row of existingRows) {\n    existingExtractions.add(row.content.slice(0, 80).toLowerCase());\n  }\n\n  console.log(`Existing extractions: ${existingExtractions.size}`);\n\n  const results: ImportResult[] = [];\n\n  // Import from selected sources\n  if (source === 'all' || source === 'claude') {\n    const result = await importFromClaude(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  if (source === 'all' || source === 'aider') {\n    const result = await importFromAider(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  if (source === 'all' || source === 'continue') {\n    const result = await importFromContinue(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n    if (result) results.push(result);\n  }\n\n  // Summary\n  console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ'));\n\n  if (results.length === 0) {\n    console.log(chalk.yellow('No conversation history found for any source.'));\n    console.log(chalk.gray('\\nSupported sources:'));\n    console.log(chalk.gray('  - Claude Code: ~/.claude/projects/'));\n    console.log(chalk.gray('  - Aider: .aider.chat.history.md in project'));\n    console.log(chalk.gray('  - Continue.dev: ~/.continue/sessions/'));\n    return;\n  }\n\n  let totalMessages = 0;\n  let totalExtractions = 0;\n  let totalDuplicates = 0;\n\n  for (const r of results) {\n    console.log(`\\n${chalk.cyan(r.source)}:`);\n    console.log(`  Messages:    ${r.messages}`);\n    console.log(`  Extractions: ${chalk.green(r.extractions)}`);\n    console.log(`  Duplicates:  ${r.duplicates}`);\n    totalMessages += r.messages;\n    totalExtractions += r.extractions;\n    totalDuplicates += r.duplicates;\n  }\n\n  console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Total ‚îÅ‚îÅ‚îÅ'));\n  console.log(`Messages:    ${totalMessages}`);\n  console.log(`Extractions: ${chalk.green(totalExtractions)}`);\n  console.log(`Duplicates:  ${totalDuplicates}`);\n\n  if (dryRun) {\n    console.log(chalk.yellow('\\nDry run - no changes made. Remove --dry-run to import.'));\n  } else if (totalExtractions \u003e 0) {\n    console.log(chalk.green('\\nImport complete!'));\n    console.log(chalk.gray('Query with: aimem_decisions \u003ctopic\u003e'));\n  }\n}","weight":8}},{"data":{"id":"structure:5484","label":"findBlockEnd","type":"function","file":"src/indexer/parsers/javascript.ts","line":25,"signature":"function findBlockEnd(content: string, startPos: number)","content":"function findBlockEnd(content: string, startPos: number): number {\n  let depth = 0;\n  let inString = false;\n  let stringChar = '';\n  let i = startPos;\n\n  // Find opening brace\n  while (i \u003c content.length \u0026\u0026 content[i] !== '{') i++;\n  if (i \u003e= content.length) return content.length;\n\n  // Find matching closing brace\n  for (; i \u003c content.length; i++) {\n    const char = content[i];\n    const prevChar = i \u003e 0 ? content[i - 1] : '';\n\n    if (inString) {\n      if (char === stringChar \u0026\u0026 prevChar !== '\\\\') {\n        inString = false;\n      }\n      continue;\n    }\n\n    if (char === '\"' || char === \"'\" || char === '`') {\n      inString = true;\n      stringChar = char;\n      continue;\n    }\n\n    if (char === '{') depth++;\n    if (char === '}') {\n      depth--;\n      if (depth === 0) return i + 1;\n    }\n  }\n\n  return content.length;\n}\n\nexport const javascriptParser: Parser = {\n  extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\n\n  parse(content: string, filePath: string): ParsedStructure[] {\n    const structures: ParsedStructure[] = [];\n    const lines = content.split('\\n');\n\n    // Parse functions\n    let match;\n    patterns.function.lastIndex = 0;\n    while ((match = patterns.function.exec(content)) !== null) {\n      const name = match[1];\n      const params = match[2];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n      const rawContent = extractLines(content, lineStart, lineEnd);\n\n      structures.push({\n        type: 'function',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `function ${name}(${params})`,\n        rawContent,\n        metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n        calls: extractCalls(rawContent, name),\n      });\n    }\n\n    // Parse arrow functions\n    patterns.arrowFunction.lastIndex = 0;\n    while ((match = patterns.arrowFunction.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n      const rawContent = extractLines(content, lineStart, lineEnd);\n\n      structures.push({\n        type: 'function',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `const ${name} = () =\u003e ...`,\n        rawContent,\n        metadata: { arrow: true },\n        calls: extractCalls(rawContent, name),\n      });\n    }\n\n    // Parse classes\n    patterns.class.lastIndex = 0;\n    while ((match = patterns.class.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n\n      structures.push({\n        type: 'class',\n        name,\n        lineStart,\n        lineEnd,\n        signature: match[0].trim(),\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    // Parse interfaces\n    patterns.interface.lastIndex = 0;\n    while ((match = patterns.interface.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n\n      structures.push({\n        type: 'interface',\n        name,\n        lineStart,\n        lineEnd,\n        signature: match[0].trim(),\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    // Parse type aliases\n    patterns.typeAlias.lastIndex = 0;\n    while ((match = patterns.typeAlias.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      // Type aliases end at semicolon or next line with different indent\n      let lineEnd = lineStart;\n      for (let i = lineStart; i \u003c lines.length; i++) {\n        if (lines[i].includes(';') || (i \u003e lineStart \u0026\u0026 !lines[i].startsWith(' ') \u0026\u0026 !lines[i].startsWith('\\t'))) {\n          lineEnd = i + 1;\n          break;\n        }\n      }\n\n      structures.push({\n        type: 'type',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `type ${name}`,\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    return structures;\n  },\n};\n","weight":3}},{"data":{"id":"structure:5491","label":"getLineNumber","type":"function","file":"src/indexer/parsers/base.ts","line":20,"signature":"function getLineNumber(content: string, position: number)","content":"export function getLineNumber(content: string, position: number): number {\n  return content.slice(0, position).split('\\n').length;\n}","weight":2}},{"data":{"id":"structure:5492","label":"extractLines","type":"function","file":"src/indexer/parsers/base.ts","line":25,"signature":"function extractLines(content: string, startLine: number, endLine: number)","content":"export function extractLines(content: string, startLine: number, endLine: number): string {\n  const lines = content.split('\\n');\n  return lines.slice(startLine - 1, endLine).join('\\n');\n}","weight":2}},{"data":{"id":"structure:5493","label":"extractCalls","type":"function","file":"src/indexer/parsers/base.ts","line":32,"signature":"function extractCalls(code: string, ownName: string)","content":"export function extractCalls(code: string, ownName: string): string[] {\n  const calls = new Set\u003cstring\u003e();\n\n  // Match function calls: identifier( or identifier.method(\n  // Excludes: keywords, string literals, comments\n  const callPattern = /\\b([a-zA-Z_]\\w*)\\s*\\(/g;\n\n  // Common keywords to exclude (cross-language)\n  const keywords = new Set([\n    // JS/TS\n    'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'try', 'catch', 'finally',\n    'function', 'async', 'await', 'return', 'throw', 'new', 'typeof', 'instanceof',\n    'class', 'interface', 'type', 'enum', 'import', 'export', 'from', 'as',\n    // Python\n    'def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except', 'finally',\n    'with', 'as', 'import', 'from', 'return', 'yield', 'raise', 'pass', 'lambda',\n    'and', 'or', 'not', 'in', 'is', 'True', 'False', 'None', 'assert', 'print',\n    // Go\n    'func', 'if', 'else', 'for', 'switch', 'case', 'select', 'go', 'defer',\n    'return', 'break', 'continue', 'goto', 'fallthrough', 'range', 'type', 'struct',\n    'interface', 'map', 'chan', 'make', 'new', 'append', 'len', 'cap', 'panic', 'recover',\n    // Ruby\n    'def', 'class', 'module', 'if', 'elsif', 'else', 'unless', 'case', 'when',\n    'while', 'until', 'for', 'do', 'begin', 'rescue', 'ensure', 'end', 'return',\n    'yield', 'raise', 'require', 'include', 'extend', 'attr_reader', 'attr_writer',\n  ]);\n\n  let match;\n  while ((match = callPattern.exec(code)) !== null) {\n    const name = match[1];\n    // Exclude keywords, the function's own name, and very short names\n    if (!keywords.has(name) \u0026\u0026 name !== ownName \u0026\u0026 name.length \u003e 1) {\n      calls.add(name);\n    }\n  }\n\n  return Array.from(calls);\n}\n","weight":1}},{"data":{"id":"structure:5496","label":"stopService","type":"function","file":"dist-test/src/cli/commands/stop.js","line":5,"signature":"function stopService(name)","content":"function stopService(name) {\n    const pidFile = join(getDataDir(), `${name}.pid`);\n    if (!existsSync(pidFile)) {\n        return false;\n    }\n    try {\n        const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n        // Try to kill the process\n        try {\n            process.kill(pid, 'SIGTERM');\n            console.log(chalk.green(`Stopped ${name} (PID ${pid})`));\n        }\n        catch {\n            console.log(chalk.gray(`${name} was not running`));\n        }\n        // Remove PID file\n        unlinkSync(pidFile);\n        return true;\n    }\n    catch (err) {\n        console.log(chalk.red(`Error stopping ${name}: ${err}`));\n        return false;\n    }\n}","weight":1}},{"data":{"id":"structure:5497","label":"stopCommand","type":"function","file":"dist-test/src/cli/commands/stop.js","line":29,"signature":"function stopCommand(options)","content":"export function stopCommand(options) {\n    const stopProxy = options.proxy !== false;\n    const stopWatcher = options.watcher !== false;\n    console.log(chalk.bold('Stopping aimem services...\\n'));\n    let stopped = 0;\n    if (stopProxy) {\n        if (stopService('proxy'))\n            stopped++;\n    }\n    if (stopWatcher) {\n        if (stopService('watcher'))\n            stopped++;\n    }\n    if (stopped === 0) {\n        console.log(chalk.gray('No services were running'));\n    }\n}","weight":1}},{"data":{"id":"structure:5499","label":"getServiceStatus","type":"function","file":"dist-test/src/cli/commands/status.js","line":19,"signature":"function getServiceStatus(name)","content":"function getServiceStatus(name) {\n    const pidFile = join(getDataDir(), `${name}.pid`);\n    if (!existsSync(pidFile)) {\n        return { running: false };\n    }\n    try {\n        const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n        // Check if process is running\n        process.kill(pid, 0);\n        return { running: true, pid };\n    }\n    catch {\n        return { running: false };\n    }\n}","weight":1}},{"data":{"id":"structure:5500","label":"statusCommand","type":"function","file":"dist-test/src/cli/commands/status.js","line":34,"signature":"function statusCommand()","content":"export function statusCommand() {\n    const dataDir = getDataDir();\n    console.log(chalk.bold('aimem status\\n'));\n    // Data directory\n    console.log(chalk.gray(`Data directory: ${dataDir}`));\n    console.log();\n    // Dependencies\n    const mitmproxyOk = isMitmproxyInstalled();\n    if (!mitmproxyOk) {\n        console.log(chalk.bold('Dependencies:'));\n        console.log(`  mitmproxy: ${chalk.red('not installed')} ${chalk.gray('(pip install mitmproxy)')}`);\n        console.log();\n    }\n    // Services\n    console.log(chalk.bold('Services:'));\n    const proxy = getServiceStatus('proxy');\n    const watcher = getServiceStatus('watcher');\n    console.log(`  Proxy:   ${proxy.running ? chalk.green(`running (PID ${proxy.pid})`) : chalk.gray('stopped')}`);\n    console.log(`  Watcher: ${watcher.running ? chalk.green(`running (PID ${watcher.pid})`) : chalk.gray('stopped')}`);\n    console.log();\n    // Database stats\n    console.log(chalk.bold('Database:'));\n    try {\n        const stats = getStats();\n        console.log(`  Projects:      ${chalk.cyan(stats.projects)}`);\n        console.log(`  Files:         ${chalk.cyan(stats.files)}`);\n        console.log(`  Structures:    ${chalk.cyan(stats.structures)}`);\n        console.log(`  Conversations: ${chalk.cyan(stats.conversations)}`);\n        console.log(`  Links:         ${chalk.cyan(stats.links)}`);\n    }\n    catch (err) {\n        console.log(chalk.gray('  (no database yet)'));\n    }\n    console.log();\n    // Projects\n    console.log(chalk.bold('Projects:'));\n    try {\n        const projects = getAllProjects();\n        if (projects.length === 0) {\n            console.log(chalk.gray('  (none)'));\n        }\n        else {\n            for (const p of projects) {\n                console.log(`  ${chalk.cyan(p.name)} - ${chalk.gray(p.path)}`);\n            }\n        }\n    }\n    catch {\n        console.log(chalk.gray('  (no database yet)'));\n    }\n}","weight":5}},{"data":{"id":"structure:5503","label":"getServicePid","type":"function","file":"dist-test/src/cli/commands/start.js","line":30,"signature":"function getServicePid(name)","content":"function getServicePid(name) {\n    const pidFile = join(getDataDir(), `${name}.pid`);\n    if (!existsSync(pidFile))\n        return null;\n    try {\n        const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);\n        return isProcessRunning(pid) ? pid : null;\n    }\n    catch {\n        return null;\n    }\n}","weight":2}},{"data":{"id":"structure:5504","label":"writePidFile","type":"function","file":"dist-test/src/cli/commands/start.js","line":42,"signature":"function writePidFile(name, pid)","content":"function writePidFile(name, pid) {\n    const pidFile = join(getDataDir(), `${name}.pid`);\n    writeFileSync(pidFile, String(pid));\n}","weight":1}},{"data":{"id":"structure:5505","label":"startCommand","type":"function","file":"dist-test/src/cli/commands/start.js","line":46,"signature":"function startCommand(options)","content":"export async function startCommand(options) {\n    ensureDataDir();\n    const dataDir = getDataDir();\n    const startProxy = options.proxy !== false;\n    const startWatcher = options.watcher !== false;\n    const port = options.port || 8080;\n    console.log(chalk.bold('Starting aimem services...\\n'));\n    // Start proxy\n    if (startProxy) {\n        const existingPid = getServicePid('proxy');\n        if (existingPid) {\n            console.log(chalk.yellow(`Proxy already running (PID ${existingPid})`));\n        }\n        else if (!isMitmproxyInstalled()) {\n            console.log(chalk.red('‚úó mitmproxy is not installed'));\n            console.log(chalk.yellow('\\n  mitmproxy is required for context capture. Install it with:\\n'));\n            console.log(chalk.white('    pip install mitmproxy\\n'));\n            console.log(chalk.gray('  After installing, run `aimem start` again.'));\n        }\n        else {\n            const interceptorPath = join(__dirname, '..', '..', 'proxy', 'interceptor.py');\n            try {\n                const child = spawn('mitmdump', [\n                    '-s', interceptorPath,\n                    '-p', String(port),\n                    '--set', `data_dir=${dataDir}`,\n                ], {\n                    detached: true,\n                    stdio: 'ignore',\n                });\n                if (child.pid) {\n                    writePidFile('proxy', child.pid);\n                    child.unref();\n                    console.log(chalk.green(`Proxy started on port ${port} (PID ${child.pid})`));\n                    console.log(chalk.gray(`  Configure tools with: HTTP_PROXY=http://localhost:${port}`));\n                }\n            }\n            catch (err) {\n                console.log(chalk.red('Failed to start proxy.'));\n                console.log(chalk.gray('  Check mitmproxy installation: pip install mitmproxy'));\n            }\n        }\n    }\n    // Start watcher\n    if (startWatcher) {\n        const existingPid = getServicePid('watcher');\n        if (existingPid) {\n            console.log(chalk.yellow(`Watcher already running (PID ${existingPid})`));\n        }\n        else {\n            const watcherPath = join(__dirname, '..', '..', 'indexer', 'watcher-daemon.js');\n            const child = spawn('node', [watcherPath], {\n                detached: true,\n                stdio: 'ignore',\n                env: { ...process.env, AIMEM_DATA_DIR: dataDir },\n            });\n            if (child.pid) {\n                writePidFile('watcher', child.pid);\n                child.unref();\n                console.log(chalk.green(`Watcher started (PID ${child.pid})`));\n            }\n        }\n    }\n    console.log(chalk.gray('\\nUse `aimem status` to check service status'));\n    console.log(chalk.gray('Use `aimem stop` to stop services'));\n}","weight":5}},{"data":{"id":"structure:5515","label":"addToShellProfile","type":"function","file":"dist-test/src/cli/commands/setup.js","line":251,"signature":"function addToShellProfile(profilePath, port, certPath)","content":"function addToShellProfile(profilePath, port, certPath) {\n    const marker = '# aimem proxy configuration';\n    // Build env block with proper Node.js SSL handling\n    let envBlock = `\n${marker}\nexport HTTP_PROXY=http://localhost:${port}\nexport HTTPS_PROXY=http://localhost:${port}\n`;\n    // Add Node.js cert configuration\n    if (certPath) {\n        envBlock += `export NODE_EXTRA_CA_CERTS=\"${certPath}\"\n`;\n    }\n    // Fallback for apps that don't respect NODE_EXTRA_CA_CERTS\n    envBlock += `export NODE_TLS_REJECT_UNAUTHORIZED=0\n`;\n    try {\n        let content = '';\n        if (existsSync(profilePath)) {\n            content = readFileSync(profilePath, 'utf-8');\n            // Check if already configured\n            if (content.includes(marker)) {\n                console.log(chalk.yellow(`Shell profile already configured: ${profilePath}`));\n                return true;\n            }\n        }\n        // Append to profile\n        writeFileSync(profilePath, content + envBlock);\n        console.log(chalk.green(`Added proxy environment to: ${profilePath}`));\n        return true;\n    }\n    catch (err) {\n        console.log(chalk.red(`Failed to update shell profile: ${profilePath}`));\n        return false;\n    }\n}\nexport async function setupCommand(tool, options) {\n    const supportedTools = ['claude-code', 'proxy', 'cursor', 'continue'];\n    if (!tool) {\n        console.log(chalk.bold('aimem setup\\n'));\n        console.log('Automatically configure aimem for AI coding tools.\\n');\n        console.log('Usage:');\n        console.log('  aimem setup claude-code    Configure for Claude Code (MCP server)');\n        console.log('  aimem setup proxy          Configure proxy for any tool (Cursor, etc.)');\n        console.log('  aimem setup cursor         Show Cursor configuration instructions');\n        console.log('  aimem setup continue       Show Continue.dev configuration instructions\\n');\n        console.log('Supported tools:', supportedTools.join(', '));\n        return;\n    }\n    if (!supportedTools.includes(tool)) {\n        console.log(chalk.red(`Unknown tool: ${tool}`));\n        console.log('Supported tools:', supportedTools.join(', '));\n        process.exit(1);\n    }\n    if (tool === 'claude-code') {\n        await setupClaudeCode(options);\n    }\n    else if (tool === 'proxy') {\n        await setupProxy(options);\n    }\n    else if (tool === 'cursor') {\n        await setupCursor(options);\n    }\n    else if (tool === 'continue') {\n        await setupContinue(options);\n    }\n}\nasync function setupClaudeCode(options) {\n    console.log(chalk.bold('Setting up aimem for Claude Code...\\n'));\n    const aimemPath = getAimemPath();\n    console.log(`Found aimem at: ${chalk.cyan(aimemPath)}`);\n    // Claude Code settings file location\n    const claudeDir = join(homedir(), '.claude');\n    const settingsPath = join(claudeDir, 'settings.json');\n    // Read existing settings or create new\n    let settings = {};\n    const existingSettings = readJsonFile(settingsPath);\n    if (existingSettings) {\n        settings = existingSettings;\n        console.log(`Found existing settings at: ${chalk.cyan(settingsPath)}`);\n    }\n    else {\n        console.log(`Creating new settings file at: ${chalk.cyan(settingsPath)}`);\n    }\n    // Track what we're changing\n    const changes = [];\n    // Configure MCP server (for query tools)\n    if (!settings.mcpServers) {\n        settings.mcpServers = {};\n    }\n    if (!settings.mcpServers.aimem || options.force) {\n        settings.mcpServers.aimem = {\n            command: aimemPath,\n            args: ['mcp-serve'],\n        };\n        changes.push('Added aimem MCP server (query tools)');\n    }\n    else {\n        console.log(chalk.yellow('MCP server already configured (use --force to overwrite)'));\n    }\n    // Write settings\n    if (changes.length \u003e 0) {\n        writeJsonFile(settingsPath, settings);\n        console.log(chalk.green('\\nConfiguration updated:'));\n        for (const change of changes) {\n            console.log(chalk.green(`  ‚úì ${change}`));\n        }\n    }\n    else {\n        console.log(chalk.green('\\nMCP server already configured.'));\n    }\n    console.log(chalk.bold('\\nNext steps:'));\n    console.log('  1. Restart Claude Code to load the MCP server');\n    console.log('  2. Set up the proxy for context capture:');\n    console.log(chalk.cyan('     aimem setup proxy --install'));\n    console.log('  3. Start the proxy before using Claude Code:');\n    console.log(chalk.cyan('     aimem start'));\n    console.log('  4. Run `aimem init` in your project directory to index it\\n');\n    console.log(chalk.yellow('Note: The proxy captures decisions in real-time and injects'));\n    console.log(chalk.yellow('context into requests. MCP provides query tools.\\n'));\n}","weight":8}},{"data":{"id":"structure:5516","label":"setupCommand","type":"function","file":"dist-test/src/cli/commands/setup.js","line":287,"signature":"function setupCommand(tool, options)","content":"export async function setupCommand(tool, options) {\n    const supportedTools = ['claude-code', 'proxy', 'cursor', 'continue'];\n    if (!tool) {\n        console.log(chalk.bold('aimem setup\\n'));\n        console.log('Automatically configure aimem for AI coding tools.\\n');\n        console.log('Usage:');\n        console.log('  aimem setup claude-code    Configure for Claude Code (MCP server)');\n        console.log('  aimem setup proxy          Configure proxy for any tool (Cursor, etc.)');\n        console.log('  aimem setup cursor         Show Cursor configuration instructions');\n        console.log('  aimem setup continue       Show Continue.dev configuration instructions\\n');\n        console.log('Supported tools:', supportedTools.join(', '));\n        return;\n    }\n    if (!supportedTools.includes(tool)) {\n        console.log(chalk.red(`Unknown tool: ${tool}`));\n        console.log('Supported tools:', supportedTools.join(', '));\n        process.exit(1);\n    }\n    if (tool === 'claude-code') {\n        await setupClaudeCode(options);\n    }\n    else if (tool === 'proxy') {\n        await setupProxy(options);\n    }\n    else if (tool === 'cursor') {\n        await setupCursor(options);\n    }\n    else if (tool === 'continue') {\n        await setupContinue(options);\n    }\n}","weight":4}},{"data":{"id":"structure:5517","label":"setupClaudeCode","type":"function","file":"dist-test/src/cli/commands/setup.js","line":318,"signature":"function setupClaudeCode(options)","content":"async function setupClaudeCode(options) {\n    console.log(chalk.bold('Setting up aimem for Claude Code...\\n'));\n    const aimemPath = getAimemPath();\n    console.log(`Found aimem at: ${chalk.cyan(aimemPath)}`);\n    // Claude Code settings file location\n    const claudeDir = join(homedir(), '.claude');\n    const settingsPath = join(claudeDir, 'settings.json');\n    // Read existing settings or create new\n    let settings = {};\n    const existingSettings = readJsonFile(settingsPath);\n    if (existingSettings) {\n        settings = existingSettings;\n        console.log(`Found existing settings at: ${chalk.cyan(settingsPath)}`);\n    }\n    else {\n        console.log(`Creating new settings file at: ${chalk.cyan(settingsPath)}`);\n    }\n    // Track what we're changing\n    const changes = [];\n    // Configure MCP server (for query tools)\n    if (!settings.mcpServers) {\n        settings.mcpServers = {};\n    }\n    if (!settings.mcpServers.aimem || options.force) {\n        settings.mcpServers.aimem = {\n            command: aimemPath,\n            args: ['mcp-serve'],\n        };\n        changes.push('Added aimem MCP server (query tools)');\n    }\n    else {\n        console.log(chalk.yellow('MCP server already configured (use --force to overwrite)'));\n    }\n    // Write settings\n    if (changes.length \u003e 0) {\n        writeJsonFile(settingsPath, settings);\n        console.log(chalk.green('\\nConfiguration updated:'));\n        for (const change of changes) {\n            console.log(chalk.green(`  ‚úì ${change}`));\n        }\n    }\n    else {\n        console.log(chalk.green('\\nMCP server already configured.'));\n    }\n    console.log(chalk.bold('\\nNext steps:'));\n    console.log('  1. Restart Claude Code to load the MCP server');\n    console.log('  2. Set up the proxy for context capture:');\n    console.log(chalk.cyan('     aimem setup proxy --install'));\n    console.log('  3. Start the proxy before using Claude Code:');\n    console.log(chalk.cyan('     aimem start'));\n    console.log('  4. Run `aimem init` in your project directory to index it\\n');\n    console.log(chalk.yellow('Note: The proxy captures decisions in real-time and injects'));\n    console.log(chalk.yellow('context into requests. MCP provides query tools.\\n'));\n}\nasync function setupProxy(options) {\n    console.log(chalk.bold('Setting up aimem proxy...\\n'));\n    const port = options.port || '8080';\n    const install = options.install || false;\n    const autostart = options.autostart || false;\n    // Check for mitmproxy\n    const mitmdumpPath = getMitmdumpPath();\n    if (!mitmdumpPath) {\n        console.log(chalk.red('mitmproxy not found!\\n'));\n        console.log('Install mitmproxy first:');\n        console.log(chalk.cyan('  pip install mitmproxy\\n'));\n        process.exit(1);\n    }\n    console.log(`Found mitmdump at: ${chalk.cyan(mitmdumpPath)}`);\n    const platform = getPlatform();\n    console.log(`Detected platform: ${chalk.cyan(platform)}`);\n    // Create a startup script\n    const aimemPath = getAimemPath();\n    const startupScript = `#!/bin/bash\n# Start aimem proxy\n${aimemPath} start --port ${port}\n`;\n    const aimemDir = join(homedir(), '.aimem');\n    if (!existsSync(aimemDir)) {\n        mkdirSync(aimemDir, { recursive: true });\n    }\n    // Write startup script\n    const scriptPath = join(aimemDir, 'start-proxy.sh');\n    writeFileSync(scriptPath, startupScript, { mode: 0o755 });\n    // Write profile snippet (for manual sourcing)\n    const profileAdditions = `\n# aimem proxy configuration\nexport HTTP_PROXY=http://localhost:${port}\nexport HTTPS_PROXY=http://localhost:${port}\n# Uncomment if needed for Node.js apps with self-signed certs:\n# export NODE_TLS_REJECT_UNAUTHORIZED=0\n`;\n    const profileSnippetPath = join(aimemDir, 'proxy-env.sh');\n    writeFileSync(profileSnippetPath, profileAdditions);\n    console.log(chalk.green('\\nFiles created:'));\n    console.log(`  ${chalk.cyan(scriptPath)} - Start proxy script`);\n    console.log(`  ${chalk.cyan(profileSnippetPath)} - Environment variables`);\n    if (install) {\n        // Full installation mode\n        console.log(chalk.bold('\\n--- Full Installation Mode ---\\n'));\n        // Step 1: Ensure certificate exists\n        const certPath = ensureMitmproxyCert();\n        if (!certPath) {\n            console.log(chalk.red('Could not find or generate mitmproxy certificate.'));\n            console.log(chalk.yellow('Start the proxy once with: aimem start'));\n            console.log(chalk.yellow('Then run: aimem setup proxy --install\\n'));\n            return;\n        }\n        console.log(chalk.green(`Certificate found: ${certPath}`));\n        // Step 2: Install certificate\n        await installCertificate(certPath, platform);\n        // Step 3: Add to shell profile\n        const profilePath = getShellProfile();\n        console.log(chalk.bold('\\nConfiguring shell environment...\\n'));\n        addToShellProfile(profilePath, port, certPath);\n        console.log(chalk.green(chalk.bold('\\n‚úì Proxy installation complete!\\n')));\n        console.log(chalk.bold('Next steps:'));\n        console.log('  1. Restart your terminal (or run: ' + chalk.cyan(`source ${profilePath}`) + ')');\n        console.log('  2. Start the proxy: ' + chalk.cyan('aimem start'));\n        console.log('  3. Your HTTP_PROXY and HTTPS_PROXY are now set automatically\\n');\n        if (platform === 'wsl') {\n            console.log(chalk.yellow('WSL Note: For Windows apps (like Cursor), you may need to:'));\n            console.log('  - Install the cert on Windows (see instructions above)');\n            console.log('  - Configure the proxy in the app settings manually\\n');\n        }\n        // Handle autostart if requested\n        if (autostart) {\n            setupAutostart(aimemPath, port, platform);\n        }\n        else {\n            console.log(chalk.cyan('Tip: Add --autostart to start the proxy automatically on login.\\n'));\n        }\n    }\n    else if (autostart) {\n        // Autostart without full install\n        setupAutostart(aimemPath, port, platform);\n    }\n    else {\n        // Manual setup instructions\n        console.log(chalk.bold('\\nTo use the proxy:\\n'));\n        console.log('Option A: ' + chalk.bold('Automatic setup (recommended)'));\n        console.log(chalk.cyan(`   aimem setup proxy --install\\n`));\n        console.log('Option B: ' + chalk.bold('Manual setup'));\n        console.log('  1. Start the proxy:');\n        console.log(chalk.cyan(`     aimem start --port ${port}\\n`));\n        console.log('  2. Trust the mitmproxy CA certificate:');\n        console.log(chalk.cyan('     # Visit http://mitm.it in browser (proxy must be running)'));\n        console.log(chalk.cyan('     # Or manually install from ~/.mitmproxy/mitmproxy-ca-cert.pem\\n'));\n        console.log('  3. Set environment variables (add to your shell profile):');\n        console.log(chalk.cyan(`     export HTTP_PROXY=http://localhost:${port}`));\n        console.log(chalk.cyan(`     export HTTPS_PROXY=http://localhost:${port}\\n`));\n        console.log('  4. Or source the env file:');\n        console.log(chalk.cyan(`     source ${profileSnippetPath}\\n`));\n    }\n    console.log(chalk.bold('Supported tools with proxy:'));\n    console.log('  - Cursor (set proxy in settings)');\n    console.log('  - Continue.dev (respects HTTP_PROXY)');\n    console.log('  - Any tool that respects HTTP_PROXY/HTTPS_PROXY\\n');\n    console.log(chalk.yellow('Note: The proxy intercepts API calls to:'));\n    console.log('  - api.anthropic.com');\n    console.log('  - api.openai.com');\n    console.log('  - localhost:11434 (Ollama)\\n');\n}\nasync function setupCursor(options) {\n    const port = options.port || '8080';\n    console.log(chalk.bold('Setting up aimem for Cursor...\\n'));\n    console.log('Cursor supports MCP servers. Add to your Cursor settings:\\n');\n    console.log(chalk.bold('Option 1: MCP Server (query only, no auto-capture)\\n'));\n    console.log('Add to Cursor settings.json:');\n    const aimemPath = getAimemPath();\n    console.log(chalk.cyan(`{\n  \"mcpServers\": {\n    \"aimem\": {\n      \"command\": \"${aimemPath}\",\n      \"args\": [\"mcp-serve\"]\n    }\n  }\n}\\n`));\n    console.log(chalk.bold('Option 2: Proxy mode (full capture + injection)\\n'));\n    console.log('1. Run: ' + chalk.cyan(`aimem setup proxy --port ${port}`));\n    console.log('2. Start proxy: ' + chalk.cyan('aimem start'));\n    console.log('3. In Cursor settings, set HTTP proxy to: ' + chalk.cyan(`http://localhost:${port}`));\n    console.log('4. Trust the mitmproxy CA certificate\\n');\n    console.log(chalk.yellow('Note: MCP mode provides query tools but won\\'t auto-capture decisions.'));\n    console.log('Use proxy mode for full context capture and injection.\\n');\n}","weight":12}},{"data":{"id":"structure:5436","label":"getMitmdumpPath","type":"function","file":"src/cli/commands/setup.ts","line":46,"signature":"function getMitmdumpPath()","content":"function getMitmdumpPath(): string | null {\n  try {\n    const result = execSync('which mitmdump', { encoding: 'utf-8' }).trim();\n    if (result) return result;\n  } catch {\n    // Not found\n  }\n  return null;\n}","weight":2}},{"data":{"id":"structure:5439","label":"getPlatform","type":"function","file":"src/cli/commands/setup.ts","line":74,"signature":"function getPlatform()","content":"function getPlatform(): 'linux' | 'macos' | 'windows' | 'wsl' {\n  const platform = process.platform;\n  if (platform === 'darwin') return 'macos';\n  if (platform === 'win32') return 'windows';\n  // Check for WSL\n  try {\n    const release = execSync('uname -r', { encoding: 'utf-8' }).toLowerCase();\n    if (release.includes('microsoft') || release.includes('wsl')) return 'wsl';\n  } catch {\n    // Ignore\n  }\n  return 'linux';\n}","weight":2}},{"data":{"id":"structure:5441","label":"ensureMitmproxyCert","type":"function","file":"src/cli/commands/setup.ts","line":100,"signature":"function ensureMitmproxyCert()","content":"function ensureMitmproxyCert(): string | null {\n  const certPath = join(homedir(), '.mitmproxy', 'mitmproxy-ca-cert.pem');\n\n  if (existsSync(certPath)) {\n    return certPath;\n  }\n\n  // Need to start mitmproxy once to generate certs\n  console.log(chalk.yellow('Generating mitmproxy certificates...'));\n  try {\n    // Start and immediately stop mitmproxy to generate certs\n    execSync('mitmdump --version', { encoding: 'utf-8' });\n    // Run mitmdump briefly in background to generate certs\n    execSync('timeout 2 mitmdump -p 0 2\u003e/dev/null || true', { encoding: 'utf-8' });\n\n    if (existsSync(certPath)) {\n      return certPath;\n    }\n  } catch {\n    // Ignore\n  }\n\n  return null;\n}","weight":2}},{"data":{"id":"structure:5442","label":"installCertificate","type":"function","file":"src/cli/commands/setup.ts","line":125,"signature":"function installCertificate(certPath: string, platform: string)","content":"async function installCertificate(certPath: string, platform: string): Promise\u003cboolean\u003e {\n  console.log(chalk.bold('\\nInstalling CA certificate...\\n'));\n\n  try {\n    if (platform === 'macos') {\n      console.log('Adding certificate to macOS keychain (requires password)...');\n      execSync(`sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain \"${certPath}\"`, {\n        stdio: 'inherit',\n      });\n      return true;\n    }\n\n    if (platform === 'linux') {\n      const destPath = '/usr/local/share/ca-certificates/mitmproxy-ca-cert.crt';\n      console.log('Adding certificate to system CA store (requires sudo)...');\n      execSync(`sudo cp \"${certPath}\" \"${destPath}\" \u0026\u0026 sudo update-ca-certificates`, {\n        stdio: 'inherit',\n      });\n      return true;\n    }\n\n    if (platform === 'wsl') {\n      // For WSL, install to both Linux and Windows\n      const destPath = '/usr/local/share/ca-certificates/mitmproxy-ca-cert.crt';\n      console.log('Adding certificate to Linux CA store (requires sudo)...');\n      execSync(`sudo cp \"${certPath}\" \"${destPath}\" \u0026\u0026 sudo update-ca-certificates`, {\n        stdio: 'inherit',\n      });\n\n      console.log(chalk.yellow('\\nFor Windows applications, you also need to install the cert on Windows:'));\n      console.log(chalk.cyan(`  1. Open: ${certPath.replace(/^\\/mnt\\//, '').replace(/\\//g, '\\\\\\\\')}`));\n      console.log(chalk.cyan('  2. Or run in PowerShell (as admin):'));\n      console.log(chalk.cyan(`     certutil -addstore -f \"ROOT\" \"${certPath}\"`));\n      return true;\n    }\n\n    if (platform === 'windows') {\n      console.log('Adding certificate to Windows certificate store (requires admin)...');\n      execSync(`certutil -addstore -f \"ROOT\" \"${certPath}\"`, {\n        stdio: 'inherit',\n      });\n      return true;\n    }\n  } catch (err) {\n    console.log(chalk.red('Failed to install certificate automatically.'));\n    console.log(chalk.yellow(`\\nManually install the certificate from: ${certPath}`));\n    return false;\n  }\n\n  return false;\n}","weight":2}},{"data":{"id":"structure:5440","label":"getShellProfile","type":"function","file":"src/cli/commands/setup.ts","line":88,"signature":"function getShellProfile()","content":"function getShellProfile(): string {\n  const shell = process.env.SHELL || '/bin/bash';\n  const home = homedir();\n\n  if (shell.includes('zsh')) {\n    return join(home, '.zshrc');\n  } else if (shell.includes('fish')) {\n    return join(home, '.config/fish/config.fish');\n  }\n  return join(home, '.bashrc');\n}","weight":2}},{"data":{"id":"structure:5443","label":"setupAutostart","type":"function","file":"src/cli/commands/setup.ts","line":177,"signature":"function setupAutostart(aimemPath: string, port: string, platform: string)","content":"function setupAutostart(aimemPath: string, port: string, platform: string): boolean {\n  console.log(chalk.bold('\\nConfiguring autostart...\\n'));\n\n  if (platform === 'macos') {\n    // macOS: Use launchd\n    const plistDir = join(homedir(), 'Library', 'LaunchAgents');\n    const plistPath = join(plistDir, 'com.aimem.proxy.plist');\n\n    if (!existsSync(plistDir)) {\n      mkdirSync(plistDir, { recursive: true });\n    }\n\n    const plistContent = `\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e\n\u003cplist version=\"1.0\"\u003e\n\u003cdict\u003e\n  \u003ckey\u003eLabel\u003c/key\u003e\n  \u003cstring\u003ecom.aimem.proxy\u003c/string\u003e\n  \u003ckey\u003eProgramArguments\u003c/key\u003e\n  \u003carray\u003e\n    \u003cstring\u003e${aimemPath}\u003c/string\u003e\n    \u003cstring\u003estart\u003c/string\u003e\n    \u003cstring\u003e--port\u003c/string\u003e\n    \u003cstring\u003e${port}\u003c/string\u003e\n  \u003c/array\u003e\n  \u003ckey\u003eRunAtLoad\u003c/key\u003e\n  \u003ctrue/\u003e\n  \u003ckey\u003eKeepAlive\u003c/key\u003e\n  \u003cfalse/\u003e\n  \u003ckey\u003eStandardOutPath\u003c/key\u003e\n  \u003cstring\u003e${join(homedir(), '.aimem', 'proxy.log')}\u003c/string\u003e\n  \u003ckey\u003eStandardErrorPath\u003c/key\u003e\n  \u003cstring\u003e${join(homedir(), '.aimem', 'proxy.error.log')}\u003c/string\u003e\n\u003c/dict\u003e\n\u003c/plist\u003e\n`;\n\n    try {\n      writeFileSync(plistPath, plistContent);\n      // Load the service\n      execSync(`launchctl load \"${plistPath}\"`, { stdio: 'inherit' });\n      console.log(chalk.green(`Created launchd service: ${plistPath}`));\n      console.log(chalk.green('Proxy will start automatically on login.'));\n      return true;\n    } catch (err) {\n      console.log(chalk.red('Failed to set up launchd service.'));\n      console.log(chalk.yellow(`Manually load with: launchctl load \"${plistPath}\"`));\n      return false;\n    }\n  }\n\n  if (platform === 'linux' || platform === 'wsl') {\n    // Linux/WSL: Use systemd user service\n    const systemdDir = join(homedir(), '.config', 'systemd', 'user');\n    const servicePath = join(systemdDir, 'aimem-proxy.service');\n\n    if (!existsSync(systemdDir)) {\n      mkdirSync(systemdDir, { recursive: true });\n    }\n\n    const serviceContent = `[Unit]\nDescription=aimem proxy for AI coding assistants\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=${aimemPath} start --port ${port}\nRestart=on-failure\nRestartSec=5\nEnvironment=HOME=${homedir()}\n\n[Install]\nWantedBy=default.target\n`;\n\n    try {\n      writeFileSync(servicePath, serviceContent);\n      // Reload systemd and enable the service\n      execSync('systemctl --user daemon-reload', { stdio: 'inherit' });\n      execSync('systemctl --user enable aimem-proxy.service', { stdio: 'inherit' });\n      console.log(chalk.green(`Created systemd user service: ${servicePath}`));\n      console.log(chalk.green('Proxy will start automatically on login.'));\n      console.log(chalk.cyan('\\nManual control:'));\n      console.log('  Start now:  systemctl --user start aimem-proxy');\n      console.log('  Stop:       systemctl --user stop aimem-proxy');\n      console.log('  Status:     systemctl --user status aimem-proxy');\n      console.log('  Disable:    systemctl --user disable aimem-proxy');\n      return true;\n    } catch (err) {\n      console.log(chalk.red('Failed to set up systemd service.'));\n      console.log(chalk.yellow(`Service file created at: ${servicePath}`));\n      console.log(chalk.yellow('Manually enable with:'));\n      console.log(chalk.cyan('  systemctl --user daemon-reload'));\n      console.log(chalk.cyan('  systemctl --user enable aimem-proxy.service'));\n      return false;\n    }\n  }\n\n  console.log(chalk.yellow(`Autostart not supported on platform: ${platform}`));\n  return false;\n}","weight":2}},{"data":{"id":"structure:5518","label":"setupProxy","type":"function","file":"dist-test/src/cli/commands/setup.js","line":372,"signature":"function setupProxy(options)","content":"async function setupProxy(options) {\n    console.log(chalk.bold('Setting up aimem proxy...\\n'));\n    const port = options.port || '8080';\n    const install = options.install || false;\n    const autostart = options.autostart || false;\n    // Check for mitmproxy\n    const mitmdumpPath = getMitmdumpPath();\n    if (!mitmdumpPath) {\n        console.log(chalk.red('mitmproxy not found!\\n'));\n        console.log('Install mitmproxy first:');\n        console.log(chalk.cyan('  pip install mitmproxy\\n'));\n        process.exit(1);\n    }\n    console.log(`Found mitmdump at: ${chalk.cyan(mitmdumpPath)}`);\n    const platform = getPlatform();\n    console.log(`Detected platform: ${chalk.cyan(platform)}`);\n    // Create a startup script\n    const aimemPath = getAimemPath();\n    const startupScript = `#!/bin/bash\n# Start aimem proxy\n${aimemPath} start --port ${port}\n`;\n    const aimemDir = join(homedir(), '.aimem');\n    if (!existsSync(aimemDir)) {\n        mkdirSync(aimemDir, { recursive: true });\n    }\n    // Write startup script\n    const scriptPath = join(aimemDir, 'start-proxy.sh');\n    writeFileSync(scriptPath, startupScript, { mode: 0o755 });\n    // Write profile snippet (for manual sourcing)\n    const profileAdditions = `\n# aimem proxy configuration\nexport HTTP_PROXY=http://localhost:${port}\nexport HTTPS_PROXY=http://localhost:${port}\n# Uncomment if needed for Node.js apps with self-signed certs:\n# export NODE_TLS_REJECT_UNAUTHORIZED=0\n`;\n    const profileSnippetPath = join(aimemDir, 'proxy-env.sh');\n    writeFileSync(profileSnippetPath, profileAdditions);\n    console.log(chalk.green('\\nFiles created:'));\n    console.log(`  ${chalk.cyan(scriptPath)} - Start proxy script`);\n    console.log(`  ${chalk.cyan(profileSnippetPath)} - Environment variables`);\n    if (install) {\n        // Full installation mode\n        console.log(chalk.bold('\\n--- Full Installation Mode ---\\n'));\n        // Step 1: Ensure certificate exists\n        const certPath = ensureMitmproxyCert();\n        if (!certPath) {\n            console.log(chalk.red('Could not find or generate mitmproxy certificate.'));\n            console.log(chalk.yellow('Start the proxy once with: aimem start'));\n            console.log(chalk.yellow('Then run: aimem setup proxy --install\\n'));\n            return;\n        }\n        console.log(chalk.green(`Certificate found: ${certPath}`));\n        // Step 2: Install certificate\n        await installCertificate(certPath, platform);\n        // Step 3: Add to shell profile\n        const profilePath = getShellProfile();\n        console.log(chalk.bold('\\nConfiguring shell environment...\\n'));\n        addToShellProfile(profilePath, port, certPath);\n        console.log(chalk.green(chalk.bold('\\n‚úì Proxy installation complete!\\n')));\n        console.log(chalk.bold('Next steps:'));\n        console.log('  1. Restart your terminal (or run: ' + chalk.cyan(`source ${profilePath}`) + ')');\n        console.log('  2. Start the proxy: ' + chalk.cyan('aimem start'));\n        console.log('  3. Your HTTP_PROXY and HTTPS_PROXY are now set automatically\\n');\n        if (platform === 'wsl') {\n            console.log(chalk.yellow('WSL Note: For Windows apps (like Cursor), you may need to:'));\n            console.log('  - Install the cert on Windows (see instructions above)');\n            console.log('  - Configure the proxy in the app settings manually\\n');\n        }\n        // Handle autostart if requested\n        if (autostart) {\n            setupAutostart(aimemPath, port, platform);\n        }\n        else {\n            console.log(chalk.cyan('Tip: Add --autostart to start the proxy automatically on login.\\n'));\n        }\n    }\n    else if (autostart) {\n        // Autostart without full install\n        setupAutostart(aimemPath, port, platform);\n    }\n    else {\n        // Manual setup instructions\n        console.log(chalk.bold('\\nTo use the proxy:\\n'));\n        console.log('Option A: ' + chalk.bold('Automatic setup (recommended)'));\n        console.log(chalk.cyan(`   aimem setup proxy --install\\n`));\n        console.log('Option B: ' + chalk.bold('Manual setup'));\n        console.log('  1. Start the proxy:');\n        console.log(chalk.cyan(`     aimem start --port ${port}\\n`));\n        console.log('  2. Trust the mitmproxy CA certificate:');\n        console.log(chalk.cyan('     # Visit http://mitm.it in browser (proxy must be running)'));\n        console.log(chalk.cyan('     # Or manually install from ~/.mitmproxy/mitmproxy-ca-cert.pem\\n'));\n        console.log('  3. Set environment variables (add to your shell profile):');\n        console.log(chalk.cyan(`     export HTTP_PROXY=http://localhost:${port}`));\n        console.log(chalk.cyan(`     export HTTPS_PROXY=http://localhost:${port}\\n`));\n        console.log('  4. Or source the env file:');\n        console.log(chalk.cyan(`     source ${profileSnippetPath}\\n`));\n    }\n    console.log(chalk.bold('Supported tools with proxy:'));\n    console.log('  - Cursor (set proxy in settings)');\n    console.log('  - Continue.dev (respects HTTP_PROXY)');\n    console.log('  - Any tool that respects HTTP_PROXY/HTTPS_PROXY\\n');\n    console.log(chalk.yellow('Note: The proxy intercepts API calls to:'));\n    console.log('  - api.anthropic.com');\n    console.log('  - api.openai.com');\n    console.log('  - localhost:11434 (Ollama)\\n');\n}","weight":8}},{"data":{"id":"structure:5519","label":"setupCursor","type":"function","file":"dist-test/src/cli/commands/setup.js","line":480,"signature":"function setupCursor(options)","content":"async function setupCursor(options) {\n    const port = options.port || '8080';\n    console.log(chalk.bold('Setting up aimem for Cursor...\\n'));\n    console.log('Cursor supports MCP servers. Add to your Cursor settings:\\n');\n    console.log(chalk.bold('Option 1: MCP Server (query only, no auto-capture)\\n'));\n    console.log('Add to Cursor settings.json:');\n    const aimemPath = getAimemPath();\n    console.log(chalk.cyan(`{\n  \"mcpServers\": {\n    \"aimem\": {\n      \"command\": \"${aimemPath}\",\n      \"args\": [\"mcp-serve\"]\n    }\n  }\n}\\n`));\n    console.log(chalk.bold('Option 2: Proxy mode (full capture + injection)\\n'));\n    console.log('1. Run: ' + chalk.cyan(`aimem setup proxy --port ${port}`));\n    console.log('2. Start proxy: ' + chalk.cyan('aimem start'));\n    console.log('3. In Cursor settings, set HTTP proxy to: ' + chalk.cyan(`http://localhost:${port}`));\n    console.log('4. Trust the mitmproxy CA certificate\\n');\n    console.log(chalk.yellow('Note: MCP mode provides query tools but won\\'t auto-capture decisions.'));\n    console.log('Use proxy mode for full context capture and injection.\\n');\n}","weight":1}},{"data":{"id":"structure:5520","label":"setupContinue","type":"function","file":"dist-test/src/cli/commands/setup.js","line":503,"signature":"function setupContinue(options)","content":"async function setupContinue(options) {\n    const port = options.port || '8080';\n    console.log(chalk.bold('Setting up aimem for Continue.dev...\\n'));\n    const aimemPath = getAimemPath();\n    console.log(chalk.bold('Option 1: MCP Server (query only)\\n'));\n    console.log('Add to ~/.continue/config.json:');\n    console.log(chalk.cyan(`{\n  \"experimental\": {\n    \"mcpServers\": [\n      {\n        \"name\": \"aimem\",\n        \"command\": \"${aimemPath}\",\n        \"args\": [\"mcp-serve\"]\n      }\n    ]\n  }\n}\\n`));\n    console.log(chalk.bold('Option 2: Proxy mode (full capture)\\n'));\n    console.log('1. Run: ' + chalk.cyan(`aimem setup proxy --port ${port}`));\n    console.log('2. Start proxy: ' + chalk.cyan('aimem start'));\n    console.log('3. Set environment variables:');\n    console.log(chalk.cyan(`   export HTTP_PROXY=http://localhost:${port}`));\n    console.log(chalk.cyan(`   export HTTPS_PROXY=http://localhost:${port}`));\n    console.log('4. Start your IDE\\n');\n    console.log(chalk.yellow('Note: Continue.dev respects HTTP_PROXY environment variables.\\n'));\n}","weight":1}},{"data":{"id":"structure:5521","label":"formatStructure","type":"function","file":"dist-test/src/cli/commands/query.js","line":3,"signature":"function formatStructure(s, fileCache)","content":"function formatStructure(s, fileCache) {\n    let filePath = fileCache.get(s.file_id);\n    if (!filePath) {\n        const file = getFile(s.file_id);\n        filePath = file?.path || 'unknown';\n        fileCache.set(s.file_id, filePath);\n    }\n    const location = `${filePath}:${s.line_start}`;\n    const sig = s.signature || s.name;\n    return `  ${chalk.cyan(s.type)} ${chalk.bold(s.name)}\n    ${chalk.gray(location)}\n    ${chalk.gray(sig)}`;\n}","weight":1}},{"data":{"id":"structure:5523","label":"queryCommand","type":"function","file":"dist-test/src/cli/commands/query.js","line":23,"signature":"function queryCommand(searchQuery, options)","content":"export function queryCommand(searchQuery, options) {\n    const type = options.type || 'all';\n    const limit = options.limit || 10;\n    // Auto-detect project from cwd unless --global flag is set\n    let projectId;\n    if (!options.global) {\n        const project = findProjectForPath(process.cwd());\n        if (project) {\n            projectId = project.id;\n            console.log(chalk.gray(`Searching in project: ${project.name}`));\n            console.log(chalk.gray(`(use --global to search all projects)\\n`));\n        }\n    }\n    console.log(chalk.bold(`Searching for: \"${searchQuery}\"\\n`));\n    const fileCache = new Map();\n    let foundAny = false;\n    // Search structures\n    if (type === 'all' || type === 'structures') {\n        try {\n            const structures = searchStructures(searchQuery, limit, projectId);\n            if (structures.length \u003e 0) {\n                foundAny = true;\n                console.log(chalk.bold.blue(`Structures (${structures.length}):`));\n                for (const s of structures) {\n                    console.log(formatStructure(s, fileCache));\n                    // Show related conversations\n                    const links = getLinksTo('structure', s.id);\n                    const decisions = links.filter(l =\u003e l.link_type === 'decision');\n                    if (decisions.length \u003e 0) {\n                        console.log(chalk.gray(`    ${decisions.length} related decision(s)`));\n                    }\n                }\n                console.log();\n            }\n        }\n        catch (err) {\n            // FTS might not be ready\n        }\n    }\n    // Search conversations\n    if (type === 'all' || type === 'conversations') {\n        try {\n            const conversations = searchConversations(searchQuery, limit, projectId);\n            if (conversations.length \u003e 0) {\n                foundAny = true;\n                console.log(chalk.bold.yellow(`Conversations (${conversations.length}):`));\n                for (const c of conversations) {\n                    console.log(formatConversation(c));\n                }\n                console.log();\n            }\n        }\n        catch (err) {\n            // FTS might not be ready\n        }\n    }\n    if (!foundAny) {\n        console.log(chalk.gray('No results found'));\n    }\n}","weight":6}},{"data":{"id":"structure:5524","label":"mcpServeCommand","type":"function","file":"dist-test/src/cli/commands/mcp-serve.js","line":2,"signature":"function mcpServeCommand()","content":"export async function mcpServeCommand() {\n    await startMcpServer();\n}","weight":1}},{"data":{"id":"structure:5525","label":"initCommand","type":"function","file":"dist-test/src/cli/commands/init.js","line":6,"signature":"function initCommand(targetPath)","content":"export async function initCommand(targetPath) {\n    const projectPath = resolve(targetPath || process.cwd());\n    if (!existsSync(projectPath)) {\n        console.error(chalk.red(`Error: Path does not exist: ${projectPath}`));\n        process.exit(1);\n    }\n    // Check if already initialized\n    const existing = getProjectByPath(projectPath);\n    if (existing) {\n        console.log(chalk.yellow(`Project already initialized: ${existing.name}`));\n        console.log(chalk.gray(`Re-indexing...`));\n        await indexProject(existing.id, projectPath);\n        console.log(chalk.green(`Re-indexed: ${projectPath}`));\n        return;\n    }\n    // Create new project\n    const name = projectPath.split('/').pop() || 'project';\n    const project = createProject(projectPath, name);\n    console.log(chalk.green(`Initialized aimem for: ${projectPath}`));\n    console.log(chalk.gray(`Data stored in: ${getDataDir()}`));\n    console.log(chalk.gray(`Project ID: ${project.id}`));\n    // Index the project\n    console.log(chalk.blue(`Indexing codebase...`));\n    await indexProject(project.id, projectPath);\n    console.log(chalk.green(`Done!`));\n}","weight":4}},{"data":{"id":"structure:5528","label":"extractDecisions","type":"function","file":"dist-test/src/cli/commands/import.js","line":44,"signature":"function extractDecisions(content)","content":"function extractDecisions(content) {\n    const extractions = [];\n    const seen = new Set();\n    for (const pattern of DECISION_PATTERNS) {\n        pattern.lastIndex = 0;\n        let match;\n        while ((match = pattern.exec(content)) !== null) {\n            const sentence = getSentenceAround(content, match.index);\n            if (isValidExtraction(sentence)) {\n                const key = sentence.slice(0, 80).toLowerCase();\n                if (!seen.has(key)) {\n                    seen.add(key);\n                    extractions.push({ type: 'decision', content: sentence });\n                }\n            }\n        }\n    }\n    for (const pattern of REJECTION_PATTERNS) {\n        pattern.lastIndex = 0;\n        let match;\n        while ((match = pattern.exec(content)) !== null) {\n            const sentence = getSentenceAround(content, match.index);\n            if (isValidExtraction(sentence)) {\n                const key = sentence.slice(0, 80).toLowerCase();\n                if (!seen.has(key)) {\n                    seen.add(key);\n                    extractions.push({ type: 'rejection', content: sentence });\n                }\n            }\n        }\n    }\n    return extractions;\n}","weight":2}},{"data":{"id":"structure:5531","label":"findClaudeProject","type":"function","file":"dist-test/src/cli/commands/import.js","line":86,"signature":"function findClaudeProject(projectPath)","content":"function findClaudeProject(projectPath) {\n    const claudeProjectsDir = getClaudeProjectsDir();\n    if (!existsSync(claudeProjectsDir))\n        return null;\n    const encoded = encodeProjectPath(projectPath);\n    const fullPath = join(claudeProjectsDir, encoded);\n    if (existsSync(fullPath)) {\n        return fullPath;\n    }\n    const dirs = readdirSync(claudeProjectsDir);\n    for (const dir of dirs) {\n        if (dir.includes(basename(projectPath))) {\n            return join(claudeProjectsDir, dir);\n        }\n    }\n    return null;\n}","weight":2}},{"data":{"id":"structure:5534","label":"importFromClaude","type":"function","file":"dist-test/src/cli/commands/import.js","line":137,"signature":"function importFromClaude(projectPath, projectId, existingExtractions, dryRun, limit, full = false)","content":"async function importFromClaude(projectPath, projectId, existingExtractions, dryRun, limit, full = false) {\n    const claudeProjectDir = findClaudeProject(projectPath);\n    if (!claudeProjectDir) {\n        return null;\n    }\n    console.log(chalk.bold('\\nüìÅ Claude Code'));\n    console.log(`   ${chalk.gray(claudeProjectDir)}`);\n    const db = getDb();\n    const files = readdirSync(claudeProjectDir)\n        .filter((f) =\u003e f.endsWith('.jsonl') \u0026\u0026 !f.startsWith('agent-'))\n        .map((f) =\u003e join(claudeProjectDir, f));\n    if (files.length === 0) {\n        console.log(chalk.gray('   No conversation files found'));\n        return null;\n    }\n    console.log(`   Found ${files.length} conversation files`);\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let skippedDuplicates = 0;\n    for (const file of files) {\n        const fileName = basename(file);\n        const messages = parseClaudeConversationFile(file);\n        if (messages.length === 0)\n            continue;\n        for (const msg of messages) {\n            if (totalExtractions \u003e= limit)\n                break;\n            const text = extractClaudeAssistantText(msg);\n            if (!text || text.length \u003c 100)\n                continue;\n            totalMessages++;\n            const extractions = extractDecisions(text);\n            const newExtractions = extractions.filter((e) =\u003e {\n                const key = e.content.slice(0, 80).toLowerCase();\n                if (existingExtractions.has(key)) {\n                    skippedDuplicates++;\n                    return false;\n                }\n                existingExtractions.add(key);\n                return true;\n            });\n            if (newExtractions.length === 0)\n                continue;\n            if (dryRun) {\n                if (full) {\n                    console.log(chalk.gray(`   [full] ${text.slice(0, 80)}...`));\n                }\n                for (const ext of newExtractions) {\n                    console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n                    totalExtractions++;\n                }\n            }\n            else {\n                const timestamp = msg.timestamp || new Date().toISOString();\n                // Store full content if --full flag is set, otherwise just metadata\n                const rawContent = full ? text : JSON.stringify({ imported: true, source: fileName });\n                const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'claude-code', rawContent, timestamp);\n                const conversationId = result.lastInsertRowid;\n                for (const ext of newExtractions) {\n                    db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'claude' }));\n                    totalExtractions++;\n                }\n            }\n        }\n        if (totalExtractions \u003e= limit)\n            break;\n    }\n    return { source: 'claude', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":5}},{"data":{"id":"structure:5536","label":"parseAiderHistory","type":"function","file":"dist-test/src/cli/commands/import.js","line":239,"signature":"function parseAiderHistory(content)","content":"function parseAiderHistory(content) {\n    // Aider format:\n    // #### /ask or #### user message\n    // User content\n    //\n    // #### assistant or #### Claude response\n    // Assistant content\n    const assistantBlocks = [];\n    const lines = content.split('\\n');\n    let inAssistantBlock = false;\n    let currentBlock = '';\n    for (const line of lines) {\n        // Check for block headers\n        if (line.startsWith('#### ')) {\n            // Save previous assistant block\n            if (inAssistantBlock \u0026\u0026 currentBlock.trim()) {\n                assistantBlocks.push(currentBlock.trim());\n            }\n            currentBlock = '';\n            // Check if this is an assistant block\n            const header = line.slice(5).toLowerCase();\n            inAssistantBlock = !header.startsWith('/') \u0026\u0026\n                !header.includes('user') \u0026\u0026\n                !header.includes('human') \u0026\u0026\n                (header.includes('assistant') ||\n                    header.includes('claude') ||\n                    header.includes('gpt') ||\n                    header.includes('aider') ||\n                    header === '');\n        }\n        else if (inAssistantBlock) {\n            currentBlock += line + '\\n';\n        }\n    }\n    // Don't forget the last block\n    if (inAssistantBlock \u0026\u0026 currentBlock.trim()) {\n        assistantBlocks.push(currentBlock.trim());\n    }\n    return assistantBlocks;\n}\nasync function importFromAider(projectPath, projectId, existingExtractions, dryRun, limit, full = false) {\n    const historyFiles = findAiderHistoryFiles(projectPath);\n    if (historyFiles.length === 0) {\n        return null;\n    }\n    console.log(chalk.bold('\\nüìÅ Aider'));\n    console.log(`   Found ${historyFiles.length} history file(s)`);\n    const db = getDb();\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let skippedDuplicates = 0;\n    for (const file of historyFiles) {\n        const fileName = basename(file);\n        console.log(`   ${chalk.gray(fileName)}`);\n        const content = readFileSync(file, 'utf-8');\n        const assistantBlocks = parseAiderHistory(content);\n        if (assistantBlocks.length === 0) {\n            console.log(chalk.gray('   No assistant messages found'));\n            continue;\n        }\n        console.log(`   ${assistantBlocks.length} assistant messages`);\n        for (const block of assistantBlocks) {\n            if (totalExtractions \u003e= limit)\n                break;\n            if (block.length \u003c 100)\n                continue;\n            totalMessages++;\n            const extractions = extractDecisions(block);\n            const newExtractions = extractions.filter((e) =\u003e {\n                const key = e.content.slice(0, 80).toLowerCase();\n                if (existingExtractions.has(key)) {\n                    skippedDuplicates++;\n                    return false;\n                }\n                existingExtractions.add(key);\n                return true;\n            });\n            if (newExtractions.length === 0)\n                continue;\n            if (dryRun) {\n                if (full) {\n                    console.log(chalk.gray(`   [full] ${block.slice(0, 80)}...`));\n                }\n                for (const ext of newExtractions) {\n                    console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n                    totalExtractions++;\n                }\n            }\n            else {\n                // Store full content if --full flag is set, otherwise just metadata\n                const rawContent = full ? block : JSON.stringify({ imported: true, source: fileName });\n                const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'aider', rawContent, new Date().toISOString());\n                const conversationId = result.lastInsertRowid;\n                for (const ext of newExtractions) {\n                    db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'aider' }));\n                    totalExtractions++;\n                }\n            }\n        }\n        if (totalExtractions \u003e= limit)\n            break;\n    }\n    return { source: 'aider', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}\n// ============================================================================\n// Continue.dev import\n// ============================================================================\nfunction getContinueSessionsDir() {\n    return join(homedir(), '.continue', 'sessions');\n}\nasync function importFromContinue(projectPath, projectId, existingExtractions, dryRun, limit, full = false) {\n    const sessionsDir = getContinueSessionsDir();\n    if (!existsSync(sessionsDir)) {\n        return null;\n    }\n    console.log(chalk.bold('\\nüìÅ Continue.dev'));\n    console.log(`   ${chalk.gray(sessionsDir)}`);\n    const db = getDb();\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let skippedDuplicates = 0;\n    try {\n        const files = readdirSync(sessionsDir).filter((f) =\u003e f.endsWith('.json'));\n        if (files.length === 0) {\n            console.log(chalk.gray('   No session files found'));\n            return null;\n        }\n        console.log(`   Found ${files.length} session files`);\n        for (const file of files) {\n            if (totalExtractions \u003e= limit)\n                break;\n            try {\n                const content = readFileSync(join(sessionsDir, file), 'utf-8');\n                const session = JSON.parse(content);\n                if (!session.history || !Array.isArray(session.history))\n                    continue;\n                const assistantMessages = session.history.filter((m) =\u003e m.role === 'assistant' \u0026\u0026 m.content);\n                for (const msg of assistantMessages) {\n                    if (totalExtractions \u003e= limit)\n                        break;\n                    if (msg.content.length \u003c 100)\n                        continue;\n                    totalMessages++;\n                    const extractions = extractDecisions(msg.content);\n                    const newExtractions = extractions.filter((e) =\u003e {\n                        const key = e.content.slice(0, 80).toLowerCase();\n                        if (existingExtractions.has(key)) {\n                            skippedDuplicates++;\n                            return false;\n                        }\n                        existingExtractions.add(key);\n                        return true;\n                    });\n                    if (newExtractions.length === 0)\n                        continue;\n                    if (dryRun) {\n                        if (full) {\n                            console.log(chalk.gray(`   [full] ${msg.content.slice(0, 80)}...`));\n                        }\n                        for (const ext of newExtractions) {\n                            console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n                            totalExtractions++;\n                        }\n                    }\n                    else {\n                        // Store full content if --full flag is set, otherwise just metadata\n                        const rawContent = full ? msg.content : JSON.stringify({ imported: true, source: file });\n                        const result = db.prepare(`\n              INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n              VALUES (?, ?, ?, ?, ?)\n            `).run(projectId, 'imported', 'continue', rawContent, new Date().toISOString());\n                        const conversationId = result.lastInsertRowid;\n                        for (const ext of newExtractions) {\n                            db.prepare(`\n                INSERT INTO extractions (conversation_id, type, content, metadata)\n                VALUES (?, ?, ?, ?)\n              `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'continue' }));\n                            totalExtractions++;\n                        }\n                    }\n                }\n            }\n            catch {\n                // Skip invalid files\n            }\n        }\n    }\n    catch {\n        return null;\n    }\n    if (totalMessages === 0) {\n        return null;\n    }\n    return { source: 'continue', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}\n// ============================================================================\n// Main import command\n// ============================================================================\nexport async function importCommand(options) {\n    ensureDataDir();\n    const db = getDb();\n    const projectPath = options.project || process.cwd();\n    const source = options.source || 'all';\n    const dryRun = options.dryRun || false;\n    const limit = options.limit || 1000;\n    const full = options.full || false;\n    console.log(chalk.bold('Importing conversation history...\\n'));\n    // Find the aimem project\n    const aimemProject = getProjectByPath(projectPath);\n    if (!aimemProject) {\n        console.log(chalk.red(`Project not indexed: ${projectPath}`));\n        console.log(chalk.yellow('Run `aimem init` first to index this project.'));\n        process.exit(1);\n    }\n    console.log(`Project: ${chalk.cyan(aimemProject.path)}`);\n    console.log(`Source:  ${chalk.cyan(source)}`);\n    if (dryRun)\n        console.log(chalk.yellow('Mode:    dry-run'));\n    if (full)\n        console.log(chalk.green('Mode:    full (storing complete conversation content)'));\n    // Load existing extractions to avoid duplicates\n    const existingExtractions = new Set();\n    const existingRows = db.prepare(`\n    SELECT e.content FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE c.project_id = ?\n  `).all(aimemProject.id);\n    for (const row of existingRows) {\n        existingExtractions.add(row.content.slice(0, 80).toLowerCase());\n    }\n    console.log(`Existing extractions: ${existingExtractions.size}`);\n    const results = [];\n    // Import from selected sources\n    if (source === 'all' || source === 'claude') {\n        const result = await importFromClaude(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    if (source === 'all' || source === 'aider') {\n        const result = await importFromAider(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    if (source === 'all' || source === 'continue') {\n        const result = await importFromContinue(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    // Summary\n    console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ'));\n    if (results.length === 0) {\n        console.log(chalk.yellow('No conversation history found for any source.'));\n        console.log(chalk.gray('\\nSupported sources:'));\n        console.log(chalk.gray('  - Claude Code: ~/.claude/projects/'));\n        console.log(chalk.gray('  - Aider: .aider.chat.history.md in project'));\n        console.log(chalk.gray('  - Continue.dev: ~/.continue/sessions/'));\n        return;\n    }\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let totalDuplicates = 0;\n    for (const r of results) {\n        console.log(`\\n${chalk.cyan(r.source)}:`);\n        console.log(`  Messages:    ${r.messages}`);\n        console.log(`  Extractions: ${chalk.green(r.extractions)}`);\n        console.log(`  Duplicates:  ${r.duplicates}`);\n        totalMessages += r.messages;\n        totalExtractions += r.extractions;\n        totalDuplicates += r.duplicates;\n    }\n    console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Total ‚îÅ‚îÅ‚îÅ'));\n    console.log(`Messages:    ${totalMessages}`);\n    console.log(`Extractions: ${chalk.green(totalExtractions)}`);\n    console.log(`Duplicates:  ${totalDuplicates}`);\n    if (dryRun) {\n        console.log(chalk.yellow('\\nDry run - no changes made. Remove --dry-run to import.'));\n    }\n    else if (totalExtractions \u003e 0) {\n        console.log(chalk.green('\\nImport complete!'));\n        console.log(chalk.gray('Query with: aimem_decisions \u003ctopic\u003e'));\n    }\n}\n//# sourceMappingURL=import.js.map","weight":10}},{"data":{"id":"structure:5537","label":"importFromAider","type":"function","file":"dist-test/src/cli/commands/import.js","line":279,"signature":"function importFromAider(projectPath, projectId, existingExtractions, dryRun, limit, full = false)","content":"async function importFromAider(projectPath, projectId, existingExtractions, dryRun, limit, full = false) {\n    const historyFiles = findAiderHistoryFiles(projectPath);\n    if (historyFiles.length === 0) {\n        return null;\n    }\n    console.log(chalk.bold('\\nüìÅ Aider'));\n    console.log(`   Found ${historyFiles.length} history file(s)`);\n    const db = getDb();\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let skippedDuplicates = 0;\n    for (const file of historyFiles) {\n        const fileName = basename(file);\n        console.log(`   ${chalk.gray(fileName)}`);\n        const content = readFileSync(file, 'utf-8');\n        const assistantBlocks = parseAiderHistory(content);\n        if (assistantBlocks.length === 0) {\n            console.log(chalk.gray('   No assistant messages found'));\n            continue;\n        }\n        console.log(`   ${assistantBlocks.length} assistant messages`);\n        for (const block of assistantBlocks) {\n            if (totalExtractions \u003e= limit)\n                break;\n            if (block.length \u003c 100)\n                continue;\n            totalMessages++;\n            const extractions = extractDecisions(block);\n            const newExtractions = extractions.filter((e) =\u003e {\n                const key = e.content.slice(0, 80).toLowerCase();\n                if (existingExtractions.has(key)) {\n                    skippedDuplicates++;\n                    return false;\n                }\n                existingExtractions.add(key);\n                return true;\n            });\n            if (newExtractions.length === 0)\n                continue;\n            if (dryRun) {\n                if (full) {\n                    console.log(chalk.gray(`   [full] ${block.slice(0, 80)}...`));\n                }\n                for (const ext of newExtractions) {\n                    console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n                    totalExtractions++;\n                }\n            }\n            else {\n                // Store full content if --full flag is set, otherwise just metadata\n                const rawContent = full ? block : JSON.stringify({ imported: true, source: fileName });\n                const result = db.prepare(`\n          INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `).run(projectId, 'imported', 'aider', rawContent, new Date().toISOString());\n                const conversationId = result.lastInsertRowid;\n                for (const ext of newExtractions) {\n                    db.prepare(`\n            INSERT INTO extractions (conversation_id, type, content, metadata)\n            VALUES (?, ?, ?, ?)\n          `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'aider' }));\n                    totalExtractions++;\n                }\n            }\n        }\n        if (totalExtractions \u003e= limit)\n            break;\n    }\n    return { source: 'aider', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":4}},{"data":{"id":"structure:5539","label":"importFromContinue","type":"function","file":"dist-test/src/cli/commands/import.js","line":355,"signature":"function importFromContinue(projectPath, projectId, existingExtractions, dryRun, limit, full = false)","content":"async function importFromContinue(projectPath, projectId, existingExtractions, dryRun, limit, full = false) {\n    const sessionsDir = getContinueSessionsDir();\n    if (!existsSync(sessionsDir)) {\n        return null;\n    }\n    console.log(chalk.bold('\\nüìÅ Continue.dev'));\n    console.log(`   ${chalk.gray(sessionsDir)}`);\n    const db = getDb();\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let skippedDuplicates = 0;\n    try {\n        const files = readdirSync(sessionsDir).filter((f) =\u003e f.endsWith('.json'));\n        if (files.length === 0) {\n            console.log(chalk.gray('   No session files found'));\n            return null;\n        }\n        console.log(`   Found ${files.length} session files`);\n        for (const file of files) {\n            if (totalExtractions \u003e= limit)\n                break;\n            try {\n                const content = readFileSync(join(sessionsDir, file), 'utf-8');\n                const session = JSON.parse(content);\n                if (!session.history || !Array.isArray(session.history))\n                    continue;\n                const assistantMessages = session.history.filter((m) =\u003e m.role === 'assistant' \u0026\u0026 m.content);\n                for (const msg of assistantMessages) {\n                    if (totalExtractions \u003e= limit)\n                        break;\n                    if (msg.content.length \u003c 100)\n                        continue;\n                    totalMessages++;\n                    const extractions = extractDecisions(msg.content);\n                    const newExtractions = extractions.filter((e) =\u003e {\n                        const key = e.content.slice(0, 80).toLowerCase();\n                        if (existingExtractions.has(key)) {\n                            skippedDuplicates++;\n                            return false;\n                        }\n                        existingExtractions.add(key);\n                        return true;\n                    });\n                    if (newExtractions.length === 0)\n                        continue;\n                    if (dryRun) {\n                        if (full) {\n                            console.log(chalk.gray(`   [full] ${msg.content.slice(0, 80)}...`));\n                        }\n                        for (const ext of newExtractions) {\n                            console.log(chalk.gray(`   [${ext.type}] ${ext.content.slice(0, 50)}...`));\n                            totalExtractions++;\n                        }\n                    }\n                    else {\n                        // Store full content if --full flag is set, otherwise just metadata\n                        const rawContent = full ? msg.content : JSON.stringify({ imported: true, source: file });\n                        const result = db.prepare(`\n              INSERT INTO conversations (project_id, model, tool, raw_content, timestamp)\n              VALUES (?, ?, ?, ?, ?)\n            `).run(projectId, 'imported', 'continue', rawContent, new Date().toISOString());\n                        const conversationId = result.lastInsertRowid;\n                        for (const ext of newExtractions) {\n                            db.prepare(`\n                INSERT INTO extractions (conversation_id, type, content, metadata)\n                VALUES (?, ?, ?, ?)\n              `).run(conversationId, ext.type, ext.content, JSON.stringify({ imported: true, source: 'continue' }));\n                            totalExtractions++;\n                        }\n                    }\n                }\n            }\n            catch {\n                // Skip invalid files\n            }\n        }\n    }\n    catch {\n        return null;\n    }\n    if (totalMessages === 0) {\n        return null;\n    }\n    return { source: 'continue', messages: totalMessages, extractions: totalExtractions, duplicates: skippedDuplicates };\n}","weight":3}},{"data":{"id":"structure:5540","label":"importCommand","type":"function","file":"dist-test/src/cli/commands/import.js","line":443,"signature":"function importCommand(options)","content":"export async function importCommand(options) {\n    ensureDataDir();\n    const db = getDb();\n    const projectPath = options.project || process.cwd();\n    const source = options.source || 'all';\n    const dryRun = options.dryRun || false;\n    const limit = options.limit || 1000;\n    const full = options.full || false;\n    console.log(chalk.bold('Importing conversation history...\\n'));\n    // Find the aimem project\n    const aimemProject = getProjectByPath(projectPath);\n    if (!aimemProject) {\n        console.log(chalk.red(`Project not indexed: ${projectPath}`));\n        console.log(chalk.yellow('Run `aimem init` first to index this project.'));\n        process.exit(1);\n    }\n    console.log(`Project: ${chalk.cyan(aimemProject.path)}`);\n    console.log(`Source:  ${chalk.cyan(source)}`);\n    if (dryRun)\n        console.log(chalk.yellow('Mode:    dry-run'));\n    if (full)\n        console.log(chalk.green('Mode:    full (storing complete conversation content)'));\n    // Load existing extractions to avoid duplicates\n    const existingExtractions = new Set();\n    const existingRows = db.prepare(`\n    SELECT e.content FROM extractions e\n    JOIN conversations c ON e.conversation_id = c.id\n    WHERE c.project_id = ?\n  `).all(aimemProject.id);\n    for (const row of existingRows) {\n        existingExtractions.add(row.content.slice(0, 80).toLowerCase());\n    }\n    console.log(`Existing extractions: ${existingExtractions.size}`);\n    const results = [];\n    // Import from selected sources\n    if (source === 'all' || source === 'claude') {\n        const result = await importFromClaude(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    if (source === 'all' || source === 'aider') {\n        const result = await importFromAider(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    if (source === 'all' || source === 'continue') {\n        const result = await importFromContinue(projectPath, aimemProject.id, existingExtractions, dryRun, limit, full);\n        if (result)\n            results.push(result);\n    }\n    // Summary\n    console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Summary ‚îÅ‚îÅ‚îÅ'));\n    if (results.length === 0) {\n        console.log(chalk.yellow('No conversation history found for any source.'));\n        console.log(chalk.gray('\\nSupported sources:'));\n        console.log(chalk.gray('  - Claude Code: ~/.claude/projects/'));\n        console.log(chalk.gray('  - Aider: .aider.chat.history.md in project'));\n        console.log(chalk.gray('  - Continue.dev: ~/.continue/sessions/'));\n        return;\n    }\n    let totalMessages = 0;\n    let totalExtractions = 0;\n    let totalDuplicates = 0;\n    for (const r of results) {\n        console.log(`\\n${chalk.cyan(r.source)}:`);\n        console.log(`  Messages:    ${r.messages}`);\n        console.log(`  Extractions: ${chalk.green(r.extractions)}`);\n        console.log(`  Duplicates:  ${r.duplicates}`);\n        totalMessages += r.messages;\n        totalExtractions += r.extractions;\n        totalDuplicates += r.duplicates;\n    }\n    console.log(chalk.bold('\\n‚îÅ‚îÅ‚îÅ Total ‚îÅ‚îÅ‚îÅ'));\n    console.log(`Messages:    ${totalMessages}`);\n    console.log(`Extractions: ${chalk.green(totalExtractions)}`);\n    console.log(`Duplicates:  ${totalDuplicates}`);\n    if (dryRun) {\n        console.log(chalk.yellow('\\nDry run - no changes made. Remove --dry-run to import.'));\n    }\n    else if (totalExtractions \u003e 0) {\n        console.log(chalk.green('\\nImport complete!'));\n        console.log(chalk.gray('Query with: aimem_decisions \u003ctopic\u003e'));\n    }\n}","weight":6}},{"data":{"id":"structure:5548","label":"findBlockEnd","type":"function","file":"dist-test/src/indexer/parsers/javascript.js","line":17,"signature":"function findBlockEnd(content, startPos)","content":"function findBlockEnd(content, startPos) {\n    let depth = 0;\n    let inString = false;\n    let stringChar = '';\n    let i = startPos;\n    // Find opening brace\n    while (i \u003c content.length \u0026\u0026 content[i] !== '{')\n        i++;\n    if (i \u003e= content.length)\n        return content.length;\n    // Find matching closing brace\n    for (; i \u003c content.length; i++) {\n        const char = content[i];\n        const prevChar = i \u003e 0 ? content[i - 1] : '';\n        if (inString) {\n            if (char === stringChar \u0026\u0026 prevChar !== '\\\\') {\n                inString = false;\n            }\n            continue;\n        }\n        if (char === '\"' || char === \"'\" || char === '`') {\n            inString = true;\n            stringChar = char;\n            continue;\n        }\n        if (char === '{')\n            depth++;\n        if (char === '}') {\n            depth--;\n            if (depth === 0)\n                return i + 1;\n        }\n    }\n    return content.length;\n}\nexport const javascriptParser = {\n    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\n    parse(content, filePath) {\n        const structures = [];\n        const lines = content.split('\\n');\n        // Parse functions\n        let match;\n        patterns.function.lastIndex = 0;\n        while ((match = patterns.function.exec(content)) !== null) {\n            const name = match[1];\n            const params = match[2];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'function',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `function ${name}(${params})`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n            });\n        }\n        // Parse arrow functions\n        patterns.arrowFunction.lastIndex = 0;\n        while ((match = patterns.arrowFunction.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'function',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `const ${name} = () =\u003e ...`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: { arrow: true },\n            });\n        }\n        // Parse classes\n        patterns.class.lastIndex = 0;\n        while ((match = patterns.class.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'class',\n                name,\n                lineStart,\n                lineEnd,\n                signature: match[0].trim(),\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        // Parse interfaces\n        patterns.interface.lastIndex = 0;\n        while ((match = patterns.interface.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'interface',\n                name,\n                lineStart,\n                lineEnd,\n                signature: match[0].trim(),\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        // Parse type aliases\n        patterns.typeAlias.lastIndex = 0;\n        while ((match = patterns.typeAlias.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            // Type aliases end at semicolon or next line with different indent\n            let lineEnd = lineStart;\n            for (let i = lineStart; i \u003c lines.length; i++) {\n                if (lines[i].includes(';') || (i \u003e lineStart \u0026\u0026 !lines[i].startsWith(' ') \u0026\u0026 !lines[i].startsWith('\\t'))) {\n                    lineEnd = i + 1;\n                    break;\n                }\n            }\n            structures.push({\n                type: 'type',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `type ${name}`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        return structures;\n    },\n};\n//# sourceMappingURL=javascript.js.map","weight":2}}],"edges":[{"data":{"id":"call:5138:5139","source":"structure:5138","target":"structure:5139","type":"calls","label":"calls"}},{"data":{"id":"call:5182:5172","source":"structure:5182","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5183:5172","source":"structure:5183","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5184:5172","source":"structure:5184","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5185:5172","source":"structure:5185","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5186:5172","source":"structure:5186","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5187:5172","source":"structure:5187","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5192:5139","source":"structure:5192","target":"structure:5139","type":"calls","label":"calls"}},{"data":{"id":"call:5233:5172","source":"structure:5233","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5234:5172","source":"structure:5234","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5235:5172","source":"structure:5235","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5236:5172","source":"structure:5236","target":"structure:5172","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5254","source":"structure:5249","target":"structure:5254","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5250","source":"structure:5249","target":"structure:5250","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5252","source":"structure:5249","target":"structure:5252","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5253","source":"structure:5249","target":"structure:5253","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5251","source":"structure:5249","target":"structure:5251","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5255","source":"structure:5249","target":"structure:5255","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5256","source":"structure:5249","target":"structure:5256","type":"calls","label":"calls"}},{"data":{"id":"call:5249:5257","source":"structure:5249","target":"structure:5257","type":"calls","label":"calls"}},{"data":{"id":"call:5250:5252","source":"structure:5250","target":"structure:5252","type":"calls","label":"calls"}},{"data":{"id":"call:5250:5253","source":"structure:5250","target":"structure:5253","type":"calls","label":"calls"}},{"data":{"id":"call:5250:5251","source":"structure:5250","target":"structure:5251","type":"calls","label":"calls"}},{"data":{"id":"call:5252:5254","source":"structure:5252","target":"structure:5254","type":"calls","label":"calls"}},{"data":{"id":"call:5253:5254","source":"structure:5253","target":"structure:5254","type":"calls","label":"calls"}},{"data":{"id":"call:5253:5255","source":"structure:5253","target":"structure:5255","type":"calls","label":"calls"}},{"data":{"id":"call:5253:5250","source":"structure:5253","target":"structure:5250","type":"calls","label":"calls"}},{"data":{"id":"call:5253:5256","source":"structure:5253","target":"structure:5256","type":"calls","label":"calls"}},{"data":{"id":"call:5253:5257","source":"structure:5253","target":"structure:5257","type":"calls","label":"calls"}},{"data":{"id":"call:5255:5250","source":"structure:5255","target":"structure:5250","type":"calls","label":"calls"}},{"data":{"id":"call:5255:5253","source":"structure:5255","target":"structure:5253","type":"calls","label":"calls"}},{"data":{"id":"call:5255:5256","source":"structure:5255","target":"structure:5256","type":"calls","label":"calls"}},{"data":{"id":"call:5255:5257","source":"structure:5255","target":"structure:5257","type":"calls","label":"calls"}},{"data":{"id":"call:5255:5254","source":"structure:5255","target":"structure:5254","type":"calls","label":"calls"}},{"data":{"id":"call:5259:5249","source":"structure:5259","target":"structure:5249","type":"calls","label":"calls"}},{"data":{"id":"call:5261:5262","source":"structure:5261","target":"structure:5262","type":"calls","label":"calls"}},{"data":{"id":"call:5261:5263","source":"structure:5261","target":"structure:5263","type":"calls","label":"calls"}},{"data":{"id":"call:5261:5264","source":"structure:5261","target":"structure:5264","type":"calls","label":"calls"}},{"data":{"id":"call:5261:5265","source":"structure:5261","target":"structure:5265","type":"calls","label":"calls"}},{"data":{"id":"call:5261:5266","source":"structure:5261","target":"structure:5266","type":"calls","label":"calls"}},{"data":{"id":"call:5262:5268","source":"structure:5262","target":"structure:5268","type":"calls","label":"calls"}},{"data":{"id":"call:5262:5267","source":"structure:5262","target":"structure:5267","type":"calls","label":"calls"}},{"data":{"id":"call:5264:5267","source":"structure:5264","target":"structure:5267","type":"calls","label":"calls"}},{"data":{"id":"call:5266:5269","source":"structure:5266","target":"structure:5269","type":"calls","label":"calls"}},{"data":{"id":"call:5270:5249","source":"structure:5270","target":"structure:5249","type":"calls","label":"calls"}},{"data":{"id":"call:5276:5277","source":"structure:5276","target":"structure:5277","type":"calls","label":"calls"}},{"data":{"id":"call:5296:5340","source":"structure:5296","target":"structure:5340","type":"calls","label":"calls"}},{"data":{"id":"call:5296:5333","source":"structure:5296","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5296:5346","source":"structure:5296","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5296:5348","source":"structure:5296","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5297:5339","source":"structure:5297","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5297:5333","source":"structure:5297","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5297:5343","source":"structure:5297","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5297:5348","source":"structure:5297","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5339","source":"structure:5300","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5333","source":"structure:5300","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5343","source":"structure:5300","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5340","source":"structure:5300","target":"structure:5340","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5346","source":"structure:5300","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5349","source":"structure:5300","target":"structure:5349","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5348","source":"structure:5300","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5350","source":"structure:5300","target":"structure:5350","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5353","source":"structure:5300","target":"structure:5353","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5354","source":"structure:5300","target":"structure:5354","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5355","source":"structure:5300","target":"structure:5355","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5341","source":"structure:5300","target":"structure:5341","type":"calls","label":"calls"}},{"data":{"id":"call:5300:5357","source":"structure:5300","target":"structure:5357","type":"calls","label":"calls"}},{"data":{"id":"call:5309:5307","source":"structure:5309","target":"structure:5307","type":"calls","label":"calls"}},{"data":{"id":"call:5309:5306","source":"structure:5309","target":"structure:5306","type":"calls","label":"calls"}},{"data":{"id":"call:5309:5332","source":"structure:5309","target":"structure:5332","type":"calls","label":"calls"}},{"data":{"id":"call:5309:5338","source":"structure:5309","target":"structure:5338","type":"calls","label":"calls"}},{"data":{"id":"call:5309:5337","source":"structure:5309","target":"structure:5337","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5314","source":"structure:5313","target":"structure:5314","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5315","source":"structure:5313","target":"structure:5315","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5316","source":"structure:5313","target":"structure:5316","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5318","source":"structure:5313","target":"structure:5318","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5317","source":"structure:5313","target":"structure:5317","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5320","source":"structure:5313","target":"structure:5320","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5319","source":"structure:5313","target":"structure:5319","type":"calls","label":"calls"}},{"data":{"id":"call:5313:5321","source":"structure:5313","target":"structure:5321","type":"calls","label":"calls"}},{"data":{"id":"call:5318:5319","source":"structure:5318","target":"structure:5319","type":"calls","label":"calls"}},{"data":{"id":"call:5321:5314","source":"structure:5321","target":"structure:5314","type":"calls","label":"calls"}},{"data":{"id":"call:5326:5325","source":"structure:5326","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5328:5326","source":"structure:5328","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5329:5326","source":"structure:5329","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5330:5326","source":"structure:5330","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5331:5326","source":"structure:5331","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5332:5326","source":"structure:5332","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5333:5326","source":"structure:5333","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5334:5326","source":"structure:5334","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5335:5326","source":"structure:5335","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5336:5326","source":"structure:5336","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5338:5326","source":"structure:5338","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5339:5326","source":"structure:5339","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5340:5326","source":"structure:5340","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5341:5331","source":"structure:5341","target":"structure:5331","type":"calls","label":"calls"}},{"data":{"id":"call:5342:5326","source":"structure:5342","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5343:5326","source":"structure:5343","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5344:5326","source":"structure:5344","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5345:5326","source":"structure:5345","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5346:5326","source":"structure:5346","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5348:5326","source":"structure:5348","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5349:5326","source":"structure:5349","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5350:5326","source":"structure:5350","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5351:5326","source":"structure:5351","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5352:5326","source":"structure:5352","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5353:5326","source":"structure:5353","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5354:5326","source":"structure:5354","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5355:5326","source":"structure:5355","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5356:5326","source":"structure:5356","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5357:5326","source":"structure:5357","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5358:5326","source":"structure:5358","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5359:5326","source":"structure:5359","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5360:5326","source":"structure:5360","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5362:5340","source":"structure:5362","target":"structure:5340","type":"calls","label":"calls"}},{"data":{"id":"call:5362:5333","source":"structure:5362","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5362:5346","source":"structure:5362","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5362:5348","source":"structure:5362","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5363:5339","source":"structure:5363","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5363:5333","source":"structure:5363","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5363:5343","source":"structure:5363","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5363:5348","source":"structure:5363","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5339","source":"structure:5365","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5333","source":"structure:5365","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5343","source":"structure:5365","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5340","source":"structure:5365","target":"structure:5340","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5346","source":"structure:5365","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5349","source":"structure:5365","target":"structure:5349","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5348","source":"structure:5365","target":"structure:5348","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5350","source":"structure:5365","target":"structure:5350","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5353","source":"structure:5365","target":"structure:5353","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5354","source":"structure:5365","target":"structure:5354","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5355","source":"structure:5365","target":"structure:5355","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5341","source":"structure:5365","target":"structure:5341","type":"calls","label":"calls"}},{"data":{"id":"call:5365:5357","source":"structure:5365","target":"structure:5357","type":"calls","label":"calls"}},{"data":{"id":"call:5373:5307","source":"structure:5373","target":"structure:5307","type":"calls","label":"calls"}},{"data":{"id":"call:5373:5306","source":"structure:5373","target":"structure:5306","type":"calls","label":"calls"}},{"data":{"id":"call:5373:5332","source":"structure:5373","target":"structure:5332","type":"calls","label":"calls"}},{"data":{"id":"call:5373:5338","source":"structure:5373","target":"structure:5338","type":"calls","label":"calls"}},{"data":{"id":"call:5373:5337","source":"structure:5373","target":"structure:5337","type":"calls","label":"calls"}},{"data":{"id":"call:5374:5308","source":"structure:5374","target":"structure:5308","type":"calls","label":"calls"}},{"data":{"id":"call:5374:5309","source":"structure:5374","target":"structure:5309","type":"calls","label":"calls"}},{"data":{"id":"call:5374:5336","source":"structure:5374","target":"structure:5336","type":"calls","label":"calls"}},{"data":{"id":"call:5374:5335","source":"structure:5374","target":"structure:5335","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5314","source":"structure:5376","target":"structure:5314","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5315","source":"structure:5376","target":"structure:5315","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5316","source":"structure:5376","target":"structure:5316","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5318","source":"structure:5376","target":"structure:5318","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5317","source":"structure:5376","target":"structure:5317","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5320","source":"structure:5376","target":"structure:5320","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5319","source":"structure:5376","target":"structure:5319","type":"calls","label":"calls"}},{"data":{"id":"call:5376:5321","source":"structure:5376","target":"structure:5321","type":"calls","label":"calls"}},{"data":{"id":"call:5381:5319","source":"structure:5381","target":"structure:5319","type":"calls","label":"calls"}},{"data":{"id":"call:5384:5314","source":"structure:5384","target":"structure:5314","type":"calls","label":"calls"}},{"data":{"id":"call:5387:5325","source":"structure:5387","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5389:5326","source":"structure:5389","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5390:5326","source":"structure:5390","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5391:5326","source":"structure:5391","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5392:5326","source":"structure:5392","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5393:5326","source":"structure:5393","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5394:5326","source":"structure:5394","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5395:5326","source":"structure:5395","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5396:5326","source":"structure:5396","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5397:5326","source":"structure:5397","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5399:5326","source":"structure:5399","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5400:5326","source":"structure:5400","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5401:5326","source":"structure:5401","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5402:5331","source":"structure:5402","target":"structure:5331","type":"calls","label":"calls"}},{"data":{"id":"call:5403:5326","source":"structure:5403","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5404:5326","source":"structure:5404","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5405:5326","source":"structure:5405","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5406:5326","source":"structure:5406","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5407:5326","source":"structure:5407","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5409:5326","source":"structure:5409","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5410:5326","source":"structure:5410","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5411:5326","source":"structure:5411","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5412:5326","source":"structure:5412","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5413:5326","source":"structure:5413","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5414:5326","source":"structure:5414","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5415:5326","source":"structure:5415","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5416:5326","source":"structure:5416","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5417:5326","source":"structure:5417","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5418:5326","source":"structure:5418","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5341","source":"structure:5419","target":"structure:5341","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5358","source":"structure:5419","target":"structure:5358","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5336","source":"structure:5419","target":"structure:5336","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5359","source":"structure:5419","target":"structure:5359","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5360","source":"structure:5419","target":"structure:5360","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5261","source":"structure:5419","target":"structure:5261","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5259","source":"structure:5419","target":"structure:5259","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5420","source":"structure:5419","target":"structure:5420","type":"calls","label":"calls"}},{"data":{"id":"call:5419:5270","source":"structure:5419","target":"structure:5270","type":"calls","label":"calls"}},{"data":{"id":"call:5422:5324","source":"structure:5422","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5423:5422","source":"structure:5423","target":"structure:5422","type":"calls","label":"calls"}},{"data":{"id":"call:5426:5324","source":"structure:5426","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5427:5324","source":"structure:5427","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5427:5425","source":"structure:5427","target":"structure:5425","type":"calls","label":"calls"}},{"data":{"id":"call:5427:5426","source":"structure:5427","target":"structure:5426","type":"calls","label":"calls"}},{"data":{"id":"call:5427:5352","source":"structure:5427","target":"structure:5352","type":"calls","label":"calls"}},{"data":{"id":"call:5427:5331","source":"structure:5427","target":"structure:5331","type":"calls","label":"calls"}},{"data":{"id":"call:5431:5324","source":"structure:5431","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5431:5430","source":"structure:5431","target":"structure:5430","type":"calls","label":"calls"}},{"data":{"id":"call:5432:5324","source":"structure:5432","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5433:5325","source":"structure:5433","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5433:5324","source":"structure:5433","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5433:5431","source":"structure:5433","target":"structure:5431","type":"calls","label":"calls"}},{"data":{"id":"call:5433:5425","source":"structure:5433","target":"structure:5425","type":"calls","label":"calls"}},{"data":{"id":"call:5433:5432","source":"structure:5433","target":"structure:5432","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5445","source":"structure:5444","target":"structure:5445","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5446","source":"structure:5444","target":"structure:5446","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5447","source":"structure:5444","target":"structure:5447","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5448","source":"structure:5444","target":"structure:5448","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5449","source":"structure:5444","target":"structure:5449","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5435","source":"structure:5444","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5437","source":"structure:5444","target":"structure:5437","type":"calls","label":"calls"}},{"data":{"id":"call:5444:5438","source":"structure:5444","target":"structure:5438","type":"calls","label":"calls"}},{"data":{"id":"call:5451:5333","source":"structure:5451","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5341","source":"structure:5453","target":"structure:5341","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5339","source":"structure:5453","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5451","source":"structure:5453","target":"structure:5451","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5346","source":"structure:5453","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5343","source":"structure:5453","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5453:5452","source":"structure:5453","target":"structure:5452","type":"calls","label":"calls"}},{"data":{"id":"call:5455:5300","source":"structure:5455","target":"structure:5300","type":"calls","label":"calls"}},{"data":{"id":"call:5456:5330","source":"structure:5456","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5456:5310","source":"structure:5456","target":"structure:5310","type":"calls","label":"calls"}},{"data":{"id":"call:5456:5328","source":"structure:5456","target":"structure:5328","type":"calls","label":"calls"}},{"data":{"id":"call:5456:5324","source":"structure:5456","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5462:5460","source":"structure:5462","target":"structure:5460","type":"calls","label":"calls"}},{"data":{"id":"call:5462:5461","source":"structure:5462","target":"structure:5461","type":"calls","label":"calls"}},{"data":{"id":"call:5465:5462","source":"structure:5465","target":"structure:5462","type":"calls","label":"calls"}},{"data":{"id":"call:5465:5326","source":"structure:5465","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5465:5464","source":"structure:5465","target":"structure:5464","type":"calls","label":"calls"}},{"data":{"id":"call:5465:5463","source":"structure:5465","target":"structure:5463","type":"calls","label":"calls"}},{"data":{"id":"call:5465:5313","source":"structure:5465","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5468","source":"structure:5467","target":"structure:5468","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5466","source":"structure:5467","target":"structure:5466","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5326","source":"structure:5467","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5313","source":"structure:5467","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5469","source":"structure:5467","target":"structure:5469","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5470","source":"structure:5467","target":"structure:5470","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5471","source":"structure:5467","target":"structure:5471","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5325","source":"structure:5467","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5330","source":"structure:5467","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5467:5465","source":"structure:5467","target":"structure:5465","type":"calls","label":"calls"}},{"data":{"id":"call:5468:5466","source":"structure:5468","target":"structure:5466","type":"calls","label":"calls"}},{"data":{"id":"call:5468:5326","source":"structure:5468","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5468:5467","source":"structure:5468","target":"structure:5467","type":"calls","label":"calls"}},{"data":{"id":"call:5468:5313","source":"structure:5468","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5470:5469","source":"structure:5470","target":"structure:5469","type":"calls","label":"calls"}},{"data":{"id":"call:5470:5326","source":"structure:5470","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5470:5313","source":"structure:5470","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5325","source":"structure:5471","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5326","source":"structure:5471","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5330","source":"structure:5471","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5465","source":"structure:5471","target":"structure:5465","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5468","source":"structure:5471","target":"structure:5468","type":"calls","label":"calls"}},{"data":{"id":"call:5471:5470","source":"structure:5471","target":"structure:5470","type":"calls","label":"calls"}},{"data":{"id":"call:5484:5491","source":"structure:5484","target":"structure:5491","type":"calls","label":"calls"}},{"data":{"id":"call:5484:5492","source":"structure:5484","target":"structure:5492","type":"calls","label":"calls"}},{"data":{"id":"call:5484:5493","source":"structure:5484","target":"structure:5493","type":"calls","label":"calls"}},{"data":{"id":"call:5496:5324","source":"structure:5496","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5497:5422","source":"structure:5497","target":"structure:5422","type":"calls","label":"calls"}},{"data":{"id":"call:5499:5324","source":"structure:5499","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5500:5324","source":"structure:5500","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5500:5425","source":"structure:5500","target":"structure:5425","type":"calls","label":"calls"}},{"data":{"id":"call:5500:5426","source":"structure:5500","target":"structure:5426","type":"calls","label":"calls"}},{"data":{"id":"call:5500:5352","source":"structure:5500","target":"structure:5352","type":"calls","label":"calls"}},{"data":{"id":"call:5500:5331","source":"structure:5500","target":"structure:5331","type":"calls","label":"calls"}},{"data":{"id":"call:5503:5324","source":"structure:5503","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5503:5430","source":"structure:5503","target":"structure:5430","type":"calls","label":"calls"}},{"data":{"id":"call:5504:5324","source":"structure:5504","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5505:5325","source":"structure:5505","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5505:5324","source":"structure:5505","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5505:5431","source":"structure:5505","target":"structure:5431","type":"calls","label":"calls"}},{"data":{"id":"call:5505:5425","source":"structure:5505","target":"structure:5425","type":"calls","label":"calls"}},{"data":{"id":"call:5505:5432","source":"structure:5505","target":"structure:5432","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5445","source":"structure:5515","target":"structure:5445","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5446","source":"structure:5515","target":"structure:5446","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5447","source":"structure:5515","target":"structure:5447","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5448","source":"structure:5515","target":"structure:5448","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5449","source":"structure:5515","target":"structure:5449","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5435","source":"structure:5515","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5437","source":"structure:5515","target":"structure:5437","type":"calls","label":"calls"}},{"data":{"id":"call:5515:5438","source":"structure:5515","target":"structure:5438","type":"calls","label":"calls"}},{"data":{"id":"call:5516:5446","source":"structure:5516","target":"structure:5446","type":"calls","label":"calls"}},{"data":{"id":"call:5516:5447","source":"structure:5516","target":"structure:5447","type":"calls","label":"calls"}},{"data":{"id":"call:5516:5448","source":"structure:5516","target":"structure:5448","type":"calls","label":"calls"}},{"data":{"id":"call:5516:5449","source":"structure:5516","target":"structure:5449","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5435","source":"structure:5517","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5437","source":"structure:5517","target":"structure:5437","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5438","source":"structure:5517","target":"structure:5438","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5447","source":"structure:5517","target":"structure:5447","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5436","source":"structure:5517","target":"structure:5436","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5439","source":"structure:5517","target":"structure:5439","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5441","source":"structure:5517","target":"structure:5441","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5442","source":"structure:5517","target":"structure:5442","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5440","source":"structure:5517","target":"structure:5440","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5444","source":"structure:5517","target":"structure:5444","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5443","source":"structure:5517","target":"structure:5443","type":"calls","label":"calls"}},{"data":{"id":"call:5517:5448","source":"structure:5517","target":"structure:5448","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5436","source":"structure:5518","target":"structure:5436","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5439","source":"structure:5518","target":"structure:5439","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5435","source":"structure:5518","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5441","source":"structure:5518","target":"structure:5441","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5442","source":"structure:5518","target":"structure:5442","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5440","source":"structure:5518","target":"structure:5440","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5444","source":"structure:5518","target":"structure:5444","type":"calls","label":"calls"}},{"data":{"id":"call:5518:5443","source":"structure:5518","target":"structure:5443","type":"calls","label":"calls"}},{"data":{"id":"call:5519:5435","source":"structure:5519","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5520:5435","source":"structure:5520","target":"structure:5435","type":"calls","label":"calls"}},{"data":{"id":"call:5521:5333","source":"structure:5521","target":"structure:5333","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5341","source":"structure:5523","target":"structure:5341","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5339","source":"structure:5523","target":"structure:5339","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5451","source":"structure:5523","target":"structure:5451","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5346","source":"structure:5523","target":"structure:5346","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5343","source":"structure:5523","target":"structure:5343","type":"calls","label":"calls"}},{"data":{"id":"call:5523:5452","source":"structure:5523","target":"structure:5452","type":"calls","label":"calls"}},{"data":{"id":"call:5524:5300","source":"structure:5524","target":"structure:5300","type":"calls","label":"calls"}},{"data":{"id":"call:5525:5330","source":"structure:5525","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5525:5310","source":"structure:5525","target":"structure:5310","type":"calls","label":"calls"}},{"data":{"id":"call:5525:5328","source":"structure:5525","target":"structure:5328","type":"calls","label":"calls"}},{"data":{"id":"call:5525:5324","source":"structure:5525","target":"structure:5324","type":"calls","label":"calls"}},{"data":{"id":"call:5528:5315","source":"structure:5528","target":"structure:5315","type":"calls","label":"calls"}},{"data":{"id":"call:5528:5316","source":"structure:5528","target":"structure:5316","type":"calls","label":"calls"}},{"data":{"id":"call:5531:5460","source":"structure:5531","target":"structure:5460","type":"calls","label":"calls"}},{"data":{"id":"call:5531:5461","source":"structure:5531","target":"structure:5461","type":"calls","label":"calls"}},{"data":{"id":"call:5534:5462","source":"structure:5534","target":"structure:5462","type":"calls","label":"calls"}},{"data":{"id":"call:5534:5326","source":"structure:5534","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5534:5464","source":"structure:5534","target":"structure:5464","type":"calls","label":"calls"}},{"data":{"id":"call:5534:5463","source":"structure:5534","target":"structure:5463","type":"calls","label":"calls"}},{"data":{"id":"call:5534:5313","source":"structure:5534","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5468","source":"structure:5536","target":"structure:5468","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5466","source":"structure:5536","target":"structure:5466","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5326","source":"structure:5536","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5313","source":"structure:5536","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5469","source":"structure:5536","target":"structure:5469","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5470","source":"structure:5536","target":"structure:5470","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5471","source":"structure:5536","target":"structure:5471","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5325","source":"structure:5536","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5330","source":"structure:5536","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5536:5465","source":"structure:5536","target":"structure:5465","type":"calls","label":"calls"}},{"data":{"id":"call:5537:5466","source":"structure:5537","target":"structure:5466","type":"calls","label":"calls"}},{"data":{"id":"call:5537:5326","source":"structure:5537","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5537:5467","source":"structure:5537","target":"structure:5467","type":"calls","label":"calls"}},{"data":{"id":"call:5537:5313","source":"structure:5537","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5539:5469","source":"structure:5539","target":"structure:5469","type":"calls","label":"calls"}},{"data":{"id":"call:5539:5326","source":"structure:5539","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5539:5313","source":"structure:5539","target":"structure:5313","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5325","source":"structure:5540","target":"structure:5325","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5326","source":"structure:5540","target":"structure:5326","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5330","source":"structure:5540","target":"structure:5330","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5465","source":"structure:5540","target":"structure:5465","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5468","source":"structure:5540","target":"structure:5468","type":"calls","label":"calls"}},{"data":{"id":"call:5540:5470","source":"structure:5540","target":"structure:5470","type":"calls","label":"calls"}},{"data":{"id":"call:5548:5491","source":"structure:5548","target":"structure:5491","type":"calls","label":"calls"}},{"data":{"id":"call:5548:5492","source":"structure:5548","target":"structure:5492","type":"calls","label":"calls"}}]},"dependencies":{"nodes":[{"data":{"id":"file:dist-test/src/cli/commands/import.js","label":"import.js","type":"file","file":"dist-test/src/cli/commands/import.js"}},{"data":{"id":"file:dist-test/src/cli/commands/init.js","label":"init.js","type":"file","file":"dist-test/src/cli/commands/init.js"}},{"data":{"id":"file:dist-test/src/cli/commands/mcp-serve.js","label":"mcp-serve.js","type":"file","file":"dist-test/src/cli/commands/mcp-serve.js"}},{"data":{"id":"file:dist-test/src/cli/commands/query.js","label":"query.js","type":"file","file":"dist-test/src/cli/commands/query.js"}},{"data":{"id":"file:dist-test/src/cli/commands/setup.js","label":"setup.js","type":"file","file":"dist-test/src/cli/commands/setup.js"}},{"data":{"id":"file:dist-test/src/cli/commands/start.js","label":"start.js","type":"file","file":"dist-test/src/cli/commands/start.js"}},{"data":{"id":"file:dist-test/src/cli/commands/status.js","label":"status.js","type":"file","file":"dist-test/src/cli/commands/status.js"}},{"data":{"id":"file:dist-test/src/cli/commands/stop.js","label":"stop.js","type":"file","file":"dist-test/src/cli/commands/stop.js"}},{"data":{"id":"file:dist-test/src/db/index.js","label":"index.js","type":"file","file":"dist-test/src/db/index.js"}},{"data":{"id":"file:dist-test/src/extractor/index.js","label":"index.js","type":"file","file":"dist-test/src/extractor/index.js"}},{"data":{"id":"file:dist-test/src/indexer/index.js","label":"index.js","type":"file","file":"dist-test/src/indexer/index.js"}},{"data":{"id":"file:dist-test/src/indexer/parsers/base.js","label":"base.js","type":"file","file":"dist-test/src/indexer/parsers/base.js"}},{"data":{"id":"file:dist-test/src/indexer/parsers/go.js","label":"go.js","type":"file","file":"dist-test/src/indexer/parsers/go.js"}},{"data":{"id":"file:dist-test/src/indexer/parsers/javascript.js","label":"javascript.js","type":"file","file":"dist-test/src/indexer/parsers/javascript.js"}},{"data":{"id":"file:dist-test/src/indexer/parsers/python.js","label":"python.js","type":"file","file":"dist-test/src/indexer/parsers/python.js"}},{"data":{"id":"file:dist-test/src/indexer/parsers/ruby.js","label":"ruby.js","type":"file","file":"dist-test/src/indexer/parsers/ruby.js"}},{"data":{"id":"file:dist-test/src/indexer/watcher.js","label":"watcher.js","type":"file","file":"dist-test/src/indexer/watcher.js"}},{"data":{"id":"file:dist-test/src/mcp/server.js","label":"server.js","type":"file","file":"dist-test/src/mcp/server.js"}},{"data":{"id":"file:dist-test/src/query/index.js","label":"index.js","type":"file","file":"dist-test/src/query/index.js"}},{"data":{"id":"file:dist-test/test/db.test.js","label":"db.test.js","type":"file","file":"dist-test/test/db.test.js"}},{"data":{"id":"file:dist-test/test/extractor.test.js","label":"extractor.test.js","type":"file","file":"dist-test/test/extractor.test.js"}},{"data":{"id":"file:dist-test/test/helpers.js","label":"helpers.js","type":"file","file":"dist-test/test/helpers.js"}},{"data":{"id":"file:dist-test/test/parsers.test.js","label":"parsers.test.js","type":"file","file":"dist-test/test/parsers.test.js"}},{"data":{"id":"file:dist-test/test/query.test.js","label":"query.test.js","type":"file","file":"dist-test/test/query.test.js"}},{"data":{"id":"file:src/cli/commands/import.ts","label":"import.ts","type":"file","file":"src/cli/commands/import.ts"}},{"data":{"id":"file:src/cli/commands/init.ts","label":"init.ts","type":"file","file":"src/cli/commands/init.ts"}},{"data":{"id":"file:src/cli/commands/mcp-serve.ts","label":"mcp-serve.ts","type":"file","file":"src/cli/commands/mcp-serve.ts"}},{"data":{"id":"file:src/cli/commands/query.ts","label":"query.ts","type":"file","file":"src/cli/commands/query.ts"}},{"data":{"id":"file:src/cli/commands/setup.ts","label":"setup.ts","type":"file","file":"src/cli/commands/setup.ts"}},{"data":{"id":"file:src/cli/commands/start.ts","label":"start.ts","type":"file","file":"src/cli/commands/start.ts"}},{"data":{"id":"file:src/cli/commands/status.ts","label":"status.ts","type":"file","file":"src/cli/commands/status.ts"}},{"data":{"id":"file:src/cli/commands/stop.ts","label":"stop.ts","type":"file","file":"src/cli/commands/stop.ts"}},{"data":{"id":"file:src/cli/commands/visualize.ts","label":"visualize.ts","type":"file","file":"src/cli/commands/visualize.ts"}},{"data":{"id":"file:src/db/index.ts","label":"index.ts","type":"file","file":"src/db/index.ts"}},{"data":{"id":"file:src/extractor/index.ts","label":"index.ts","type":"file","file":"src/extractor/index.ts"}},{"data":{"id":"file:src/indexer/index.ts","label":"index.ts","type":"file","file":"src/indexer/index.ts"}},{"data":{"id":"file:src/indexer/parsers/base.ts","label":"base.ts","type":"file","file":"src/indexer/parsers/base.ts"}},{"data":{"id":"file:src/indexer/parsers/go.ts","label":"go.ts","type":"file","file":"src/indexer/parsers/go.ts"}},{"data":{"id":"file:src/indexer/parsers/javascript.ts","label":"javascript.ts","type":"file","file":"src/indexer/parsers/javascript.ts"}},{"data":{"id":"file:src/indexer/parsers/python.ts","label":"python.ts","type":"file","file":"src/indexer/parsers/python.ts"}},{"data":{"id":"file:src/indexer/parsers/ruby.ts","label":"ruby.ts","type":"file","file":"src/indexer/parsers/ruby.ts"}},{"data":{"id":"file:src/indexer/watcher.ts","label":"watcher.ts","type":"file","file":"src/indexer/watcher.ts"}},{"data":{"id":"file:src/mcp/server.ts","label":"server.ts","type":"file","file":"src/mcp/server.ts"}},{"data":{"id":"file:src/proxy/interceptor.py","label":"interceptor.py","type":"file","file":"src/proxy/interceptor.py"}},{"data":{"id":"file:src/query/index.ts","label":"index.ts","type":"file","file":"src/query/index.ts"}},{"data":{"id":"file:src/types/index.ts","label":"index.ts","type":"file","file":"src/types/index.ts"}},{"data":{"id":"file:src/visualize/index.ts","label":"index.ts","type":"file","file":"src/visualize/index.ts"}},{"data":{"id":"file:src/visualize/server.ts","label":"server.ts","type":"file","file":"src/visualize/server.ts"}},{"data":{"id":"file:src/visualize/template.ts","label":"template.ts","type":"file","file":"src/visualize/template.ts"}},{"data":{"id":"file:test/db.test.ts","label":"db.test.ts","type":"file","file":"test/db.test.ts"}},{"data":{"id":"file:test/extractor.test.ts","label":"extractor.test.ts","type":"file","file":"test/extractor.test.ts"}},{"data":{"id":"file:test/helpers.ts","label":"helpers.ts","type":"file","file":"test/helpers.ts"}},{"data":{"id":"file:test/parsers.test.ts","label":"parsers.test.ts","type":"file","file":"test/parsers.test.ts"}},{"data":{"id":"file:test/query.test.ts","label":"query.test.ts","type":"file","file":"test/query.test.ts"}}],"edges":[]},"classes":{"nodes":[{"data":{"id":"structure:5553","label":"interface","type":"interface","file":"dist-test/src/indexer/parsers/go.js","line":7,"signature":"interface\n    interface","content":"    // type Name interface\n    interface: /^type\\s+(\\w+)\\s+interface\\s*\\{/gm,\n    // type Name = ... or type Name ...\n    typeAlias: /^type\\s+(\\w+)\\s+(?!=)/gm,\n};"}},{"data":{"id":"structure:5549","label":"Name","type":"class","file":"dist-test/src/indexer/parsers/javascript.js","line":8,"signature":"class Name","content":"    // class Name\n    class: /(?:export\\s+)?(?:abstract\\s+)?class\\s+(\\w+)(?:\\s+extends\\s+\\w+)?(?:\\s+implements\\s+[\\w,\\s]+)?/g,\n    // Method inside class: name(...) or async name(...)\n    method: /^\\s*(?:async\\s+)?(?:static\\s+)?(?:get\\s+|set\\s+)?(\\w+)\\s*\\(([^)]*)\\)\\s*(?::\\s*\\w+)?\\s*\\{/gm,\n    // interface Name\n    interface: /(?:export\\s+)?interface\\s+(\\w+)(?:\\s+extends\\s+[\\w,\\s]+)?/g,\n    // type Name =\n    typeAlias: /(?:export\\s+)?type\\s+(\\w+)\\s*(?:\u003c[^\u003e]+\u003e)?\\s*=/g,\n};"}},{"data":{"id":"structure:5550","label":"Name","type":"interface","file":"dist-test/src/indexer/parsers/javascript.js","line":12,"signature":"interface Name","content":"    // interface Name\n    interface: /(?:export\\s+)?interface\\s+(\\w+)(?:\\s+extends\\s+[\\w,\\s]+)?/g,\n    // type Name =\n    typeAlias: /(?:export\\s+)?type\\s+(\\w+)\\s*(?:\u003c[^\u003e]+\u003e)?\\s*=/g,\n};\nfunction findBlockEnd(content, startPos) {\n    let depth = 0;\n    let inString = false;\n    let stringChar = '';\n    let i = startPos;\n    // Find opening brace\n    while (i \u003c content.length \u0026\u0026 content[i] !== '{')\n        i++;\n    if (i \u003e= content.length)\n        return content.length;\n    // Find matching closing brace\n    for (; i \u003c content.length; i++) {\n        const char = content[i];\n        const prevChar = i \u003e 0 ? content[i - 1] : '';\n        if (inString) {\n            if (char === stringChar \u0026\u0026 prevChar !== '\\\\') {\n                inString = false;\n            }\n            continue;\n        }\n        if (char === '\"' || char === \"'\" || char === '`') {\n            inString = true;\n            stringChar = char;\n            continue;\n        }\n        if (char === '{')\n            depth++;\n        if (char === '}') {\n            depth--;\n            if (depth === 0)\n                return i + 1;\n        }\n    }\n    return content.length;\n}\nexport const javascriptParser = {\n    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\n    parse(content, filePath) {\n        const structures = [];\n        const lines = content.split('\\n');\n        // Parse functions\n        let match;\n        patterns.function.lastIndex = 0;\n        while ((match = patterns.function.exec(content)) !== null) {\n            const name = match[1];\n            const params = match[2];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'function',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `function ${name}(${params})`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n            });\n        }\n        // Parse arrow functions\n        patterns.arrowFunction.lastIndex = 0;\n        while ((match = patterns.arrowFunction.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'function',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `const ${name} = () =\u003e ...`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: { arrow: true },\n            });\n        }\n        // Parse classes\n        patterns.class.lastIndex = 0;\n        while ((match = patterns.class.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'class',\n                name,\n                lineStart,\n                lineEnd,\n                signature: match[0].trim(),\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        // Parse interfaces\n        patterns.interface.lastIndex = 0;\n        while ((match = patterns.interface.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            const blockEnd = findBlockEnd(content, match.index);\n            const lineEnd = getLineNumber(content, blockEnd);\n            structures.push({\n                type: 'interface',\n                name,\n                lineStart,\n                lineEnd,\n                signature: match[0].trim(),\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        // Parse type aliases\n        patterns.typeAlias.lastIndex = 0;\n        while ((match = patterns.typeAlias.exec(content)) !== null) {\n            const name = match[1];\n            const lineStart = getLineNumber(content, match.index);\n            // Type aliases end at semicolon or next line with different indent\n            let lineEnd = lineStart;\n            for (let i = lineStart; i \u003c lines.length; i++) {\n                if (lines[i].includes(';') || (i \u003e lineStart \u0026\u0026 !lines[i].startsWith(' ') \u0026\u0026 !lines[i].startsWith('\\t'))) {\n                    lineEnd = i + 1;\n                    break;\n                }\n            }\n            structures.push({\n                type: 'type',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `type ${name}`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        return structures;\n    },\n};\n//# sourceMappingURL=javascript.js.map"}},{"data":{"id":"structure:5544","label":"Name","type":"class","file":"dist-test/src/indexer/parsers/python.js","line":5,"signature":"class Name","content":"    // class Name:\n    class: /^(\\s*)class\\s+(\\w+)(?:\\s*\\([^)]*\\))?:/gm,\n};\nfunction findPythonBlockEnd(content, startLine, indent) {\n    const lines = content.split('\\n');\n    const indentLevel = indent.length;\n    for (let i = startLine; i \u003c lines.length; i++) {\n        const line = lines[i];\n        // Skip empty lines and comments\n        if (line.trim() === '' || line.trim().startsWith('#'))\n            continue;\n        // Check if this line has less or equal indentation (and is not empty)\n        const lineIndent = line.match(/^(\\s*)/)?.[1] || '';\n        if (lineIndent.length \u003c= indentLevel \u0026\u0026 line.trim() !== '') {\n            return i; // Return the line number (0-indexed) where block ends\n        }\n    }\n    return lines.length;\n}"}},{"data":{"id":"structure:5545","label":"above","type":"class","file":"dist-test/src/indexer/parsers/python.js","line":40,"signature":"class above","content":"                // Check if this is a method by looking for a class above\n                const linesAbove = content.slice(0, match.index).split('\\n');\n                let isMethod = false;\n                for (let i = linesAbove.length - 1; i \u003e= 0; i--) {\n                    const line = linesAbove[i];\n                    if (line.match(/^class\\s+\\w+/)) {\n                        isMethod = true;\n                        break;\n                    }\n                    // If we hit a non-indented non-empty line that's not a class, stop\n                    if (line.trim() !== '' \u0026\u0026 !line.startsWith(' ') \u0026\u0026 !line.startsWith('\\t')) {\n                        break;\n                    }\n                }\n                if (isMethod) {\n                    structures.push({\n                        type: 'method',\n                        name,\n                        lineStart,\n                        lineEnd,\n                        signature: `def ${name}(${params})`,\n                        rawContent: extractLines(content, lineStart, lineEnd),\n                        metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n                    });\n                    continue;\n                }\n            }\n            structures.push({\n                type: 'function',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `def ${name}(${params})`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n            });\n        }\n        // Parse classes\n        patterns.class.lastIndex = 0;\n        while ((match = patterns.class.exec(content)) !== null) {\n            const indent = match[1];\n            const name = match[2];\n            const lineStart = getLineNumber(content, match.index);\n            const lineEnd = findPythonBlockEnd(content, lineStart, indent);\n            structures.push({\n                type: 'class',\n                name,\n                lineStart,\n                lineEnd,\n                signature: `class ${name}`,\n                rawContent: extractLines(content, lineStart, lineEnd),\n                metadata: {},\n            });\n        }\n        return structures;\n    },\n};\n//# sourceMappingURL=python.js.map"}},{"data":{"id":"structure:5542","label":"Name","type":"class","file":"dist-test/src/indexer/parsers/ruby.js","line":5,"signature":"class Name","content":"    // class Name\n    class: /^\\s*class\\s+(\\w+)(?:\\s*\u003c\\s*\\w+)?/gm,\n    // module Name\n    module: /^\\s*module\\s+(\\w+)/gm,\n};\nfunction findRubyBlockEnd(content, startLine) {\n    const lines = content.split('\\n');\n    let depth = 1;\n    for (let i = startLine; i \u003c lines.length; i++) {\n        const line = lines[i];\n        // Count block openers\n        if (line.match(/\\b(class|module|def|do|if|unless|case|while|until|for|begin)\\b/) \u0026\u0026 !line.match(/\\bend\\b/)) {\n            depth++;\n        }\n        // Count block closers\n        if (line.match(/\\bend\\b/)) {\n            depth--;\n            if (depth === 0) {\n                return i + 1;\n            }\n        }\n    }\n    return lines.length;\n}"}},{"data":{"id":"structure:5366","label":"name","type":"class","file":"dist-test/src/mcp/server.js","line":25,"signature":"class name","content":"                            description: 'Search query - can be a function name, class name, or keyword',\n                        },\n                        type: {\n                            type: 'string',\n                            enum: ['all', 'structures', 'conversations'],\n                            description: 'What to search: all, structures, or conversations',\n                            default: 'all',\n                        },"}},{"data":{"id":"structure:5367","label":"to","type":"class","file":"dist-test/src/mcp/server.js","line":78,"signature":"class to","content":"                            description: 'Name of the function or class to verify',\n                        },\n                        type: {\n                            type: 'string',\n                            enum: ['structure', 'file'],\n                            description: 'Type of entity to verify',\n                            default: 'structure',\n                        },"}},{"data":{"id":"structure:5231","label":"to","type":"class","file":"dist-test/test/extractor.test.js","line":167,"signature":"class to","content":"                    content: \"I'll update the UserService class to include a new validateCredentials method for authentication.\"\n                }\n            ];\n            const extractions = extractDecisions(messages);\n            // Should extract class and method names as entities\n            const withEntities = extractions.filter(e =\u003e e.mentionedEntities.length \u003e 0);\n            assert.ok(withEntities.length \u003e 0 || extractions.length \u003e 0);\n        });\n        it('should handle empty messages', () =\u003e {\n            const messages = [];\n            const extractions = extractDecisions(messages);\n            assert.strictEqual(extractions.length, 0);\n        });"}},{"data":{"id":"structure:5232","label":"and","type":"class","file":"dist-test/test/extractor.test.js","line":171,"signature":"class and","content":"            // Should extract class and method names as entities\n            const withEntities = extractions.filter(e =\u003e e.mentionedEntities.length \u003e 0);\n            assert.ok(withEntities.length \u003e 0 || extractions.length \u003e 0);\n        });\n        it('should handle empty messages', () =\u003e {\n            const messages = [];\n            const extractions = extractDecisions(messages);\n            assert.strictEqual(extractions.length, 0);\n        });"}},{"data":{"id":"structure:5201","label":"declaration","type":"class","file":"dist-test/test/parsers.test.js","line":110,"signature":"class declaration","content":"        it('should parse class declaration', () =\u003e {\n            const code = `class User {\n  constructor(name) {\n    this.name = name;\n  }\n}`;\n            const structures = javascriptParser.parse(code, 'test.js');\n            assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'User'));\n        });"}},{"data":{"id":"structure:5202","label":"User","type":"class","file":"dist-test/test/parsers.test.js","line":111,"signature":"class User","content":"            const code = `class User {\n  constructor(name) {\n    this.name = name;\n  }\n}`;"}},{"data":{"id":"structure:5203","label":"with","type":"class","file":"dist-test/test/parsers.test.js","line":119,"signature":"class with","content":"        it('should parse class with extends', () =\u003e {\n            const code = `class Admin extends User {\n  constructor(name, role) {\n    super(name);\n    this.role = role;\n  }\n}`;\n            const structures = javascriptParser.parse(code, 'test.js');\n            const classStructure = structures.find(s =\u003e s.type === 'class');\n            assert.ok(classStructure);\n            assert.strictEqual(classStructure.name, 'Admin');\n            assert.ok(classStructure.signature?.includes('extends'));\n        });"}},{"data":{"id":"structure:5204","label":"Admin","type":"class","file":"dist-test/test/parsers.test.js","line":120,"signature":"class Admin extends User","content":"            const code = `class Admin extends User {\n  constructor(name, role) {\n    super(name);\n    this.role = role;\n  }\n}`;"}},{"data":{"id":"structure:5205","label":"Service","type":"class","file":"dist-test/test/parsers.test.js","line":133,"signature":"export class Service","content":"            const code = `export class Service {\n  run() {}\n}`;"}},{"data":{"id":"structure:5214","label":"declaration","type":"interface","file":"dist-test/test/parsers.test.js","line":141,"signature":"interface declaration","content":"        it('should parse interface declaration', () =\u003e {\n            const code = `interface Config {\n  host: string;\n  port: number;\n}`;\n            const structures = javascriptParser.parse(code, 'test.ts');\n            assert.strictEqual(structures.length, 1);\n            assert.strictEqual(structures[0].type, 'interface');\n            assert.strictEqual(structures[0].name, 'Config');\n        });"}},{"data":{"id":"structure:5215","label":"Config","type":"interface","file":"dist-test/test/parsers.test.js","line":142,"signature":"interface Config","content":"            const code = `interface Config {\n  host: string;\n  port: number;\n}`;"}},{"data":{"id":"structure:5216","label":"Options","type":"interface","file":"dist-test/test/parsers.test.js","line":152,"signature":"export interface Options","content":"            const code = `export interface Options {\n  debug: boolean;\n}`;"}},{"data":{"id":"structure:5217","label":"with","type":"interface","file":"dist-test/test/parsers.test.js","line":158,"signature":"interface with","content":"        it('should parse interface with extends', () =\u003e {\n            const code = `interface ExtendedConfig extends Config {\n  timeout: number;\n}`;\n            const structures = javascriptParser.parse(code, 'test.ts');\n            assert.ok(structures[0].signature?.includes('extends'));\n        });"}},{"data":{"id":"structure:5218","label":"ExtendedConfig","type":"interface","file":"dist-test/test/parsers.test.js","line":159,"signature":"interface ExtendedConfig extends Config","content":"            const code = `interface ExtendedConfig extends Config {\n  timeout: number;\n}`;"}},{"data":{"id":"structure:5219","label":"UserData","type":"interface","file":"dist-test/test/parsers.test.js","line":183,"signature":"interface UserData","content":"interface UserData {\n  id: number;\n  name: string;\n}"}},{"data":{"id":"structure:5206","label":"UserService","type":"class","file":"dist-test/test/parsers.test.js","line":190,"signature":"export class UserService","content":"export class UserService {\n  private users: Map\u003cnumber, UserData\u003e = new Map();\n\n  async getUser(id: UserID): Promise\u003cUserData | null\u003e {\n    return this.users.get(id) || null;\n  }\n}"}},{"data":{"id":"structure:5207","label":"definition","type":"class","file":"dist-test/test/parsers.test.js","line":256,"signature":"class definition","content":"        it('should parse class definition', () =\u003e {\n            const code = `class User:\n    def __init__(self, name):\n        self.name = name`;\n            const structures = pythonParser.parse(code, 'test.py');\n            const classStructure = structures.find(s =\u003e s.type === 'class');\n            assert.ok(classStructure);\n            assert.strictEqual(classStructure.name, 'User');\n        });"}},{"data":{"id":"structure:5208","label":"User","type":"class","file":"dist-test/test/parsers.test.js","line":257,"signature":"class User","content":"            const code = `class User:\n    def __init__(self, name):\n        self.name = name`;\n            const structures = pythonParser.parse(code, 'test.py');\n            const classStructure = structures.find(s =\u003e s.type === 'class');\n            assert.ok(classStructure);\n            assert.strictEqual(classStructure.name, 'User');\n        });\n        it('should parse class with inheritance', () =\u003e {\n            const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n            const structures = pythonParser.parse(code, 'test.py');\n            assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n        });"}},{"data":{"id":"structure:5209","label":"with","type":"class","file":"dist-test/test/parsers.test.js","line":265,"signature":"class with","content":"        it('should parse class with inheritance', () =\u003e {\n            const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n            const structures = pythonParser.parse(code, 'test.py');\n            assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n        });"}},{"data":{"id":"structure:5210","label":"Admin","type":"class","file":"dist-test/test/parsers.test.js","line":266,"signature":"class Admin","content":"            const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n            const structures = pythonParser.parse(code, 'test.py');\n            assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n        });\n        it('should parse methods inside class', () =\u003e {\n            const code = `class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b`;\n            const structures = pythonParser.parse(code, 'test.py');\n            const methods = structures.filter(s =\u003e s.type === 'method');\n            assert.strictEqual(methods.length, 2);\n            assert.ok(methods.some(m =\u003e m.name === 'add'));\n            assert.ok(methods.some(m =\u003e m.name === 'subtract'));\n        });"}},{"data":{"id":"structure:5211","label":"Calculator","type":"class","file":"dist-test/test/parsers.test.js","line":274,"signature":"class Calculator","content":"            const code = `class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b`;\n            const structures = pythonParser.parse(code, 'test.py');\n            const methods = structures.filter(s =\u003e s.type === 'method');\n            assert.strictEqual(methods.length, 2);\n            assert.ok(methods.some(m =\u003e m.name === 'add'));\n            assert.ok(methods.some(m =\u003e m.name === 'subtract'));\n        });\n    });\n    describe('Complex Files', () =\u003e {\n        it('should parse a file with mixed declarations', () =\u003e {\n            const code = `def helper_function():\n    return \"helper\"\n\nclass DataProcessor:\n    def __init__(self):\n        self.data = []\n\n    def process(self, item):\n        self.data.append(item)\n\ndef main():\n    processor = DataProcessor()\n    processor.process(\"item\")\n`;\n            const structures = pythonParser.parse(code, 'processor.py');\n            const functions = structures.filter(s =\u003e s.type === 'function');\n            const classes = structures.filter(s =\u003e s.type === 'class');\n            const methods = structures.filter(s =\u003e s.type === 'method');\n            // Should find top-level functions (helper_function and main)\n            assert.ok(functions.some(f =\u003e f.name === 'helper_function'), 'Should find helper_function');\n            // Should find the class\n            assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n            // Should find at least some methods\n            assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n            // Total structures should be reasonable\n            assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);\n        });\n    });"}},{"data":{"id":"structure:5212","label":"DataProcessor","type":"class","file":"dist-test/test/parsers.test.js","line":292,"signature":"class DataProcessor","content":"class DataProcessor:\n    def __init__(self):\n        self.data = []\n\n    def process(self, item):\n        self.data.append(item)\n\ndef main():\n    processor = DataProcessor()\n    processor.process(\"item\")\n`;\n            const structures = pythonParser.parse(code, 'processor.py');\n            const functions = structures.filter(s =\u003e s.type === 'function');\n            const classes = structures.filter(s =\u003e s.type === 'class');\n            const methods = structures.filter(s =\u003e s.type === 'method');\n            // Should find top-level functions (helper_function and main)\n            assert.ok(functions.some(f =\u003e f.name === 'helper_function'), 'Should find helper_function');\n            // Should find the class\n            assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n            // Should find at least some methods\n            assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n            // Total structures should be reasonable\n            assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);"}},{"data":{"id":"structure:5213","label":"assert","type":"class","file":"dist-test/test/parsers.test.js","line":309,"signature":"class\n            assert","content":"            // Should find the class\n            assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n            // Should find at least some methods\n            assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n            // Total structures should be reasonable\n            assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);"}},{"data":{"id":"structure:5189","label":"UserService","type":"class","file":"dist-test/test/query.test.js","line":178,"signature":"class UserService","content":"                        signature: 'class UserService',\n                        content: 'class UserService { }'"}},{"data":{"id":"structure:5190","label":"UserService","type":"class","file":"dist-test/test/query.test.js","line":179,"signature":"class UserService","content":"                        content: 'class UserService { }'"}},{"data":{"id":"structure:5472","label":"ImportOptions","type":"interface","file":"src/cli/commands/import.ts","line":31,"signature":"interface ImportOptions","content":"interface ImportOptions {\n  project?: string;\n  source?: ImportSource;\n  dryRun?: boolean;\n  limit?: number;\n  full?: boolean;  // Store complete conversation content, not just extractions\n}"}},{"data":{"id":"structure:5473","label":"ImportResult","type":"interface","file":"src/cli/commands/import.ts","line":39,"signature":"interface ImportResult","content":"interface ImportResult {\n  source: string;\n  messages: number;\n  extractions: number;\n  duplicates: number;\n}"}},{"data":{"id":"structure:5474","label":"ClaudeMessage","type":"interface","file":"src/cli/commands/import.ts","line":46,"signature":"interface ClaudeMessage","content":"interface ClaudeMessage {\n  type: string;\n  message?: {\n    role: string;\n    content: Array\u003c{ type: string; text?: string; thinking?: string }\u003e | string;\n  };\n  cwd?: string;\n  timestamp?: string;\n  sessionId?: string;\n}"}},{"data":{"id":"structure:5475","label":"ContinueSession","type":"interface","file":"src/cli/commands/import.ts","line":454,"signature":"interface ContinueSession","content":"interface ContinueSession {\n  history?: Array\u003c{\n    role: string;\n    content: string;\n  }\u003e;\n}"}},{"data":{"id":"structure:5454","label":"QueryOptions","type":"interface","file":"src/cli/commands/query.ts","line":5,"signature":"interface QueryOptions","content":"interface QueryOptions {\n  type?: 'all' | 'structures' | 'conversations';\n  limit?: number;\n  global?: boolean;\n}"}},{"data":{"id":"structure:5450","label":"ClaudeSettings","type":"interface","file":"src/cli/commands/setup.ts","line":11,"signature":"interface ClaudeSettings","content":"interface ClaudeSettings {\n  [key: string]: unknown;\n  mcpServers?: {\n    [name: string]: {\n      command: string;\n      args?: string[];\n    };\n  };\n}"}},{"data":{"id":"structure:5434","label":"StartOptions","type":"interface","file":"src/cli/commands/start.ts","line":23,"signature":"interface StartOptions","content":"interface StartOptions {\n  proxy?: boolean;\n  watcher?: boolean;\n  port?: number;\n}"}},{"data":{"id":"structure:5428","label":"ServiceStatus","type":"interface","file":"src/cli/commands/status.ts","line":20,"signature":"interface ServiceStatus","content":"interface ServiceStatus {\n  running: boolean;\n  pid?: number;\n}"}},{"data":{"id":"structure:5424","label":"StopOptions","type":"interface","file":"src/cli/commands/stop.ts","line":33,"signature":"interface StopOptions","content":"interface StopOptions {\n  proxy?: boolean;\n  watcher?: boolean;\n}"}},{"data":{"id":"structure:5421","label":"VisualizeOptions","type":"interface","file":"src/cli/commands/visualize.ts","line":15,"signature":"export interface VisualizeOptions","content":"export interface VisualizeOptions {\n  output?: string;\n  open?: boolean;\n  serve?: boolean;\n  port?: number;\n}"}},{"data":{"id":"structure:5361","label":"StructureWithFile","type":"interface","file":"src/db/index.ts","line":361,"signature":"export interface StructureWithFile extends Structure","content":"export interface StructureWithFile extends Structure {\n  file_path: string;\n}"}},{"data":{"id":"structure:5322","label":"TranscriptMessage","type":"interface","file":"src/extractor/index.ts","line":3,"signature":"export interface TranscriptMessage","content":"export interface TranscriptMessage {\n  type: string;\n  role?: string;\n  content?: string | { type: string; text?: string }[];\n  tool_name?: string;\n  tool_input?: Record\u003cstring, unknown\u003e;\n  tool_result?: unknown;\n}"}},{"data":{"id":"structure:5323","label":"ExtractedItem","type":"interface","file":"src/extractor/index.ts","line":12,"signature":"export interface ExtractedItem","content":"export interface ExtractedItem {\n  type: 'decision' | 'rejection' | 'pattern' | 'question';\n  content: string;\n  mentionedEntities: string[];\n  metadata: Record\u003cstring, unknown\u003e;\n}"}},{"data":{"id":"structure:5312","label":"PendingCall","type":"interface","file":"src/indexer/index.ts","line":13,"signature":"interface PendingCall","content":"interface PendingCall {\n  callerId: number;\n  calledName: string;\n}"}},{"data":{"id":"structure:5494","label":"ParsedStructure","type":"interface","file":"src/indexer/parsers/base.ts","line":3,"signature":"export interface ParsedStructure","content":"export interface ParsedStructure {\n  type: StructureType;\n  name: string;\n  lineStart: number;\n  lineEnd: number;\n  signature: string | null;\n  rawContent: string;\n  metadata: Record\u003cstring, unknown\u003e;\n  calls?: string[];  // Function/method names called within this structure\n}"}},{"data":{"id":"structure:5495","label":"Parser","type":"interface","file":"src/indexer/parsers/base.ts","line":14,"signature":"export interface Parser","content":"export interface Parser {\n  extensions: string[];\n  parse(content: string, filePath: string): ParsedStructure[];\n}"}},{"data":{"id":"structure:5489","label":"interface","type":"interface","file":"src/indexer/parsers/go.ts","line":11,"signature":"interface\n  interface","content":"  // type Name interface\n  interface: /^type\\s+(\\w+)\\s+interface\\s*\\{/gm,\n\n  // type Name = ... or type Name ...\n  typeAlias: /^type\\s+(\\w+)\\s+(?!=)/gm,\n};"}},{"data":{"id":"structure:5485","label":"Name","type":"class","file":"src/indexer/parsers/javascript.ts","line":12,"signature":"class Name","content":"  // class Name\n  class: /(?:export\\s+)?(?:abstract\\s+)?class\\s+(\\w+)(?:\\s+extends\\s+\\w+)?(?:\\s+implements\\s+[\\w,\\s]+)?/g,\n\n  // Method inside class: name(...) or async name(...)\n  method: /^\\s*(?:async\\s+)?(?:static\\s+)?(?:get\\s+|set\\s+)?(\\w+)\\s*\\(([^)]*)\\)\\s*(?::\\s*\\w+)?\\s*\\{/gm,\n\n  // interface Name\n  interface: /(?:export\\s+)?interface\\s+(\\w+)(?:\\s+extends\\s+[\\w,\\s]+)?/g,\n\n  // type Name =\n  typeAlias: /(?:export\\s+)?type\\s+(\\w+)\\s*(?:\u003c[^\u003e]+\u003e)?\\s*=/g,\n};"}},{"data":{"id":"structure:5486","label":"Name","type":"interface","file":"src/indexer/parsers/javascript.ts","line":18,"signature":"interface Name","content":"  // interface Name\n  interface: /(?:export\\s+)?interface\\s+(\\w+)(?:\\s+extends\\s+[\\w,\\s]+)?/g,\n\n  // type Name =\n  typeAlias: /(?:export\\s+)?type\\s+(\\w+)\\s*(?:\u003c[^\u003e]+\u003e)?\\s*=/g,\n};\n\nfunction findBlockEnd(content: string, startPos: number): number {\n  let depth = 0;\n  let inString = false;\n  let stringChar = '';\n  let i = startPos;\n\n  // Find opening brace\n  while (i \u003c content.length \u0026\u0026 content[i] !== '{') i++;\n  if (i \u003e= content.length) return content.length;\n\n  // Find matching closing brace\n  for (; i \u003c content.length; i++) {\n    const char = content[i];\n    const prevChar = i \u003e 0 ? content[i - 1] : '';\n\n    if (inString) {\n      if (char === stringChar \u0026\u0026 prevChar !== '\\\\') {\n        inString = false;\n      }\n      continue;\n    }\n\n    if (char === '\"' || char === \"'\" || char === '`') {\n      inString = true;\n      stringChar = char;\n      continue;\n    }\n\n    if (char === '{') depth++;\n    if (char === '}') {\n      depth--;\n      if (depth === 0) return i + 1;\n    }\n  }\n\n  return content.length;\n}\n\nexport const javascriptParser: Parser = {\n  extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\n\n  parse(content: string, filePath: string): ParsedStructure[] {\n    const structures: ParsedStructure[] = [];\n    const lines = content.split('\\n');\n\n    // Parse functions\n    let match;\n    patterns.function.lastIndex = 0;\n    while ((match = patterns.function.exec(content)) !== null) {\n      const name = match[1];\n      const params = match[2];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n      const rawContent = extractLines(content, lineStart, lineEnd);\n\n      structures.push({\n        type: 'function',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `function ${name}(${params})`,\n        rawContent,\n        metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n        calls: extractCalls(rawContent, name),\n      });\n    }\n\n    // Parse arrow functions\n    patterns.arrowFunction.lastIndex = 0;\n    while ((match = patterns.arrowFunction.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n      const rawContent = extractLines(content, lineStart, lineEnd);\n\n      structures.push({\n        type: 'function',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `const ${name} = () =\u003e ...`,\n        rawContent,\n        metadata: { arrow: true },\n        calls: extractCalls(rawContent, name),\n      });\n    }\n\n    // Parse classes\n    patterns.class.lastIndex = 0;\n    while ((match = patterns.class.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n\n      structures.push({\n        type: 'class',\n        name,\n        lineStart,\n        lineEnd,\n        signature: match[0].trim(),\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    // Parse interfaces\n    patterns.interface.lastIndex = 0;\n    while ((match = patterns.interface.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      const blockEnd = findBlockEnd(content, match.index);\n      const lineEnd = getLineNumber(content, blockEnd);\n\n      structures.push({\n        type: 'interface',\n        name,\n        lineStart,\n        lineEnd,\n        signature: match[0].trim(),\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    // Parse type aliases\n    patterns.typeAlias.lastIndex = 0;\n    while ((match = patterns.typeAlias.exec(content)) !== null) {\n      const name = match[1];\n      const lineStart = getLineNumber(content, match.index);\n      // Type aliases end at semicolon or next line with different indent\n      let lineEnd = lineStart;\n      for (let i = lineStart; i \u003c lines.length; i++) {\n        if (lines[i].includes(';') || (i \u003e lineStart \u0026\u0026 !lines[i].startsWith(' ') \u0026\u0026 !lines[i].startsWith('\\t'))) {\n          lineEnd = i + 1;\n          break;\n        }\n      }\n\n      structures.push({\n        type: 'type',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `type ${name}`,\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    return structures;\n  },\n};\n"}},{"data":{"id":"structure:5480","label":"Name","type":"class","file":"src/indexer/parsers/python.ts","line":8,"signature":"class Name","content":"  // class Name:\n  class: /^(\\s*)class\\s+(\\w+)(?:\\s*\\([^)]*\\))?:/gm,\n};\n\nfunction findPythonBlockEnd(content: string, startLine: number, indent: string): number {\n  const lines = content.split('\\n');\n  const indentLevel = indent.length;\n\n  for (let i = startLine; i \u003c lines.length; i++) {\n    const line = lines[i];\n    // Skip empty lines and comments\n    if (line.trim() === '' || line.trim().startsWith('#')) continue;\n\n    // Check if this line has less or equal indentation (and is not empty)\n    const lineIndent = line.match(/^(\\s*)/)?.[1] || '';\n    if (lineIndent.length \u003c= indentLevel \u0026\u0026 line.trim() !== '') {\n      return i; // Return the line number (0-indexed) where block ends\n    }\n  }\n\n  return lines.length;\n}"}},{"data":{"id":"structure:5481","label":"above","type":"class","file":"src/indexer/parsers/python.ts","line":50,"signature":"class above","content":"        // Check if this is a method by looking for a class above\n        const linesAbove = content.slice(0, match.index).split('\\n');\n        let isMethod = false;\n        for (let i = linesAbove.length - 1; i \u003e= 0; i--) {\n          const line = linesAbove[i];\n          if (line.match(/^class\\s+\\w+/)) {\n            isMethod = true;\n            break;\n          }\n          // If we hit a non-indented non-empty line that's not a class, stop\n          if (line.trim() !== '' \u0026\u0026 !line.startsWith(' ') \u0026\u0026 !line.startsWith('\\t')) {\n            break;\n          }\n        }\n\n        if (isMethod) {\n          const rawContent = extractLines(content, lineStart, lineEnd);\n          structures.push({\n            type: 'method',\n            name,\n            lineStart,\n            lineEnd,\n            signature: `def ${name}(${params})`,\n            rawContent,\n            metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n            calls: extractCalls(rawContent, name),\n          });\n          continue;\n        }\n      }\n\n      const rawContent = extractLines(content, lineStart, lineEnd);\n      structures.push({\n        type: 'function',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `def ${name}(${params})`,\n        rawContent,\n        metadata: { params: params.split(',').map(p =\u003e p.trim()).filter(Boolean) },\n        calls: extractCalls(rawContent, name),\n      });\n    }\n\n    // Parse classes\n    patterns.class.lastIndex = 0;\n    while ((match = patterns.class.exec(content)) !== null) {\n      const indent = match[1];\n      const name = match[2];\n      const lineStart = getLineNumber(content, match.index);\n      const lineEnd = findPythonBlockEnd(content, lineStart, indent);\n\n      structures.push({\n        type: 'class',\n        name,\n        lineStart,\n        lineEnd,\n        signature: `class ${name}`,\n        rawContent: extractLines(content, lineStart, lineEnd),\n        metadata: {},\n      });\n    }\n\n    return structures;\n  },\n};\n"}},{"data":{"id":"structure:5478","label":"Name","type":"class","file":"src/indexer/parsers/ruby.ts","line":8,"signature":"class Name","content":"  // class Name\n  class: /^\\s*class\\s+(\\w+)(?:\\s*\u003c\\s*\\w+)?/gm,\n\n  // module Name\n  module: /^\\s*module\\s+(\\w+)/gm,\n};\n\nfunction findRubyBlockEnd(content: string, startLine: number): number {\n  const lines = content.split('\\n');\n  let depth = 1;\n\n  for (let i = startLine; i \u003c lines.length; i++) {\n    const line = lines[i];\n\n    // Count block openers\n    if (line.match(/\\b(class|module|def|do|if|unless|case|while|until|for|begin)\\b/) \u0026\u0026 !line.match(/\\bend\\b/)) {\n      depth++;\n    }\n\n    // Count block closers\n    if (line.match(/\\bend\\b/)) {\n      depth--;\n      if (depth === 0) {\n        return i + 1;\n      }\n    }\n  }\n\n  return lines.length;\n}"}},{"data":{"id":"structure:5305","label":"WatcherOptions","type":"interface","file":"src/indexer/watcher.ts","line":22,"signature":"export interface WatcherOptions","content":"export interface WatcherOptions {\n  onIndex?: (projectId: number, path: string, structures: number) =\u003e void;\n  onDelete?: (projectId: number, path: string) =\u003e void;\n  onError?: (error: Error) =\u003e void;\n}"}},{"data":{"id":"structure:5301","label":"name","type":"class","file":"src/mcp/server.ts","line":47,"signature":"class name","content":"              description: 'Search query - can be a function name, class name, or keyword',\n            },\n            type: {\n              type: 'string',\n              enum: ['all', 'structures', 'conversations'],\n              description: 'What to search: all, structures, or conversations',\n              default: 'all',\n            },"}},{"data":{"id":"structure:5302","label":"to","type":"class","file":"src/mcp/server.ts","line":100,"signature":"class to","content":"              description: 'Name of the function or class to verify',\n            },\n            type: {\n              type: 'string',\n              enum: ['structure', 'file'],\n              description: 'Type of entity to verify',\n              default: 'structure',\n            },"}},{"data":{"id":"structure:5295","label":"AimemInterceptor","type":"class","file":"src/proxy/interceptor.py","line":69,"signature":"class AimemInterceptor","content":"\n"}},{"data":{"id":"structure:5299","label":"ContextResult","type":"interface","file":"src/query/index.ts","line":11,"signature":"export interface ContextResult","content":"export interface ContextResult {\n  structures: Array\u003c{\n    type: string;\n    name: string;\n    file: string;\n    line: number;\n    signature: string | null;\n    content: string;\n  }\u003e;\n  decisions: Extraction[];\n  rejections: Extraction[];\n  patterns: Extraction[];\n  relatedConversations: Array\u003c{\n    id: number;\n    timestamp: string;\n    summary: string | null;\n  }\u003e;\n}"}},{"data":{"id":"structure:5237","label":"Project","type":"interface","file":"src/types/index.ts","line":3,"signature":"export interface Project","content":"export interface Project {\n  id: number;\n  path: string;\n  name: string;\n  created_at: string;\n}"}},{"data":{"id":"structure:5238","label":"File","type":"interface","file":"src/types/index.ts","line":10,"signature":"export interface File","content":"export interface File {\n  id: number;\n  project_id: number;\n  path: string;\n  hash: string;\n  last_indexed: string;\n}"}},{"data":{"id":"structure:5239","label":"Structure","type":"interface","file":"src/types/index.ts","line":20,"signature":"export interface Structure","content":"export interface Structure {\n  id: number;\n  file_id: number;\n  type: StructureType;\n  name: string;\n  line_start: number;\n  line_end: number;\n  signature: string | null;\n  raw_content: string;\n  metadata: Record\u003cstring, unknown\u003e;\n}"}},{"data":{"id":"structure:5240","label":"Conversation","type":"interface","file":"src/types/index.ts","line":32,"signature":"export interface Conversation","content":"export interface Conversation {\n  id: number;\n  project_id: number | null;\n  timestamp: string;\n  model: string | null;\n  tool: string | null;\n  summary: string | null;\n  raw_content: string;\n}"}},{"data":{"id":"structure:5241","label":"Link","type":"interface","file":"src/types/index.ts","line":45,"signature":"export interface Link","content":"export interface Link {\n  id: number;\n  source_type: NodeType;\n  source_id: number;\n  target_type: NodeType;\n  target_id: number;\n  link_type: LinkType;\n}"}},{"data":{"id":"structure:5242","label":"Extraction","type":"interface","file":"src/types/index.ts","line":56,"signature":"export interface Extraction","content":"export interface Extraction {\n  id: number;\n  conversation_id: number;\n  type: ExtractionType;\n  content: string;\n  metadata: Record\u003cstring, unknown\u003e;\n}"}},{"data":{"id":"structure:5243","label":"AimemConfig","type":"interface","file":"src/types/index.ts","line":64,"signature":"export interface AimemConfig","content":"export interface AimemConfig {\n  dataDir: string;\n  proxyPort: number;\n  watcherEnabled: boolean;\n}"}},{"data":{"id":"structure:5244","label":"IndexStats","type":"interface","file":"src/types/index.ts","line":70,"signature":"export interface IndexStats","content":"export interface IndexStats {\n  projects: number;\n  files: number;\n  structures: number;\n  conversations: number;\n  links: number;\n}"}},{"data":{"id":"structure:5272","label":"GraphNode","type":"interface","file":"src/visualize/index.ts","line":7,"signature":"export interface GraphNode","content":"export interface GraphNode {\n  data: {\n    id: string;\n    label: string;\n    type: 'function' | 'class' | 'method' | 'interface' | 'type' | 'variable' | 'module' | 'file' | 'decision' | 'pattern' | 'rejection';\n    file?: string;\n    line?: number;\n    lineEnd?: number;\n    signature?: string;\n    content?: string;\n    parent?: string; // For compound nodes (file -\u003e structures)\n  };\n}"}},{"data":{"id":"structure:5273","label":"GraphEdge","type":"interface","file":"src/visualize/index.ts","line":22,"signature":"export interface GraphEdge","content":"export interface GraphEdge {\n  data: {\n    id: string;\n    source: string;\n    target: string;\n    type: 'calls' | 'called_by' | 'references' | 'decision' | 'touched' | 'rejected' | 'contains';\n    label?: string;\n  };\n}"}},{"data":{"id":"structure:5274","label":"GraphData","type":"interface","file":"src/visualize/index.ts","line":32,"signature":"export interface GraphData","content":"export interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}"}},{"data":{"id":"structure:5275","label":"VisualizationData","type":"interface","file":"src/visualize/index.ts","line":37,"signature":"export interface VisualizationData","content":"export interface VisualizationData {\n  project: Project;\n  graphs: {\n    overview: GraphData;\n    callGraph: GraphData;\n    dependencies: GraphData;\n    classes: GraphData;\n    decisions: GraphData;\n  };\n  stats: {\n    totalStructures: number;\n    totalFiles: number;\n    totalLinks: number;\n    totalDecisions: number;\n    byType: Record\u003cstring, number\u003e;\n  };\n}"}},{"data":{"id":"structure:5271","label":"for","type":"class","file":"src/visualize/index.ts","line":261,"signature":"class\n  for","content":"  // This is a simplified approach - methods appear near their class\n  for (const s of structures) {\n    if (s.type === 'method') {\n      nodes.push({\n        data: {\n          id: `structure:${s.id}`,\n          label: s.name,\n          type: s.type,\n          file: s.file_path,\n          line: s.line_start,\n          signature: s.signature || undefined,\n          content: s.raw_content,\n        },\n      });\n    }\n  }"}},{"data":{"id":"structure:5260","label":"ServerOptions","type":"interface","file":"src/visualize/server.ts","line":6,"signature":"export interface ServerOptions","content":"export interface ServerOptions {\n  port: number;\n  getData: () =\u003e VisualizationData;\n}"}},{"data":{"id":"structure:5178","label":"to","type":"class","file":"test/extractor.test.ts","line":210,"signature":"class to","content":"          content: \"I'll update the UserService class to include a new validateCredentials method for authentication.\"\n        }\n      ];\n\n      const extractions = extractDecisions(messages);\n\n      // Should extract class and method names as entities\n      const withEntities = extractions.filter(e =\u003e e.mentionedEntities.length \u003e 0);\n      assert.ok(withEntities.length \u003e 0 || extractions.length \u003e 0);\n    });\n\n    it('should handle empty messages', () =\u003e {\n      const messages: TranscriptMessage[] = [];\n      const extractions = extractDecisions(messages);\n      assert.strictEqual(extractions.length, 0);\n    });"}},{"data":{"id":"structure:5179","label":"and","type":"class","file":"test/extractor.test.ts","line":216,"signature":"class and","content":"      // Should extract class and method names as entities\n      const withEntities = extractions.filter(e =\u003e e.mentionedEntities.length \u003e 0);\n      assert.ok(withEntities.length \u003e 0 || extractions.length \u003e 0);\n    });\n\n    it('should handle empty messages', () =\u003e {\n      const messages: TranscriptMessage[] = [];\n      const extractions = extractDecisions(messages);\n      assert.strictEqual(extractions.length, 0);\n    });"}},{"data":{"id":"structure:5176","label":"TestDb","type":"interface","file":"test/helpers.ts","line":9,"signature":"export interface TestDb","content":"export interface TestDb {\n  db: Database.Database;\n  path: string;\n  cleanup: () =\u003e void;\n}"}},{"data":{"id":"structure:5147","label":"declaration","type":"class","file":"test/parsers.test.ts","line":134,"signature":"class declaration","content":"    it('should parse class declaration', () =\u003e {\n      const code = `class User {\n  constructor(name) {\n    this.name = name;\n  }\n}`;\n      const structures = javascriptParser.parse(code, 'test.js');\n\n      assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'User'));\n    });"}},{"data":{"id":"structure:5148","label":"User","type":"class","file":"test/parsers.test.ts","line":135,"signature":"class User","content":"      const code = `class User {\n  constructor(name) {\n    this.name = name;\n  }\n}`;"}},{"data":{"id":"structure:5149","label":"with","type":"class","file":"test/parsers.test.ts","line":145,"signature":"class with","content":"    it('should parse class with extends', () =\u003e {\n      const code = `class Admin extends User {\n  constructor(name, role) {\n    super(name);\n    this.role = role;\n  }\n}`;\n      const structures = javascriptParser.parse(code, 'test.js');\n\n      const classStructure = structures.find(s =\u003e s.type === 'class');\n      assert.ok(classStructure);\n      assert.strictEqual(classStructure.name, 'Admin');\n      assert.ok(classStructure.signature?.includes('extends'));\n    });"}},{"data":{"id":"structure:5150","label":"Admin","type":"class","file":"test/parsers.test.ts","line":146,"signature":"class Admin extends User","content":"      const code = `class Admin extends User {\n  constructor(name, role) {\n    super(name);\n    this.role = role;\n  }\n}`;"}},{"data":{"id":"structure:5151","label":"Service","type":"class","file":"test/parsers.test.ts","line":161,"signature":"export class Service","content":"      const code = `export class Service {\n  run() {}\n}`;"}},{"data":{"id":"structure:5160","label":"declaration","type":"interface","file":"test/parsers.test.ts","line":171,"signature":"interface declaration","content":"    it('should parse interface declaration', () =\u003e {\n      const code = `interface Config {\n  host: string;\n  port: number;\n}`;\n      const structures = javascriptParser.parse(code, 'test.ts');\n\n      assert.strictEqual(structures.length, 1);\n      assert.strictEqual(structures[0].type, 'interface');\n      assert.strictEqual(structures[0].name, 'Config');\n    });"}},{"data":{"id":"structure:5161","label":"Config","type":"interface","file":"test/parsers.test.ts","line":172,"signature":"interface Config","content":"      const code = `interface Config {\n  host: string;\n  port: number;\n}`;"}},{"data":{"id":"structure:5162","label":"Options","type":"interface","file":"test/parsers.test.ts","line":184,"signature":"export interface Options","content":"      const code = `export interface Options {\n  debug: boolean;\n}`;"}},{"data":{"id":"structure:5163","label":"with","type":"interface","file":"test/parsers.test.ts","line":192,"signature":"interface with","content":"    it('should parse interface with extends', () =\u003e {\n      const code = `interface ExtendedConfig extends Config {\n  timeout: number;\n}`;\n      const structures = javascriptParser.parse(code, 'test.ts');\n\n      assert.ok(structures[0].signature?.includes('extends'));\n    });"}},{"data":{"id":"structure:5164","label":"ExtendedConfig","type":"interface","file":"test/parsers.test.ts","line":193,"signature":"interface ExtendedConfig extends Config","content":"      const code = `interface ExtendedConfig extends Config {\n  timeout: number;\n}`;"}},{"data":{"id":"structure:5165","label":"UserData","type":"interface","file":"test/parsers.test.ts","line":223,"signature":"interface UserData","content":"interface UserData {\n  id: number;\n  name: string;\n}"}},{"data":{"id":"structure:5152","label":"UserService","type":"class","file":"test/parsers.test.ts","line":230,"signature":"export class UserService","content":"export class UserService {\n  private users: Map\u003cnumber, UserData\u003e = new Map();\n\n  async getUser(id: UserID): Promise\u003cUserData | null\u003e {\n    return this.users.get(id) || null;\n  }\n}"}},{"data":{"id":"structure:5153","label":"definition","type":"class","file":"test/parsers.test.ts","line":307,"signature":"class definition","content":"    it('should parse class definition', () =\u003e {\n      const code = `class User:\n    def __init__(self, name):\n        self.name = name`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      const classStructure = structures.find(s =\u003e s.type === 'class');\n      assert.ok(classStructure);\n      assert.strictEqual(classStructure.name, 'User');\n    });"}},{"data":{"id":"structure:5154","label":"User","type":"class","file":"test/parsers.test.ts","line":308,"signature":"class User","content":"      const code = `class User:\n    def __init__(self, name):\n        self.name = name`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      const classStructure = structures.find(s =\u003e s.type === 'class');\n      assert.ok(classStructure);\n      assert.strictEqual(classStructure.name, 'User');\n    });\n\n    it('should parse class with inheritance', () =\u003e {\n      const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n    });"}},{"data":{"id":"structure:5155","label":"with","type":"class","file":"test/parsers.test.ts","line":318,"signature":"class with","content":"    it('should parse class with inheritance', () =\u003e {\n      const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n    });"}},{"data":{"id":"structure:5156","label":"Admin","type":"class","file":"test/parsers.test.ts","line":319,"signature":"class Admin","content":"      const code = `class Admin(User):\n    def __init__(self, name, role):\n        super().__init__(name)\n        self.role = role`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      assert.ok(structures.some(s =\u003e s.type === 'class' \u0026\u0026 s.name === 'Admin'));\n    });\n\n    it('should parse methods inside class', () =\u003e {\n      const code = `class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      const methods = structures.filter(s =\u003e s.type === 'method');\n      assert.strictEqual(methods.length, 2);\n      assert.ok(methods.some(m =\u003e m.name === 'add'));\n      assert.ok(methods.some(m =\u003e m.name === 'subtract'));\n    });"}},{"data":{"id":"structure:5157","label":"Calculator","type":"class","file":"test/parsers.test.ts","line":329,"signature":"class Calculator","content":"      const code = `class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def subtract(self, a, b):\n        return a - b`;\n      const structures = pythonParser.parse(code, 'test.py');\n\n      const methods = structures.filter(s =\u003e s.type === 'method');\n      assert.strictEqual(methods.length, 2);\n      assert.ok(methods.some(m =\u003e m.name === 'add'));\n      assert.ok(methods.some(m =\u003e m.name === 'subtract'));\n    });\n  });\n\n  describe('Complex Files', () =\u003e {\n    it('should parse a file with mixed declarations', () =\u003e {\n      const code = `def helper_function():\n    return \"helper\"\n\nclass DataProcessor:\n    def __init__(self):\n        self.data = []\n\n    def process(self, item):\n        self.data.append(item)\n\ndef main():\n    processor = DataProcessor()\n    processor.process(\"item\")\n`;\n      const structures = pythonParser.parse(code, 'processor.py');\n\n      const functions = structures.filter(s =\u003e s.type === 'function');\n      const classes = structures.filter(s =\u003e s.type === 'class');\n      const methods = structures.filter(s =\u003e s.type === 'method');\n\n      // Should find top-level functions (helper_function and main)\n      assert.ok(functions.some(f =\u003e f.name === 'helper_function'), 'Should find helper_function');\n\n      // Should find the class\n      assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n\n      // Should find at least some methods\n      assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n\n      // Total structures should be reasonable\n      assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);\n    });\n  });"}},{"data":{"id":"structure:5158","label":"DataProcessor","type":"class","file":"test/parsers.test.ts","line":349,"signature":"class DataProcessor","content":"class DataProcessor:\n    def __init__(self):\n        self.data = []\n\n    def process(self, item):\n        self.data.append(item)\n\ndef main():\n    processor = DataProcessor()\n    processor.process(\"item\")\n`;\n      const structures = pythonParser.parse(code, 'processor.py');\n\n      const functions = structures.filter(s =\u003e s.type === 'function');\n      const classes = structures.filter(s =\u003e s.type === 'class');\n      const methods = structures.filter(s =\u003e s.type === 'method');\n\n      // Should find top-level functions (helper_function and main)\n      assert.ok(functions.some(f =\u003e f.name === 'helper_function'), 'Should find helper_function');\n\n      // Should find the class\n      assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n\n      // Should find at least some methods\n      assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n\n      // Total structures should be reasonable\n      assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);"}},{"data":{"id":"structure:5159","label":"assert","type":"class","file":"test/parsers.test.ts","line":369,"signature":"class\n      assert","content":"      // Should find the class\n      assert.ok(classes.some(c =\u003e c.name === 'DataProcessor'), 'Should find DataProcessor class');\n\n      // Should find at least some methods\n      assert.ok(methods.length \u003e= 1, 'Should find at least one method');\n\n      // Total structures should be reasonable\n      assert.ok(structures.length \u003e= 3, `Expected at least 3 structures, got ${structures.length}`);"}},{"data":{"id":"structure:5135","label":"UserService","type":"class","file":"test/query.test.ts","line":302,"signature":"class UserService","content":"            signature: 'class UserService',\n            content: 'class UserService { }'"}},{"data":{"id":"structure:5136","label":"UserService","type":"class","file":"test/query.test.ts","line":303,"signature":"class UserService","content":"            content: 'class UserService { }'"}},{"data":{"id":"structure:5276","label":"__init__","type":"method","file":"src/proxy/interceptor.py","line":72,"signature":"def __init__(self)","content":"    def __init__(self):\n        self.data_dir = os.environ.get(\"AIMEM_DATA_DIR\", os.path.expanduser(\"~/.aimem\"))\n        self.db_path = os.path.join(self.data_dir, \"aimem.db\")\n        self.pending_requests = {}\n        self.current_project_id = None\n        self._detect_project()\n"}},{"data":{"id":"structure:5277","label":"_detect_project","type":"method","file":"src/proxy/interceptor.py","line":78,"signature":"def _detect_project(self)","content":""}},{"data":{"id":"structure:5278","label":"load","type":"method","file":"src/proxy/interceptor.py","line":96,"signature":"def load(self, loader)","content":""}},{"data":{"id":"structure:5279","label":"configure","type":"method","file":"src/proxy/interceptor.py","line":110,"signature":"def configure(self, updates)","content":""}},{"data":{"id":"structure:5280","label":"is_target_host","type":"method","file":"src/proxy/interceptor.py","line":117,"signature":"def is_target_host(self, host: str)","content":""}},{"data":{"id":"structure:5281","label":"get_model_from_request","type":"method","file":"src/proxy/interceptor.py","line":120,"signature":"def get_model_from_request(self, data: dict)","content":""}},{"data":{"id":"structure:5282","label":"get_tool_from_host","type":"method","file":"src/proxy/interceptor.py","line":124,"signature":"def get_tool_from_host(self, host: str)","content":""}},{"data":{"id":"structure:5283","label":"extract_decisions","type":"method","file":"src/proxy/interceptor.py","line":155,"signature":"def extract_decisions(self, content: str)","content":""}},{"data":{"id":"structure:5284","label":"_get_sentence_around","type":"method","file":"src/proxy/interceptor.py","line":194,"signature":"def _get_sentence_around(self, text: str, index: int)","content":""}},{"data":{"id":"structure:5285","label":"_is_valid_extraction","type":"method","file":"src/proxy/interceptor.py","line":208,"signature":"def _is_valid_extraction(self, sentence: str)","content":""}},{"data":{"id":"structure:5286","label":"_extract_entities","type":"method","file":"src/proxy/interceptor.py","line":219,"signature":"def _extract_entities(self, text: str)","content":""}},{"data":{"id":"structure:5287","label":"_is_duplicate_extraction","type":"method","file":"src/proxy/interceptor.py","line":229,"signature":"def _is_duplicate_extraction(self, cursor, content: str, project_id: int, window_seconds: int = 300)","content":""}},{"data":{"id":"structure:5288","label":"store_conversation","type":"method","file":"src/proxy/interceptor.py","line":245,"signature":"def store_conversation(self, model: str, tool: str, content: str, extractions: list, assistant_content: str = \"\")","content":""}},{"data":{"id":"structure:5289","label":"get_relevant_context","type":"method","file":"src/proxy/interceptor.py","line":305,"signature":"def get_relevant_context(self, messages: list)","content":""}},{"data":{"id":"structure:5290","label":"_parse_sse_content","type":"method","file":"src/proxy/interceptor.py","line":360,"signature":"def _parse_sse_content(self, raw_content: bytes)","content":""}},{"data":{"id":"structure:5291","label":"_is_streaming_response","type":"method","file":"src/proxy/interceptor.py","line":414,"signature":"def _is_streaming_response(self, flow: http.HTTPFlow)","content":""}},{"data":{"id":"structure:5292","label":"_get_assistant_content","type":"method","file":"src/proxy/interceptor.py","line":419,"signature":"def _get_assistant_content(self, response_data: dict)","content":""}},{"data":{"id":"structure:5293","label":"request","type":"method","file":"src/proxy/interceptor.py","line":468,"signature":"def request(self, flow: http.HTTPFlow)","content":""}},{"data":{"id":"structure:5294","label":"response","type":"method","file":"src/proxy/interceptor.py","line":539,"signature":"def response(self, flow: http.HTTPFlow)","content":""}}],"edges":[]},"decisions":{"nodes":[{"data":{"id":"extraction:47","label":"But verifying it is tricky since I can't \"see\" ...","type":"decision","content":"But verifying it is tricky since I can't \"see\" my own system prompt to confirm."}},{"data":{"id":"extraction:46","label":"This matches the decision to use proxy instead ...","type":"rejection","content":"This matches the decision to use proxy instead of hooks."}},{"data":{"id":"extraction:45","label":"**Exception:** If you wanted people to see the ...","type":"decision","content":"**Exception:** If you wanted people to see the source code without going to GitHub, you could include it."}},{"data":{"id":"extraction:44","label":"rejected approaches, why you built things a cer...","type":"rejection","content":"rejected approaches, why you built things a certain way."}},{"data":{"id":"extraction:43","label":"**The problem:** Every time you start a new ses...","type":"rejection","content":"**The problem:** Every time you start a new session, your AI assistant forgets everything - architectural decisions, rejected approaches, why you built things a certain way."}},{"data":{"id":"extraction:42","label":"Next session when you ask \"why proxy instead of...","type":"rejection","content":"Next session when you ask \"why proxy instead of hooks?\" - aimem will find the actual context."}},{"data":{"id":"extraction:41","label":"Now let's test the search again:","type":"decision","content":"Now let's test the search again:"}},{"data":{"id":"extraction:40","label":"Now let's test through the MCP tool:","type":"decision","content":"Now let's test through the MCP tool:"}},{"data":{"id":"extraction:39","label":"That's my actual response text, not JSON! Now l...","type":"decision","content":"That's my actual response text, not JSON! Now let's test FTS search properly:"}},{"data":{"id":"extraction:38","label":"The `summary` field should now have actual resp...","type":"rejection","content":"The `summary` field should now have actual response text instead of being empty."}},{"data":{"id":"extraction:17","label":"- `\"I'll implement it for Linux/WSL (systemd) a...","type":"decision","content":"- `\"I'll implement it for Linux/WSL (systemd) and macOS (launchd)."}},{"data":{"id":"extraction:16","label":"let's implement context injection","type":"decision","content":"let's implement context injection"}},{"data":{"id":"extraction:15","label":"I'll implement it for Linux/WSL (systemd) and m...","type":"decision","content":"I'll implement it for Linux/WSL (systemd) and macOS (launchd)."}},{"data":{"id":"extraction:14","label":"js SSL troubleshooting entry since that was a k...","type":"decision","content":"js SSL troubleshooting entry since that was a key issue we solved."}},{"data":{"id":"extraction:11","label":"**User asked about using hooks AND proxy togeth...","type":"decision","content":"**User asked about using hooks AND proxy together**: I explained double injection/extraction issues."}},{"data":{"id":"extraction:12","label":"This should find decisions containing \"streamin...","type":"decision","content":"This should find decisions containing \"streaming\" via keyword search since there's no code structure named \"streaming\"."}},{"data":{"id":"extraction:13","label":"- \"lets just us the proxy for everything instea...","type":"rejection","content":"- \"lets just us the proxy for everything instead of hooks."}},{"data":{"id":"extraction:10","label":"\"content\": \"I'll use realtime mode for TwilioVo...","type":"decision","content":"\"content\": \"I'll use realtime mode for TwilioVoiceService because latency is critical for voice conversations."}},{"data":{"id":"extraction:9","label":"I'll thoroughly explore the codebase, understan...","type":"decision","content":"I'll thoroughly explore the codebase, understand existing patterns, and provide a detailed implementation plan."}},{"data":{"id":"extraction:7","label":"content: \"I'll use realtime mode for TwilioVoic...","type":"decision","content":"content: \"I'll use realtime mode for TwilioVoiceService because latency is critical for voice conversations."}},{"data":{"id":"extraction:8","label":"But the fix is confirmed working - the direct N...","type":"decision","content":"But the fix is confirmed working - the direct Node."}},{"data":{"id":"extraction:6","label":"\u003e \"I've decided to use SSE parsing to extract d...","type":"decision","content":"\u003e \"I've decided to use SSE parsing to extract decisions from streaming responses because Claude Code uses streaming by default."}},{"data":{"id":"extraction:5","label":"**Decision: I've decided to use SSE parsing to ...","type":"decision","content":"**Decision: I've decided to use SSE parsing to extract decisions from streaming responses because Claude Code uses streaming by default."}},{"data":{"id":"extraction:23","label":"json`, so I'll have these tools in every Claude...","type":"decision","content":"json`, so I'll have these tools in every Claude Code session, regardless of which project you're in."}},{"data":{"id":"extraction:24","label":"Then I'll be able to search that codebase too, ...","type":"decision","content":"Then I'll be able to search that codebase too, and see connections across projects when needed."}},{"data":{"id":"extraction:22","label":"json`) and added the note about using the full ...","type":"decision","content":"json`) and added the note about using the full path."}},{"data":{"id":"extraction:21","label":"Note: Since you're using nvm, you'll need `sour...","type":"decision","content":"Note: Since you're using nvm, you'll need `source ~/."}},{"data":{"id":"extraction:20","label":"I'll start with a regex-based parser (simpler t...","type":"decision","content":"I'll start with a regex-based parser (simpler to start, can add tree-sitter later for more accuracy):"}},{"data":{"id":"extraction:19","label":"Since this is a greenfield project, I have a fe...","type":"decision","content":"Since this is a greenfield project, I have a few questions to finalize the approach:"}}],"edges":[]}},"stats":{"totalStructures":427,"totalFiles":61,"totalLinks":359,"totalDecisions":23,"byType":{"function":297,"interface":48,"type":15,"class":48,"method":19}}}</script>
  <script>
    // Visualization data - parse from JSON script tag to avoid escaping issues
    const vizData = JSON.parse(document.getElementById('viz-data').textContent);

    // Initialize Cytoscape
    let cy = null;
    let currentView = 'overview';
    let currentViewMode = 'visual'; // 'visual' or 'list'

    // View descriptions - clear, action-oriented
    const viewDescriptions = {
      overview: '<strong>Files</strong> - Your codebase at a glance. Hover to see connections. <em>Double-click any file</em> to explore inside.',
      callGraph: '<strong>Call Graph</strong> - See how functions connect. Bigger nodes = more connections. <em>Double-click</em> to follow the flow.',
      dependencies: '<strong>Dependencies</strong> - File relationships. <em>Double-click</em> to see inside each file.',
      classes: '<strong>Classes</strong> - Your types and structures. <em>Double-click a class</em> to see its methods.',
      decisions: '<strong>Decisions</strong> - Why your code is the way it is. Connects decisions to the code they affect.',
    };

    // Store full graph data for focus mode filtering
    let fullCallGraphData = null;

    // Navigation history for back button
    let drillHistory = [];

    // Flow mode: 'connections' (default) or 'downstream' or 'upstream'
    let flowMode = 'connections';

    // Node colors
    const nodeColors = {
      function: '#2563eb',
      class: '#7c3aed',
      method: '#0891b2',
      interface: '#059669',
      type: '#d97706',
      variable: '#dc2626',
      module: '#4f46e5',
      file: '#475569',
      decision: '#16a34a',
      pattern: '#0d9488',
      rejection: '#dc2626',
    };

    // Cytoscape styles - node size based on weight (connections)
    const cyStyle = [
      {
        selector: 'node',
        style: {
          'label': 'data(label)',
          'text-valign': 'bottom',
          'text-halign': 'center',
          'font-size': '10px',
          'color': '#ccc',
          'text-margin-y': 4,
          'background-color': '#475569',
          'width': 'mapData(weight, 0, 10, 25, 60)',  // Size based on connections
          'height': 'mapData(weight, 0, 10, 25, 60)',
        }
      },
      {
        selector: 'node[type="function"]',
        style: { 'background-color': nodeColors.function }
      },
      {
        selector: 'node[type="class"]',
        style: { 'background-color': nodeColors.class, 'width': 40, 'height': 40 }
      },
      {
        selector: 'node[type="method"]',
        style: { 'background-color': nodeColors.method }
      },
      {
        selector: 'node[type="interface"]',
        style: { 'background-color': nodeColors.interface }
      },
      {
        selector: 'node[type="type"]',
        style: { 'background-color': nodeColors.type }
      },
      {
        selector: 'node[type="file"]',
        style: {
          'background-color': nodeColors.file,
          'width': 50,
          'height': 30,
          'shape': 'round-rectangle',
          'font-size': '11px',
          'text-wrap': 'ellipsis',
          'text-max-width': '80px',
        }
      },
      {
        selector: 'node[type="decision"]',
        style: { 'background-color': nodeColors.decision, 'shape': 'diamond' }
      },
      {
        selector: 'node[type="pattern"]',
        style: { 'background-color': nodeColors.pattern, 'shape': 'diamond' }
      },
      {
        selector: 'node[type="rejection"]',
        style: { 'background-color': nodeColors.rejection, 'shape': 'diamond' }
      },
      {
        selector: 'edge',
        style: {
          'width': 1.5,
          'line-color': '#334155',
          'target-arrow-color': '#334155',
          'target-arrow-shape': 'triangle',
          'curve-style': 'bezier',
          'arrow-scale': 0.8,
        }
      },
      {
        selector: 'edge[type="calls"]',
        style: { 'line-color': '#2563eb', 'target-arrow-color': '#2563eb' }
      },
      {
        selector: 'edge[type="contains"]',
        style: { 'line-style': 'dashed', 'line-color': '#475569', 'target-arrow-shape': 'none' }
      },
      {
        selector: 'edge[type="decision"]',
        style: { 'line-color': '#16a34a', 'target-arrow-color': '#16a34a' }
      },
      {
        selector: ':selected',
        style: {
          'border-width': 3,
          'border-color': '#e94560',
        }
      },
      {
        selector: 'node.hover',
        style: {
          'border-width': 2,
          'border-color': '#e94560',
        }
      },
      {
        selector: 'node.faded',
        style: {
          'opacity': 0.2,
        }
      },
      {
        selector: 'edge.highlighted',
        style: {
          'width': 3,
          'line-color': '#e94560',
          'target-arrow-color': '#e94560',
          'z-index': 999,
        }
      },
      {
        selector: 'edge.faded',
        style: {
          'opacity': 0.1,
        }
      }
    ];

    function initCytoscape(graphData) {
      if (cy) {
        cy.destroy();
      }

      // Ensure all nodes have a weight for sizing
      const nodesWithWeight = graphData.nodes.map(n => ({
        ...n,
        data: {
          ...n.data,
          weight: n.data.weight || 1
        }
      }));

      cy = cytoscape({
        container: document.getElementById('cy'),
        elements: [...nodesWithWeight, ...graphData.edges],
        style: cyStyle,
        layout: { name: 'cose', animate: false, randomize: true },
        minZoom: 0.1,
        maxZoom: 3,
      });

      // Click handler
      cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        const nodeData = node.data();
        showDetails(nodeData);

        // In call graph, handle flow mode
        if (currentView === 'callGraph' && fullCallGraphData && nodeData.id) {
          setTimeout(() => {
            if (node.selected()) {
              if (flowMode === 'downstream') {
                // Save history before tracing
                drillHistory.push({
                  view: currentView,
                  label: 'Call Graph',
                  description: document.getElementById('view-description').innerHTML
                });
                updateBackButton();
                updateBreadcrumb([{ label: 'Call Graph' }, { label: nodeData.label + ' (downstream)' }]);
                traceFlow(nodeData.id, 'downstream');
              } else if (flowMode === 'upstream') {
                // Save history before tracing
                drillHistory.push({
                  view: currentView,
                  label: 'Call Graph',
                  description: document.getElementById('view-description').innerHTML
                });
                updateBackButton();
                updateBreadcrumb([{ label: 'Call Graph' }, { label: nodeData.label + ' (upstream)' }]);
                traceFlow(nodeData.id, 'upstream');
              } else {
                // Default: focus on connections
                focusOnNode(nodeData.id);
              }
            }
          }, 300);
        }
      });

      // Double-click to drill down
      cy.on('dbltap', 'node', function(evt) {
        const nodeData = evt.target.data();
        drillDown(nodeData);
      });

      // Clear selection on background click
      cy.on('tap', function(evt) {
        if (evt.target === cy) {
          clearDetails();
        }
      });

      // Hover effects - show tooltip and highlight connections
      cy.on('mouseover', 'node', function(evt) {
        const node = evt.target;
        const nodeData = node.data();

        // Show tooltip
        showTooltip(evt.originalEvent, nodeData);

        // Highlight this node and its connections
        node.addClass('hover');

        // Get connected edges and nodes
        const connectedEdges = node.connectedEdges();
        const connectedNodes = connectedEdges.connectedNodes();

        // Fade everything else
        cy.elements().addClass('faded');
        node.removeClass('faded');
        connectedNodes.removeClass('faded');
        connectedEdges.removeClass('faded').addClass('highlighted');
      });

      cy.on('mouseout', 'node', function(evt) {
        hideTooltip();

        // Remove all highlight classes
        cy.elements().removeClass('faded hover highlighted');
      });

      // Update tooltip position on mouse move
      cy.on('mousemove', 'node', function(evt) {
        moveTooltip(evt.originalEvent);
      });

      runLayout();
    }

    function runLayout() {
      const layoutName = document.getElementById('layout-select').value;
      const nodeCount = cy.nodes(':visible').length;

      const layoutOptions = {
        name: layoutName,
        animate: nodeCount < 100,
        animationDuration: 300,
        nodeDimensionsIncludeLabels: true,
        fit: true,
        padding: 50,
      };

      // Layout-specific options for better spacing
      if (layoutName === 'cose') {
        Object.assign(layoutOptions, {
          nodeRepulsion: 8000,
          idealEdgeLength: 100,
          edgeElasticity: 100,
          nestingFactor: 1.2,
          gravity: 0.25,
          numIter: 1000,
          randomize: true,
        });
      } else if (layoutName === 'breadthfirst') {
        Object.assign(layoutOptions, {
          spacingFactor: 1.5,
          directed: true,
        });
      } else if (layoutName === 'circle') {
        Object.assign(layoutOptions, {
          spacingFactor: 1.2,
        });
      } else if (layoutName === 'grid') {
        Object.assign(layoutOptions, {
          spacingFactor: 1.5,
          condense: false,
        });
      } else if (layoutName === 'concentric') {
        Object.assign(layoutOptions, {
          spacingFactor: 2,
          minNodeSpacing: 50,
        });
      }

      cy.layout(layoutOptions).run();
    }

    // Store current selected node data for visualization buttons
    let currentSelectedData = null;

    function showDetails(data) {
      currentSelectedData = data;
      const content = document.getElementById('details-content');
      let html = '';

      // Type tag
      html += '<div class="detail-row">';
      html += '<span class="tag ' + data.type + '">' + data.type + '</span>';
      html += '</div>';

      // Name
      html += '<div class="detail-row">';
      html += '<div class="detail-label">Name</div>';
      html += '<div class="detail-value">' + escapeHtml(data.label) + '</div>';
      html += '</div>';

      // File location
      if (data.file) {
        html += '<div class="detail-row">';
        html += '<div class="detail-label">Location</div>';
        html += '<div class="detail-value">' + escapeHtml(data.file);
        if (data.line) {
          html += ':' + data.line;
        }
        html += '</div>';
        html += '</div>';
      }

      // Signature
      if (data.signature) {
        html += '<div class="detail-row">';
        html += '<div class="detail-label">Signature</div>';
        html += '<div class="detail-value"><code>' + escapeHtml(data.signature) + '</code></div>';
        html += '</div>';
      }

      // Visualize buttons for functions and methods
      if (data.type === 'function' || data.type === 'method') {
        html += '<div class="detail-row">';
        html += '<div class="detail-label">Visualize</div>';
        html += '<button class="visualize-btn" onclick="visualizeNode(\'connections\')">Show Connections</button>';
        html += '<div class="visualize-btn-group">';
        html += '<button class="visualize-btn secondary" onclick="visualizeNode(\'downstream\')">Trace Calls &#8594;</button>';
        html += '<button class="visualize-btn secondary" onclick="visualizeNode(\'upstream\')">&#8592; Trace Callers</button>';
        html += '</div>';
        html += '</div>';
      }
      // For files: show contents button
      else if (data.type === 'file') {
        html += '<div class="detail-row">';
        html += '<button class="visualize-btn" onclick="visualizeFile()">Show File Contents</button>';
        html += '</div>';
      }
      // For classes/interfaces: show methods button
      else if (data.type === 'class' || data.type === 'interface') {
        html += '<div class="detail-row">';
        html += '<button class="visualize-btn" onclick="visualizeClass()">Show Methods</button>';
        html += '</div>';
      }

      // Source code
      if (data.content) {
        html += '<div class="detail-row">';
        html += '<div class="detail-label">Source Code</div>';
        html += '<div class="code-block">' + escapeHtml(data.content) + '</div>';
        html += '</div>';
      }

      content.innerHTML = html;

      // Show panel in fullscreen mode
      if (document.body.classList.contains('fullscreen')) {
        document.getElementById('details-panel').classList.add('visible');
      }
    }

    // Visualize a node in the call graph
    function visualizeNode(mode) {
      if (!currentSelectedData) return;

      // Switch to visual mode if in list mode
      if (currentViewMode === 'list') {
        setViewMode('visual');
      }

      // Make sure we have call graph data
      fullCallGraphData = vizData.graphs.callGraph;

      // Save current state to history
      drillHistory.push({
        view: currentView,
        label: getBreadcrumbLabel(currentView),
        description: document.getElementById('view-description').innerHTML
      });
      updateBackButton();

      // Set flow mode and update UI
      flowMode = mode;
      document.querySelectorAll('input[name="flow-mode"]').forEach(radio => {
        radio.checked = radio.value === mode;
      });

      // Switch to call graph tab
      currentView = 'callGraph';
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === 'callGraph');
      });
      document.getElementById('flow-mode-group').style.display = 'block';

      // Perform the visualization
      if (mode === 'downstream') {
        updateBreadcrumb([{ label: 'Call Graph' }, { label: currentSelectedData.label + ' (downstream)' }]);
        traceFlow(currentSelectedData.id, 'downstream');
      } else if (mode === 'upstream') {
        updateBreadcrumb([{ label: 'Call Graph' }, { label: currentSelectedData.label + ' (upstream)' }]);
        traceFlow(currentSelectedData.id, 'upstream');
      } else {
        updateBreadcrumb([{ label: 'Call Graph' }, { label: currentSelectedData.label }]);
        focusOnNode(currentSelectedData.id);
      }
    }

    // Visualize file contents
    function visualizeFile() {
      if (!currentSelectedData || !currentSelectedData.file) return;

      // Switch to visual mode if in list mode
      if (currentViewMode === 'list') {
        setViewMode('visual');
      }

      drillDown(currentSelectedData);
    }

    // Visualize class methods
    function visualizeClass() {
      if (!currentSelectedData) return;

      // Switch to visual mode if in list mode
      if (currentViewMode === 'list') {
        setViewMode('visual');
      }

      drillDown(currentSelectedData);
    }

    function clearDetails() {
      document.getElementById('details-content').innerHTML = `
        <div class="empty-state">
          <h3>No selection</h3>
          <p>Click a node to view details</p>
        </div>
      `;
      // Hide panel in fullscreen mode
      document.getElementById('details-panel').classList.remove('visible');
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Tooltip functions
    function showTooltip(event, nodeData) {
      const tooltip = document.getElementById('tooltip');
      tooltip.querySelector('.tip-type').textContent = nodeData.type || '';
      tooltip.querySelector('.tip-name').textContent = nodeData.label || '';

      let location = '';
      if (nodeData.file) {
        location = nodeData.file.split('/').pop();
        if (nodeData.line) location += ':' + nodeData.line;
      }
      tooltip.querySelector('.tip-location').textContent = location;

      // Update hint based on type
      const hint = tooltip.querySelector('.tip-hint');
      if (nodeData.type === 'file') {
        hint.textContent = 'Double-click to see contents';
      } else if (nodeData.type === 'class' || nodeData.type === 'interface') {
        hint.textContent = 'Double-click to see methods';
      } else if (nodeData.type === 'function' || nodeData.type === 'method') {
        hint.textContent = 'Double-click to see call graph';
      } else {
        hint.textContent = 'Double-click to explore';
      }

      tooltip.classList.add('visible');
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const tooltip = document.getElementById('tooltip');
      const x = event.clientX + 15;
      const y = event.clientY + 15;

      // Keep tooltip on screen
      const rect = tooltip.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width - 10;
      const maxY = window.innerHeight - rect.height - 10;

      tooltip.style.left = Math.min(x, maxX) + 'px';
      tooltip.style.top = Math.min(y, maxY) + 'px';
    }

    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }

    // Breadcrumb functions
    function updateBreadcrumb(items) {
      const bc = document.getElementById('breadcrumb');
      let html = '';

      items.forEach((item, i) => {
        if (i > 0) html += '<span class="breadcrumb-sep">‚Ä∫</span>';

        const isLast = i === items.length - 1;
        if (isLast) {
          html += '<span class="breadcrumb-item current">' + escapeHtml(item.label) + '</span>';
        } else {
          html += '<span class="breadcrumb-item" onclick="goBackTo(' + i + ')">' + escapeHtml(item.label) + '</span>';
        }
      });

      bc.innerHTML = html;
    }

    function goBackTo(index) {
      // Pop history until we reach the target index
      while (drillHistory.length > index) {
        drillHistory.pop();
      }
      updateBackButton();

      if (drillHistory.length === 0) {
        switchView(currentView);
      } else {
        const target = drillHistory[drillHistory.length - 1];
        drillHistory.pop();
        switchView(target.view);
      }
    }

    // Welcome overlay
    function dismissWelcome() {
      document.getElementById('welcome').style.display = 'none';
      localStorage.setItem('aimem-welcome-dismissed', 'true');
    }

    function maybeShowWelcome() {
      if (!localStorage.getItem('aimem-welcome-dismissed')) {
        document.getElementById('welcome').style.display = 'block';
      }
    }

    function switchView(view) {
      currentView = view;

      // Update tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === view);
      });

      // Update description
      document.getElementById('view-description').innerHTML = viewDescriptions[view] || '';

      // Show/hide flow mode controls for Call Graph
      const flowModeGroup = document.getElementById('flow-mode-group');
      if (view === 'callGraph') {
        flowModeGroup.style.display = 'block';
      } else {
        flowModeGroup.style.display = 'none';
      }

      // Special handling for call graph - focus mode
      if (view === 'callGraph') {
        fullCallGraphData = vizData.graphs.callGraph;
        if (cy) cy.destroy();

        // Find entry points: functions that call others but aren't called themselves
        const entryPoints = findEntryPoints();

        if (entryPoints.length > 0) {
          // Show entry points view
          showEntryPoints(entryPoints);
        } else {
          const stats = fullCallGraphData ? fullCallGraphData.nodes.length + ' functions, ' + fullCallGraphData.edges.length + ' call relationships' : 'No data';
          document.getElementById('cy').innerHTML =
            '<div class="empty-state">' +
              '<h3>Search for a function</h3>' +
              '<p>Type a function name in the search box above to explore its call relationships</p>' +
              '<p style="margin-top: 16px; font-size: 12px; color: #666;">' + stats + '</p>' +
            '</div>';
        }
        // Re-render list view if in list mode
        if (currentViewMode === 'list') {
          renderListView();
        }
        clearDetails();
        return;
      }

      fullCallGraphData = null;

      // Load graph data
      const graphData = vizData.graphs[view];
      if (graphData && (graphData.nodes.length > 0 || graphData.edges.length > 0)) {
        initCytoscape(graphData);
      } else {
        if (cy) cy.destroy();
        document.getElementById('cy').innerHTML = `
          <div class="empty-state">
            <h3>No data</h3>
            <p>No nodes to display for this view</p>
          </div>
        `;
      }

      // Re-render list view if in list mode
      if (currentViewMode === 'list') {
        renderListView();
      }

      clearDetails();
    }

    // Find entry points: functions that call others but aren't called
    function findEntryPoints() {
      if (!fullCallGraphData || !fullCallGraphData.edges.length) return [];

      const callers = new Set();  // nodes that call something
      const callees = new Set();  // nodes that are called

      for (const edge of fullCallGraphData.edges) {
        callers.add(edge.data.source);
        callees.add(edge.data.target);
      }

      // Entry points: call others but aren't called
      const entryPointIds = [];
      for (const callerId of callers) {
        if (!callees.has(callerId)) {
          entryPointIds.push(callerId);
        }
      }

      // Get the actual nodes, sorted by number of outgoing calls
      const outgoingCounts = {};
      for (const edge of fullCallGraphData.edges) {
        outgoingCounts[edge.data.source] = (outgoingCounts[edge.data.source] || 0) + 1;
      }

      return fullCallGraphData.nodes
        .filter(n => entryPointIds.includes(n.data.id))
        .sort((a, b) => (outgoingCounts[b.data.id] || 0) - (outgoingCounts[a.data.id] || 0));
    }

    // Show entry points with their immediate callees
    function showEntryPoints(entryPoints) {
      // Take top entry points (most outgoing calls)
      const topEntries = entryPoints.slice(0, 10);
      const entryIds = new Set(topEntries.map(n => n.data.id));

      // Get edges from entry points
      const relevantEdges = fullCallGraphData.edges.filter(e => entryIds.has(e.data.source));

      // Get called nodes
      const calledIds = new Set();
      for (const edge of relevantEdges) {
        calledIds.add(edge.data.target);
      }

      // Build node set
      const nodeIds = new Set([...entryIds, ...calledIds]);
      const nodes = fullCallGraphData.nodes.filter(n => nodeIds.has(n.data.id));

      if (nodes.length > 0) {
        initCytoscape({ nodes, edges: relevantEdges });

        // Update description
        document.getElementById('view-description').innerHTML =
          '<strong>Entry Points</strong> - Functions that call others but are not called. These are typically command handlers or main functions. Click any node to explore further.';
      }
    }

    // Focus mode: show only a node and its direct connections
    function focusOnNode(nodeId) {
      if (!fullCallGraphData) return;

      const nodeIdStr = nodeId.startsWith('structure:') ? nodeId : 'structure:' + nodeId;

      // Find the center node
      const centerNode = fullCallGraphData.nodes.find(n => n.data.id === nodeIdStr);
      if (!centerNode) return;

      // Find all edges connected to this node
      const connectedEdges = fullCallGraphData.edges.filter(e =>
        e.data.source === nodeIdStr || e.data.target === nodeIdStr
      );

      // Find all connected node IDs
      const connectedNodeIds = new Set([nodeIdStr]);
      for (const edge of connectedEdges) {
        connectedNodeIds.add(edge.data.source);
        connectedNodeIds.add(edge.data.target);
      }

      // Build focused graph
      const focusedNodes = fullCallGraphData.nodes.filter(n => connectedNodeIds.has(n.data.id));
      const focusedGraph = {
        nodes: focusedNodes,
        edges: connectedEdges,
      };

      if (focusedNodes.length > 0) {
        initCytoscape(focusedGraph);

        // Highlight the center node
        setTimeout(() => {
          if (cy) {
            const centerEle = cy.getElementById(nodeIdStr);
            if (centerEle) {
              centerEle.select();
              showDetails(centerEle.data());
            }
          }
        }, 100);
      }
    }

    // Trace code flow from a starting node
    function traceFlow(nodeId, direction) {
      if (!fullCallGraphData) return;

      const nodeIdStr = nodeId.startsWith('structure:') ? nodeId : 'structure:' + nodeId;
      const visited = new Set();
      const nodesToInclude = new Set([nodeIdStr]);
      const edgesToInclude = [];

      // BFS to trace flow
      const queue = [nodeIdStr];
      const maxDepth = 5; // Limit depth to avoid overwhelming
      const depthMap = { [nodeIdStr]: 0 };

      while (queue.length > 0) {
        const current = queue.shift();
        if (visited.has(current)) continue;
        visited.add(current);

        const currentDepth = depthMap[current] || 0;
        if (currentDepth >= maxDepth) continue;

        for (const edge of fullCallGraphData.edges) {
          let nextNode = null;

          if (direction === 'downstream' && edge.data.source === current) {
            // Following calls: source -> target
            nextNode = edge.data.target;
          } else if (direction === 'upstream' && edge.data.target === current) {
            // Following callers: target <- source
            nextNode = edge.data.source;
          }

          if (nextNode && !visited.has(nextNode)) {
            nodesToInclude.add(nextNode);
            edgesToInclude.push(edge);
            queue.push(nextNode);
            depthMap[nextNode] = currentDepth + 1;
          }
        }
      }

      // Build flow graph
      const flowNodes = fullCallGraphData.nodes.filter(n => nodesToInclude.has(n.data.id));
      const flowGraph = {
        nodes: flowNodes,
        edges: edgesToInclude,
      };

      if (flowNodes.length > 0) {
        initCytoscape(flowGraph);

        // Use hierarchical layout for flow
        setTimeout(() => {
          if (cy) {
            cy.layout({
              name: 'breadthfirst',
              directed: true,
              roots: direction === 'downstream' ? [nodeIdStr] : undefined,
              spacingFactor: 1.5,
              animate: true,
              animationDuration: 300,
            }).run();
          }
        }, 100);

        // Highlight the starting node
        setTimeout(() => {
          if (cy) {
            const startNode = cy.getElementById(nodeIdStr);
            if (startNode) {
              startNode.select();
              showDetails(startNode.data());
            }
          }
        }, 200);

        const dirLabel = direction === 'downstream' ? 'calls from' : 'callers of';
        document.getElementById('view-description').innerHTML =
          '<strong>Flow: ' + dirLabel + '</strong> - Tracing ' + (flowNodes.length - 1) + ' ' + (direction === 'downstream' ? 'called functions' : 'calling functions') + '. Click nodes to see details.';
      }
    }

    // Drill down into a node to see related structures
    function drillDown(nodeData) {
      if (!nodeData) return;

      let nodes = [];
      let edges = [];
      let title = '';

      // For files: show all structures in that file
      if (nodeData.type === 'file' && nodeData.file) {
        const filePath = nodeData.file;
        title = 'Structures in ' + filePath.split('/').pop();

        // Find all structures in this file from callGraph data
        const allNodes = vizData.graphs.callGraph.nodes;
        nodes = allNodes.filter(n => n.data.file === filePath);

        // Find edges between these nodes
        const nodeIds = new Set(nodes.map(n => n.data.id));
        edges = vizData.graphs.callGraph.edges.filter(e =>
          nodeIds.has(e.data.source) && nodeIds.has(e.data.target)
        );
      }
      // For classes/interfaces: show methods in same file near the class
      else if ((nodeData.type === 'class' || nodeData.type === 'interface') && nodeData.file) {
        const filePath = nodeData.file;
        const classLine = nodeData.line || 0;
        const classLineEnd = nodeData.lineEnd || classLine + 1000;
        title = 'Contents of ' + nodeData.label;

        // Find methods in the same file within the class line range
        const allNodes = vizData.graphs.callGraph.nodes;
        nodes = allNodes.filter(n => {
          if (n.data.file !== filePath) return false;
          if (n.data.id === nodeData.id) return true; // Include the class itself
          if (n.data.type === 'method') {
            const line = n.data.line || 0;
            return line >= classLine && line <= classLineEnd;
          }
          return false;
        });

        // Find edges between these nodes
        const nodeIds = new Set(nodes.map(n => n.data.id));
        edges = vizData.graphs.callGraph.edges.filter(e =>
          nodeIds.has(e.data.source) && nodeIds.has(e.data.target)
        );
      }
      // For functions/methods: show what they call (focus mode)
      else if (nodeData.type === 'function' || nodeData.type === 'method') {
        // Save current state before drilling
        drillHistory.push({
          view: currentView,
          label: getBreadcrumbLabel(currentView),
          description: document.getElementById('view-description').innerHTML
        });
        updateBackButton();

        // Update breadcrumb
        const breadcrumbItems = drillHistory.map(h => ({ label: h.label }));
        breadcrumbItems.push({ label: nodeData.label });
        updateBreadcrumb(breadcrumbItems);

        fullCallGraphData = vizData.graphs.callGraph;
        focusOnNode(nodeData.id);

        document.getElementById('view-description').innerHTML =
          '<strong>' + nodeData.label + '</strong> - Shows calls to/from this function. Double-click to explore further.';
        return;
      }
      // Default: show structures in same file
      else if (nodeData.file) {
        const filePath = nodeData.file;
        title = 'Structures in ' + filePath.split('/').pop();

        const allNodes = vizData.graphs.callGraph.nodes;
        nodes = allNodes.filter(n => n.data.file === filePath);

        const nodeIds = new Set(nodes.map(n => n.data.id));
        edges = vizData.graphs.callGraph.edges.filter(e =>
          nodeIds.has(e.data.source) && nodeIds.has(e.data.target)
        );
      }

      if (nodes.length > 0) {
        // Save current state before drilling
        drillHistory.push({
          view: currentView,
          label: getBreadcrumbLabel(currentView),
          description: document.getElementById('view-description').innerHTML
        });
        updateBackButton();

        // Update breadcrumb
        const breadcrumbItems = drillHistory.map(h => ({ label: h.label }));
        breadcrumbItems.push({ label: title.replace('Structures in ', '').replace('Contents of ', '') });
        updateBreadcrumb(breadcrumbItems);

        initCytoscape({ nodes, edges });
        document.getElementById('view-description').innerHTML =
          '<strong>' + title + '</strong> - Double-click to drill deeper.';
      }
    }

    function getBreadcrumbLabel(view) {
      const labels = {
        overview: 'Files',
        callGraph: 'Call Graph',
        dependencies: 'Dependencies',
        classes: 'Classes',
        decisions: 'Decisions',
      };
      return labels[view] || view;
    }

    // Go back to previous view
    function goBack() {
      if (drillHistory.length === 0) return;

      const prev = drillHistory.pop();
      updateBackButton();

      // Restore the previous view
      switchView(prev.view);
    }

    // Update back button visibility
    function updateBackButton() {
      const btn = document.getElementById('back-btn');
      if (drillHistory.length > 0) {
        btn.classList.add('visible');
      } else {
        btn.classList.remove('visible');
      }
    }

    function applyFilters() {
      if (!cy) return;

      const filters = {
        function: document.getElementById('filter-function').checked,
        class: document.getElementById('filter-class').checked,
        method: document.getElementById('filter-method').checked,
        interface: document.getElementById('filter-interface').checked,
        type: document.getElementById('filter-type').checked,
        file: document.getElementById('filter-file').checked,
      };

      cy.nodes().forEach(node => {
        const type = node.data('type');
        const visible = filters[type] !== false;
        node.style('display', visible ? 'element' : 'none');
      });

      // Refit to show visible nodes
      setTimeout(() => {
        cy.fit(cy.nodes(':visible'), 50);
      }, 50);
    }

    // View mode toggle (visual vs list)
    function setViewMode(mode) {
      currentViewMode = mode;

      // Update toggle buttons
      document.querySelectorAll('.view-toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });

      // Toggle visibility
      const cyEl = document.getElementById('cy');
      const listEl = document.getElementById('list-view');
      const legendEl = document.getElementById('legend');

      if (mode === 'visual') {
        cyEl.classList.remove('hidden');
        listEl.classList.remove('active');
        legendEl.classList.remove('hidden');
        if (cy) {
          setTimeout(() => {
            cy.resize();
            cy.fit(50);
          }, 50);
        }
      } else {
        cyEl.classList.add('hidden');
        listEl.classList.add('active');
        legendEl.classList.add('hidden');
        renderListView();
      }
    }

    // Render list view for current data
    function renderListView() {
      const listEl = document.getElementById('list-view');
      const graphData = currentView === 'callGraph' ? fullCallGraphData : vizData.graphs[currentView];

      if (!graphData || graphData.nodes.length === 0) {
        listEl.innerHTML = '<div class="empty-state"><h3>No data</h3><p>No items to display for this view</p></div>';
        return;
      }

      // Group nodes by type
      const byType = {};
      for (const node of graphData.nodes) {
        const type = node.data.type || 'other';
        if (!byType[type]) byType[type] = [];
        byType[type].push(node.data);
      }

      // Sort types
      const typeOrder = ['file', 'class', 'interface', 'function', 'method', 'type', 'variable', 'module', 'decision', 'pattern', 'rejection'];
      const sortedTypes = Object.keys(byType).sort((a, b) => {
        const aIdx = typeOrder.indexOf(a);
        const bIdx = typeOrder.indexOf(b);
        return (aIdx === -1 ? 999 : aIdx) - (bIdx === -1 ? 999 : bIdx);
      });

      let html = '';
      for (const type of sortedTypes) {
        const items = byType[type];
        html += '<div class="list-section">';
        html += '<h4>' + type + 's (' + items.length + ')</h4>';

        // Sort items by name
        items.sort((a, b) => (a.label || '').localeCompare(b.label || ''));

        for (const item of items) {
          html += '<div class="list-item" data-id="' + escapeHtml(item.id) + '">';
          html += '<span class="tag ' + type + '">' + type + '</span>';
          html += '<div class="list-item-content">';
          html += '<div class="list-item-name">' + escapeHtml(item.label) + '</div>';
          if (item.file) {
            html += '<div class="list-item-location">' + escapeHtml(item.file);
            if (item.line) html += ':' + item.line;
            html += '</div>';
          }
          if (item.signature) {
            html += '<div class="list-item-signature">' + escapeHtml(item.signature) + '</div>';
          }
          html += '</div></div>';
        }
        html += '</div>';
      }

      listEl.innerHTML = html;

      // Add click handlers
      listEl.querySelectorAll('.list-item').forEach(item => {
        item.addEventListener('click', () => {
          const id = item.dataset.id;
          const nodeData = graphData.nodes.find(n => n.data.id === id);
          if (nodeData) {
            showDetails(nodeData.data);
          }
        });

        // Double-click to drill down
        item.addEventListener('dblclick', () => {
          const id = item.dataset.id;
          const nodeData = graphData.nodes.find(n => n.data.id === id);
          if (nodeData) {
            drillDown(nodeData.data);
          }
        });
      });
    }

    function searchNodes(query) {
      const searchInput = document.getElementById('search');

      if (!query) {
        // Reset visual view
        if (cy) {
          cy.nodes().style('opacity', 1);
          cy.nodes().removeClass('search-match');
        }
        // Reset list view filter
        if (currentViewMode === 'list') {
          document.querySelectorAll('.list-item').forEach(item => {
            item.style.display = '';
          });
          document.querySelectorAll('.list-section').forEach(section => {
            section.style.display = '';
          });
        }
        return;
      }

      query = query.toLowerCase();

      // Get the data source for current view
      const graphData = currentView === 'callGraph' ? fullCallGraphData : vizData.graphs[currentView];

      if (!graphData) return;

      // Search across name, file, and signature
      const matches = graphData.nodes.filter(n => {
        const label = (n.data.label || '').toLowerCase();
        const file = (n.data.file || '').toLowerCase();
        const signature = (n.data.signature || '').toLowerCase();
        return label.includes(query) || file.includes(query) || signature.includes(query);
      });

      // Handle list view
      if (currentViewMode === 'list') {
        document.querySelectorAll('.list-item').forEach(item => {
          const name = item.querySelector('.list-item-name');
          const location = item.querySelector('.list-item-location');
          const signature = item.querySelector('.list-item-signature');
          const text = [
            name ? name.textContent : '',
            location ? location.textContent : '',
            signature ? signature.textContent : ''
          ].join(' ').toLowerCase();
          item.style.display = text.includes(query) ? '' : 'none';
        });

        // Hide empty sections
        document.querySelectorAll('.list-section').forEach(section => {
          const visibleItems = section.querySelectorAll('.list-item[style=""], .list-item:not([style])');
          const hasVisible = Array.from(section.querySelectorAll('.list-item')).some(
            item => item.style.display !== 'none'
          );
          section.style.display = hasVisible ? '' : 'none';
        });
        return;
      }

      // Handle visual view
      if (matches.length === 0) {
        // No matches - show message
        document.getElementById('details-content').innerHTML = `
          <div class="empty-state">
            <h3>No matches</h3>
            <p>No results for "${escapeHtml(query)}"</p>
          </div>
        `;
        if (cy) cy.nodes().style('opacity', 0.2);
        return;
      }

      // For call graph, rebuild with matching nodes
      if (currentView === 'callGraph' && fullCallGraphData) {
        if (matches.length === 1) {
          focusOnNode(matches[0].data.id);
        } else if (matches.length <= 30) {
          // Show matching nodes with their connections
          const matchIds = new Set(matches.map(m => m.data.id));
          const relevantEdges = fullCallGraphData.edges.filter(e =>
            matchIds.has(e.data.source) || matchIds.has(e.data.target)
          );

          // Add connected nodes
          for (const edge of relevantEdges) {
            matchIds.add(edge.data.source);
            matchIds.add(edge.data.target);
          }

          const focusedNodes = fullCallGraphData.nodes.filter(n => matchIds.has(n.data.id));
          initCytoscape({ nodes: focusedNodes, edges: relevantEdges });

          document.getElementById('view-description').innerHTML =
            '<strong>Search results</strong> - Found ' + matches.length + ' matches for "' + escapeHtml(query) + '"';
        } else {
          // Too many - show clickable list
          const listHtml = matches.slice(0, 30).map(m =>
            '<div style="padding: 6px 0; cursor: pointer; color: #e94560; border-bottom: 1px solid #0f3460;" onclick="focusOnNode(\'' + m.data.id + '\')">' +
            escapeHtml(m.data.label) +
            '<span style="color: #666; font-size: 11px; margin-left: 8px;">' + (m.data.file ? m.data.file.split("/").pop() : '') + '</span></div>'
          ).join('');
          document.getElementById('details-content').innerHTML = `
            <div class="detail-row">
              <div class="detail-label">${matches.length} matches found</div>
              <div style="margin-top: 8px;">${listHtml}</div>
              ${matches.length > 30 ? '<div style="color: #666; margin-top: 8px;">...and ' + (matches.length - 30) + ' more</div>' : ''}
            </div>
          `;
        }
        return;
      }

      // For other views, highlight matches
      if (cy) {
        const matchIds = new Set(matches.map(m => m.data.id));
        cy.nodes().forEach(node => {
          const isMatch = matchIds.has(node.data('id'));
          node.style('opacity', isMatch ? 1 : 0.15);
        });

        // Fit to show matches
        const matchingNodes = cy.nodes().filter(n => matchIds.has(n.data('id')));
        if (matchingNodes.length > 0 && matchingNodes.length < 20) {
          cy.fit(matchingNodes, 80);
        }
      }
    }

    // Event listeners
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Clear history when manually switching tabs
        drillHistory = [];
        updateBackButton();
        switchView(tab.dataset.view);
        // Reset breadcrumb to just the view name
        updateBreadcrumb([{ label: getBreadcrumbLabel(tab.dataset.view) }]);
      });
    });

    document.getElementById('back-btn').addEventListener('click', goBack);

    document.getElementById('layout-select').addEventListener('change', runLayout);

    document.querySelectorAll('[id^="filter-"]').forEach(checkbox => {
      checkbox.addEventListener('change', applyFilters);
    });

    document.getElementById('search').addEventListener('input', (e) => {
      searchNodes(e.target.value);
    });

    // View mode toggle (visual/list)
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.addEventListener('click', () => setViewMode(btn.dataset.mode));
    });

    // Flow mode radio buttons
    document.querySelectorAll('input[name="flow-mode"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        flowMode = e.target.value;
        // Update hint text based on mode
        const hint = document.querySelector('#flow-mode-group p');
        if (hint) {
          if (flowMode === 'connections') {
            hint.textContent = 'Click a function to see its connections';
          } else if (flowMode === 'downstream') {
            hint.textContent = 'Click a function to trace what it calls';
          } else if (flowMode === 'upstream') {
            hint.textContent = 'Click a function to trace what calls it';
          }
        }
      });
    });

    // Fullscreen toggle
    function toggleFullscreen() {
      const isFullscreen = document.body.classList.toggle('fullscreen');
      document.getElementById('exit-fullscreen').style.display = isFullscreen ? 'block' : 'none';

      // When exiting fullscreen, reinitialize the view to fix layout
      if (!isFullscreen) {
        setTimeout(() => {
          switchView(currentView);
        }, 300);
      } else if (cy && currentViewMode === 'visual') {
        // Entering fullscreen - just resize
        setTimeout(() => {
          cy.resize();
          cy.fit(50);
        }, 100);
      }
    }

    document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
    document.getElementById('exit-fullscreen').addEventListener('click', toggleFullscreen);
    document.getElementById('close-details').addEventListener('click', clearDetails);

    // ESC key to exit fullscreen
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('fullscreen')) {
        toggleFullscreen();
      }
    });

    // Initialize
    switchView('overview');
    updateBreadcrumb([{ label: 'Files' }]);
    maybeShowWelcome();
  </script>
</body>
</html>